module.exports = {

"[project]/node_modules/@thirdweb-dev/wallets/dist/errors-35fc3528.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "A": (()=>AddChainError),
    "C": (()=>ChainNotConfiguredError),
    "P": (()=>ProviderRpcError),
    "R": (()=>ResourceUnavailableError),
    "S": (()=>SwitchChainError),
    "U": (()=>UserRejectedRequestError),
    "a": (()=>ConnectorNotFoundError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/defineProperty-7303a112.esm.js [app-ssr] (ecmascript)");
;
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 * @see https://eips.ethereum.org/EIPS/eip-1474
 */ class RpcError extends Error {
    constructor(/** Human-readable string */ message, options){
        const { cause, code, data } = options;
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string.');
        }
        super(`${message}. Cause: ${JSON.stringify(cause)}`);
        this.cause = cause;
        this.code = code;
        this.data = data;
    }
}
/**
 * @internal
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * @see https://eips.ethereum.org/EIPS/eip-1193
 */ class ProviderRpcError extends RpcError {
    /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the `1000 <= 4999` range.
   */ constructor(/** Human-readable string */ message, options){
        const { cause, code, data } = options;
        if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(message, {
            cause,
            code,
            data
        });
    }
}
/**
 * @internal
 */ class AddChainError extends Error {
    constructor(){
        super(...arguments);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "AddChainError");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "message", "Error adding chain");
    }
}
/**
 * @internal
 */ class ChainNotConfiguredError extends Error {
    constructor(_ref){
        let { chainId, connectorId } = _ref;
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "ChainNotConfigured");
    }
}
class ConnectorNotFoundError extends Error {
    constructor(){
        super(...arguments);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "ConnectorNotFoundError");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "message", "Connector not found");
    }
}
class ResourceUnavailableError extends RpcError {
    constructor(cause){
        super("Resource unavailable", {
            cause,
            code: -32002
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "ResourceUnavailable");
    }
}
/**
 * @internal
 */ class SwitchChainError extends ProviderRpcError {
    constructor(cause){
        super("Error switching chain", {
            cause,
            code: 4902
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "SwitchChainError");
    }
}
/**
 * @internal
 */ class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause){
        super("User rejected request", {
            cause,
            code: 4001
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "name", "UserRejectedRequestError");
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-6011bbb1.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "W": (()=>WagmiConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$chains$2f$dist$2f$thirdweb$2d$dev$2d$chains$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
;
;
class WagmiConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    /** Unique connector id */ /** Connector name */ /** Chains connector supports */ /** Options to use with connector */ /** Whether connector is usable */ constructor(_ref){
        let { chains = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$chains$2f$dist$2f$thirdweb$2d$dev$2d$chains$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultChains"], options } = _ref;
        super();
        this.chains = chains;
        this.options = options;
    }
    getBlockExplorerUrls(chain) {
        const explorers = chain.explorers?.map((x)=>x.url) ?? [];
        return explorers.length > 0 ? explorers : undefined;
    }
    isChainUnsupported(chainId) {
        return !this.chains.some((x)=>x.chainId === chainId);
    }
    updateChains(chains) {
        this.chains = chains;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-abcb61d5.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @internal
 */ __turbopack_context__.s({
    "n": (()=>normalizeChainId)
});
function normalizeChainId(chainId) {
    if (typeof chainId === "string") {
        return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    }
    if (typeof chainId === "bigint") {
        return Number(chainId);
    }
    return chainId;
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "InjectedConnector": (()=>InjectedConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/defineProperty-7303a112.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$WagmiConnector$2d$6011bbb1$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-6011bbb1.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/errors-35fc3528.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$assertWindowEthereum$2d$2bcf9787$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/assertWindowEthereum-2bcf9787.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$url$2d$0d129c6b$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/url-0d129c6b.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-ssr] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__providers$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/providers/lib.esm/index.js [app-ssr] (ecmascript) <export * as providers>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$normalizeChainId$2d$abcb61d5$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-abcb61d5.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <module evaluation>");
;
;
;
;
;
;
;
;
;
function getInjectedName(ethereum) {
    if (!ethereum) {
        return "Injected";
    }
    const getName = (provider)=>{
        if (provider.isAvalanche) {
            return "Core Wallet";
        }
        if (provider.isBitKeep) {
            return "BitKeep";
        }
        if (provider.isBraveWallet) {
            return "Brave Wallet";
        }
        if (provider.isCoinbaseWallet) {
            return "Coinbase Wallet";
        }
        if (provider.isExodus) {
            return "Exodus";
        }
        if (provider.isFrame) {
            return "Frame";
        }
        if (provider.isKuCoinWallet) {
            return "KuCoin Wallet";
        }
        if (provider.isMathWallet) {
            return "MathWallet";
        }
        if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {
            return "1inch Wallet";
        }
        if (provider.isOpera) {
            return "Opera";
        }
        if (provider.isPortal) {
            return "Ripio Portal";
        }
        if (provider.isTally) {
            return "Tally";
        }
        if (provider.isTokenPocket) {
            return "TokenPocket";
        }
        if (provider.isTokenary) {
            return "Tokenary";
        }
        if (provider.isTrust || provider.isTrustWallet) {
            return "Trust Wallet";
        }
        if (provider.isMetaMask) {
            return "MetaMask";
        }
        if (provider.isImToken) {
            return "imToken";
        }
    };
    // Some injected providers detect multiple other providers and create a list at `ethers.providers`
    if (ethereum.providers?.length) {
        // Deduplicate names using Set
        // Coinbase Wallet puts multiple providers in `ethereum.providers`
        const nameSet = new Set();
        let unknownCount = 1;
        for (const provider of ethereum.providers){
            let name = getName(provider);
            if (!name) {
                name = `Unknown Wallet #${unknownCount}`;
                unknownCount += 1;
            }
            nameSet.add(name);
        }
        const names = [
            ...nameSet
        ];
        if (names.length) {
            return names;
        }
        return names[0] ?? "Injected";
    }
    return getName(ethereum) ?? "Injected";
}
class InjectedConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$WagmiConnector$2d$6011bbb1$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["W"] {
    constructor(arg){
        const defaultOptions = {
            shimDisconnect: true,
            getProvider: ()=>{
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$assertWindowEthereum$2d$2bcf9787$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(globalThis.window)) {
                    return globalThis.window.ethereum;
                }
            }
        };
        const options = {
            ...defaultOptions,
            ...arg.options
        };
        super({
            chains: arg.chains,
            options
        });
        /**
     * Name of the injected connector
     */ /**
     * Whether the connector is ready to be used
     *
     * `true` if the injected provider is found
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "shimDisconnectKey", "injected.shimDisconnect");
        /**
     * handles the `accountsChanged` event from the provider
     * * emits `change` event if connected to a different account
     * * emits `disconnect` event if no accounts available
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "onAccountsChanged", async (accounts)=>{
            if (accounts.length === 0) {
                this.emit("disconnect");
            } else {
                this.emit("change", {
                    account: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0])
                });
            }
        });
        /**
     * handles the `chainChanged` event from the provider
     * * emits `change` event if connected to a different chain
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "onChainChanged", (chainId)=>{
            const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$normalizeChainId$2d$abcb61d5$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"])(chainId);
            const unsupported = this.isChainUnsupported(id);
            this.emit("change", {
                chain: {
                    id,
                    unsupported
                }
            });
        });
        /**
     * handles the `disconnect` event from the provider
     * * emits `disconnect` event
     */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "onDisconnect", async (error)=>{
            // We need this as MetaMask can emit the "disconnect" event upon switching chains.
            // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
            // https://github.com/MetaMask/providers/pull/120
            if (error.code === 1013) {
                const provider = await this.getProvider();
                if (provider) {
                    try {
                        const isAuthorized = await this.getAccount();
                        if (isAuthorized) {
                            return;
                        }
                    } catch  {
                    // If we can't get the account anymore, continue with disconnect
                    }
                }
            }
            this.emit("disconnect");
            // Remove `shimDisconnect` => it signals that wallet is disconnected
            if (this.options.shimDisconnect) {
                await this.connectorStorage.removeItem(this.shimDisconnectKey);
            }
        });
        const _provider = options.getProvider();
        // set the name of the connector
        if (typeof options.name === "string") {
            // if name is given, use that
            this.name = options.name;
        } else if (_provider) {
            // if injected provider is detected, get name from it
            const detectedName = getInjectedName(_provider);
            if (options.name) {
                this.name = options.name(detectedName);
            } else {
                if (typeof detectedName === "string") {
                    this.name = detectedName;
                } else {
                    this.name = detectedName[0];
                }
            }
        } else {
            // else default to "Injected"
            this.name = "Injected";
        }
        this.id = "injected";
        this.ready = !!_provider;
        this.connectorStorage = arg.connectorStorage;
    }
    /**
   * * Connect to the injected provider
   * * switch to the given chain if `chainId` is specified as an argument
   */ async connect() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        try {
            const provider = await this.getProvider();
            if (!provider) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
            }
            this.setupListeners();
            // emit "connecting" event
            this.emit("message", {
                type: "connecting"
            });
            // request account addresses from injected provider
            const accountAddresses = await provider.request({
                method: "eth_requestAccounts"
            });
            // get the first account address
            const firstAccountAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accountAddresses[0]);
            // Switch to given chain if a chainId is specified
            let connectedChainId = await this.getChainId();
            // Check if currently connected chain is unsupported
            // chainId is considered unsupported if chainId is not in the list of this.chains array
            let isUnsupported = this.isChainUnsupported(connectedChainId);
            // if chainId is specified and it is not the same as the currently connected chain
            if (options.chainId && connectedChainId !== options.chainId) {
                // switch to the given chain
                try {
                    await this.switchChain(options.chainId);
                    // recalculate connectedChainId and isUnsupported
                    connectedChainId = options.chainId;
                    isUnsupported = this.isChainUnsupported(options.chainId);
                } catch (e) {
                    console.error(`Could not switch to chain id: ${options.chainId}`, e);
                }
            }
            // if shimDisconnect is enabled
            if (this.options.shimDisconnect) {
                // add the shim shimDisconnectKey => it signals that wallet is connected
                await this.connectorStorage.setItem(this.shimDisconnectKey, "true");
            }
            const connectionInfo = {
                account: firstAccountAddress,
                chain: {
                    id: connectedChainId,
                    unsupported: isUnsupported
                },
                provider
            };
            this.emit("connect", connectionInfo);
            return connectionInfo;
        } catch (error) {
            if (this.isUserRejectedRequestError(error)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"](error);
            }
            if (error.code === -32002) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"](error);
            }
            throw error;
        }
    }
    /**
   * disconnect from the injected provider
   */ async disconnect() {
        // perform cleanup
        const provider = await this.getProvider();
        if (!provider?.removeListener) {
            return;
        }
        provider.removeListener("accountsChanged", this.onAccountsChanged);
        provider.removeListener("chainChanged", this.onChainChanged);
        provider.removeListener("disconnect", this.onDisconnect);
        // if shimDisconnect is enabled
        if (this.options.shimDisconnect) {
            // Remove the shimDisconnectKey => it signals that wallet is disconnected
            await this.connectorStorage.removeItem(this.shimDisconnectKey);
        }
    }
    /**
   * @returns The first account address from the injected provider
   */ async getAccount() {
        const provider = await this.getProvider();
        if (!provider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
        }
        const accounts = await provider.request({
            method: "eth_accounts"
        });
        // return checksum address
        // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0]);
    }
    /**
   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`
   */ async getChainId() {
        const provider = await this.getProvider();
        if (!provider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
        }
        return provider.request({
            method: "eth_chainId"
        }).then(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$normalizeChainId$2d$abcb61d5$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"]);
    }
    /**
   * get the injected provider
   */ async getProvider() {
        const provider = this.options.getProvider();
        if (provider) {
            this._provider = provider;
        // setting listeners
        }
        return this._provider;
    }
    /**
   * get a `signer` for given `chainId`
   */ async getSigner() {
        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const [provider, account] = await Promise.all([
            this.getProvider(),
            this.getAccount()
        ]);
        // ethers.providers.Web3Provider
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__providers$3e$__["providers"].Web3Provider(provider, chainId).getSigner(account);
    }
    /**
   *
   * @returns `true` if the connector is connected and address is available, else `false`
   */ async isAuthorized() {
        try {
            // `false` if connector is disconnected
            if (this.options.shimDisconnect && // If shim does not exist in storage, wallet is disconnected
            !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {
                return false;
            }
            const provider = await this.getProvider();
            if (!provider) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
            }
            // `false` if no account address available, else `true`
            const account = await this.getAccount();
            return !!account;
        } catch  {
            // `false` if any error thrown
            return false;
        }
    }
    /**
   * switch to given chain
   */ async switchChain(chainId) {
        const provider = await this.getProvider();
        if (!provider) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
        }
        const chainIdHex = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexValue(chainId);
        try {
            // request provider to switch to given chainIdHex
            await provider.request({
                method: "wallet_switchEthereumChain",
                params: [
                    {
                        chainId: chainIdHex
                    }
                ]
            });
            const chain = this.chains.find((_chain)=>_chain.chainId === chainId);
            if (chain) {
                return chain;
            }
            return {
                chainId: chainId,
                name: `Chain ${chainIdHex}`,
                slug: `${chainIdHex}`,
                nativeCurrency: {
                    name: "Ether",
                    decimals: 18,
                    symbol: "ETH"
                },
                rpc: [
                    ""
                ],
                chain: "",
                shortName: "",
                testnet: true
            };
        } catch (error) {
            // if could not switch to given chainIdHex
            // if tried to connect to a chain that is not configured
            const chain = this.chains.find((_chain)=>_chain.chainId === chainId);
            if (!chain) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]({
                    chainId,
                    connectorId: this.id
                });
            }
            // if chain is not added to provider
            if (error.code === 4902 || // Unwrapping for MetaMask Mobile
            // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
            error?.data?.originalError?.code === 4902) {
                try {
                    // request provider to add chain
                    await provider.request({
                        method: "wallet_addEthereumChain",
                        params: [
                            {
                                chainId: chainIdHex,
                                chainName: chain.name,
                                nativeCurrency: chain.nativeCurrency,
                                rpcUrls: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$url$2d$0d129c6b$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"])(chain),
                                // no client id on purpose here
                                blockExplorerUrls: this.getBlockExplorerUrls(chain)
                            }
                        ]
                    });
                    return chain;
                } catch (addError) {
                    // if user rejects request to add chain
                    if (this.isUserRejectedRequestError(addError)) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"](error);
                    }
                    // else other error
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["A"]();
                }
            }
            if (this.isUserRejectedRequestError(error)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"](error);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"](error);
        }
    }
    async setupListeners() {
        const provider = await this.getProvider();
        if (provider.on) {
            provider.on("accountsChanged", this.onAccountsChanged);
            provider.on("chainChanged", this.onChainChanged);
            provider.on("disconnect", this.onDisconnect);
        }
    }
    isUserRejectedRequestError(error) {
        return error.code === 4001;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/evm/connectors/rabby/dist/thirdweb-dev-wallets-evm-connectors-rabby.esm.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RabbyConnector": (()=>RabbyConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/defineProperty-7303a112.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/errors-35fc3528.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$walletIds$2d$c34dbb3f$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/walletIds-c34dbb3f.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$evm$2f$connectors$2f$injected$2f$dist$2f$thirdweb$2d$dev$2d$wallets$2d$evm$2d$connectors$2d$injected$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-ssr] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$getInjectedRabbyProvider$2d$71aa751e$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/getInjectedRabbyProvider-71aa751e.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <module evaluation>");
;
;
;
;
;
;
;
;
;
;
;
;
class RabbyConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$evm$2f$connectors$2f$injected$2f$dist$2f$thirdweb$2d$dev$2d$wallets$2d$evm$2d$connectors$2d$injected$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InjectedConnector"] {
    constructor(arg){
        const defaultOptions = {
            name: "Rabby Wallet",
            shimDisconnect: true,
            shimChainChangedDisconnect: true,
            getProvider: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$getInjectedRabbyProvider$2d$71aa751e$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]
        };
        const options = {
            ...defaultOptions,
            ...arg.options
        };
        super({
            chains: arg.chains,
            options,
            connectorStorage: arg.connectorStorage
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$7303a112$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"])(this, "id", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$walletIds$2d$c34dbb3f$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"].rabby);
    }
    /**
   * Connect to injected RabbyWallet provider
   */ async connect() {
        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        try {
            const provider = await this.getProvider();
            if (!provider) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]();
            }
            this.setupListeners();
            // emit "connecting" event
            this.emit("message", {
                type: "connecting"
            });
            // Attempt to show wallet select prompt with `wallet_requestPermissions` when
            // `shimDisconnect` is active and account is in disconnected state (flag in storage)
            let account = null;
            if (this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {
                account = await this.getAccount().catch(()=>null);
                const isConnected = !!account;
                if (isConnected) {
                    // Attempt to show another prompt for selecting wallet if already connected
                    try {
                        await provider.request({
                            method: "wallet_requestPermissions",
                            params: [
                                {
                                    eth_accounts: {}
                                }
                            ]
                        });
                    } catch (error) {
                        // Not all injected providers support `wallet_requestPermissions` (e.g. iOS).
                        // Only bubble up error if user rejects request
                        if (this.isUserRejectedRequestError(error)) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"](error);
                        }
                    }
                }
            }
            // if account is not already set, request accounts and use the first account
            if (!account) {
                const accounts = await provider.request({
                    method: "eth_requestAccounts"
                });
                account = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0]);
            }
            // get currently connected chainId
            let connectedChainId = await this.getChainId();
            // check if connected chain is unsupported
            let isUnsupported = this.isChainUnsupported(connectedChainId);
            // if chainId is given, but does not match the currently connected chainId, switch to the given chainId
            if (options.chainId && connectedChainId !== options.chainId) {
                try {
                    await this.switchChain(options.chainId);
                    // recalculate the chainId and isUnsupported
                    connectedChainId = options.chainId;
                    isUnsupported = this.isChainUnsupported(options.chainId);
                } catch (e) {
                    console.error(`Could not switch to chain id : ${options.chainId}`, e);
                }
            }
            // if shimDisconnect is enabled
            if (this.options?.shimDisconnect) {
                // add shimDisconnectKey in storage - this signals that connector is "connected"
                await this.connectorStorage.setItem(this.shimDisconnectKey, "true");
            }
            const connectionInfo = {
                chain: {
                    id: connectedChainId,
                    unsupported: isUnsupported
                },
                provider: provider,
                account
            };
            this.emit("connect", connectionInfo);
            return connectionInfo;
        } catch (error) {
            if (this.isUserRejectedRequestError(error)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"](error);
            }
            if (error.code === -32002) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$35fc3528$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"](error);
            }
            throw error;
        }
    }
}
;
}}),

};

//# sourceMappingURL=node_modules_%40thirdweb-dev_wallets_f8181e92._.js.map