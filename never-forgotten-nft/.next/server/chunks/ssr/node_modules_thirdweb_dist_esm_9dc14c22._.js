module.exports = {

"[project]/node_modules/thirdweb/dist/esm/utils/caching/lru.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Represents a Least Recently Used (LRU) Map.
 * Extends the built-in Map class.
 */ __turbopack_context__.s({
    "LruMap": (()=>LruMap)
});
class LruMap extends Map {
    /**
     *
     * @param size
     * @internal
     */ constructor(size){
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    /**
     *
     * @param key
     * @param value
     * @internal
     */ set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            this.delete(this.keys().next().value);
        }
        return this;
    }
} //# sourceMappingURL=lru.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/text-encoder.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cachedTextEncoder": (()=>cachedTextEncoder)
});
let textEncoder;
function cachedTextEncoder() {
    if (!textEncoder) {
        textEncoder = new TextEncoder();
    }
    return textEncoder;
} //# sourceMappingURL=text-encoder.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Checks if a value is a valid hexadecimal string.
 * @param value - The value to be checked.
 * @param options - Optional configuration for the validation.
 * @returns True if the value is a valid hexadecimal string, false otherwise.
 * @example
 * ```ts
 * import { isHex } from "thirdweb/utils";
 * const result = isHex("0x1a4");
 * console.log(result); // true
 * ```
 * @utils
 */ __turbopack_context__.s({
    "isHex": (()=>isHex)
});
function isHex(value, options = {}) {
    if (!value) {
        return false;
    }
    if (typeof value !== "string") {
        return false;
    }
    return options.strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
} //# sourceMappingURL=is-hex.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/byte-size.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "byteSize": (()=>byteSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js [app-ssr] (ecmascript)");
;
function byteSize(value) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHex"])(value, {
        strict: false
    })) {
        return Math.ceil((value.length - 2) / 2);
    }
    return value.length;
} //# sourceMappingURL=byte-size.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/assert-size.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "assertSize": (()=>assertSize)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/byte-size.js [app-ssr] (ecmascript)");
;
function assertSize(hexOrBytes, { size }) {
    const givenSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(hexOrBytes);
    if (givenSize > size) {
        throw new Error(`Size overflow: ${givenSize} > ${size}`);
    }
} //# sourceMappingURL=assert-size.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/charcode-to-base-16.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "charCodeToBase16": (()=>charCodeToBase16)
});
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine) {
        return char - charCodeMap.zero;
    }
    if (char >= charCodeMap.A && char <= charCodeMap.F) {
        return char - (charCodeMap.A - 10);
    }
    if (char >= charCodeMap.a && char <= charCodeMap.f) {
        return char - (charCodeMap.a - 10);
    }
    return undefined;
} //# sourceMappingURL=charcode-to-base-16.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/text-decoder.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cachedTextDecoder": (()=>cachedTextDecoder)
});
let textDecoder;
function cachedTextDecoder() {
    if (!textDecoder) {
        textDecoder = new TextDecoder();
    }
    return textDecoder;
} //# sourceMappingURL=text-decoder.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/hex.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "boolToHex": (()=>boolToHex),
    "fromHex": (()=>fromHex),
    "hexToBigInt": (()=>hexToBigInt),
    "hexToBool": (()=>hexToBool),
    "hexToNumber": (()=>hexToNumber),
    "hexToString": (()=>hexToString),
    "hexToUint8Array": (()=>hexToUint8Array),
    "numberToHex": (()=>numberToHex),
    "padHex": (()=>padHex),
    "stringToHex": (()=>stringToHex),
    "toHex": (()=>toHex),
    "uint8ArrayToHex": (()=>uint8ArrayToHex)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/text-decoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/text-encoder.js [app-ssr] (ecmascript)");
// slightly tweaked re-exports from viem for the moment
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/assert-size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/charcode-to-base-16.js [app-ssr] (ecmascript)");
;
;
;
;
;
function trim(hexOrBytes, options = {}) {
    const dir = options.dir || "left";
    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
    let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === "left" ? i : data.length - i - 1].toString() === "0") {
            sliceLength++;
        } else {
            break;
        }
    }
    data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === "string") {
        if (data.length === 1 && dir === "right") {
            data = `${data}0`;
        }
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}
function padHex(hex_, options = {}) {
    const { dir, size = 32 } = options;
    if (size === null) {
        return hex_;
    }
    const hex = hex_.replace("0x", "");
    if (hex.length > size * 2) {
        throw new Error(`Size overflow: ${Math.ceil(hex.length / 2)} > ${size}`);
    }
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size * 2, "0")}`;
}
function hexToString(hex, opts = {}) {
    let bytes = hexToUint8Array(hex);
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(bytes, {
            size: opts.size
        });
        bytes = trim(bytes, {
            dir: "right"
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cachedTextDecoder"])().decode(bytes);
}
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
    }
    const value = BigInt(hex);
    if (!signed) {
        return value;
    }
    const size = (hex.length - 2) / 2;
    const max = (1n << BigInt(size) * 8n - 1n) - 1n;
    if (value <= max) {
        return value;
    }
    return value - BigInt(`0x${"f".padStart(size * 2, "f")}`) - 1n;
}
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
function hexToBool(hex, opts = {}) {
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        // biome-ignore lint/style/noParameterAssign: for perf
        hex = trim(hex);
    }
    if (trim(hex) === "0x00") {
        return false;
    }
    if (trim(hex) === "0x01") {
        return true;
    }
    throw new Error(`Invalid hex boolean: ${hex}`);
}
function hexToUint8Array(hex, opts = {}) {
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        // biome-ignore lint/style/noParameterAssign: for perf
        hex = padHex(hex, {
            dir: "right",
            size: opts.size
        });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) {
        hexString = `0${hexString}`;
    }
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for(let index = 0, j = 0; index < length; index++){
        const nibbleLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["charCodeToBase16"])(hexString.charCodeAt(j++));
        const nibbleRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["charCodeToBase16"])(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new Error(`Invalid hex character: ${hexString}`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === "string" ? {
        to: toOrOpts
    } : toOrOpts;
    switch(opts.to){
        case "number":
            return hexToNumber(hex, opts);
        case "bigint":
            return hexToBigInt(hex, opts);
        case "string":
            return hexToString(hex, opts);
        case "boolean":
            return hexToBool(hex, opts);
        default:
            return hexToUint8Array(hex, opts);
    }
}
//--------------------------------------------------------------------------
// TO HEX
//--------------------------------------------------------------------------
const hexes = /* @__PURE__ */ (()=>Array.from({
        length: 256
    }, (_v, i)=>i.toString(16).padStart(2, "0")))();
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        return padHex(hex, {
            size: opts.size
        });
    }
    return hex;
}
function uint8ArrayToHex(value, opts = {}) {
    let string = "";
    for(let i = 0; i < value.length; i++){
        // biome-ignore lint/style/noNonNullAssertion: we know this is defined
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === "number") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        return padHex(hex, {
            dir: "right",
            size: opts.size
        });
    }
    return hex;
}
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed) {
            maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        } else {
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
        }
    } else if (typeof value_ === "number") {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === "bigint" ? "n" : "";
        throw new Error(`Number "${value_}${suffix}" is not in safe ${size ? `${size * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${maxValue ? `(${minValue} to ${maxValue})` : `(above ${minValue})`}`);
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size) {
        return padHex(hex, {
            size
        });
    }
    return hex;
}
function stringToHex(value_, opts = {}) {
    const value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cachedTextEncoder"])().encode(value_);
    return uint8ArrayToHex(value, opts);
}
function toHex(value, opts = {}) {
    switch(typeof value){
        case "number":
        case "bigint":
            return numberToHex(value, opts);
        case "string":
            return stringToHex(value, opts);
        case "boolean":
            return boolToHex(value, opts);
        default:
            return uint8ArrayToHex(value, opts);
    }
} //# sourceMappingURL=hex.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "boolToBytes": (()=>boolToBytes),
    "hexToBytes": (()=>hexToBytes),
    "numberToBytes": (()=>numberToBytes),
    "stringToBytes": (()=>stringToBytes),
    "toBytes": (()=>toBytes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/text-encoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/assert-size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/charcode-to-base-16.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/hex.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null) {
        return bytes;
    }
    if (bytes.length > size) {
        throw new Error(`Size overflow: ${bytes.length} > ${size}`);
    }
    const paddedBytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        const padEnd = dir === "right";
        paddedBytes[padEnd ? i : size - i - 1] = // biome-ignore lint/style/noNonNullAssertion: we know its there
        bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
function toBytes(value, opts = {}) {
    switch(typeof value){
        case "number":
        case "bigint":
            return numberToBytes(value, opts);
        case "boolean":
            return boolToBytes(value, opts);
        default:
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHex"])(value)) {
                return hexToBytes(value, opts);
            }
            return stringToBytes(value, opts);
    }
}
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === "number") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(bytes, {
            size: opts.size
        });
        return padBytes(bytes, {
            size: opts.size
        });
    }
    return bytes;
}
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(hex, {
            size: opts.size
        });
        hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])(hex, {
            dir: "right",
            size: opts.size
        });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) {
        hexString = `0${hexString}`;
    }
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for(let index = 0, j = 0; index < length; index++){
        const nibbleLeft = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["charCodeToBase16"])(hexString.charCodeAt(j++));
        const nibbleRight = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$charcode$2d$to$2d$base$2d$16$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["charCodeToBase16"])(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new Error(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function numberToBytes(value, opts) {
    const hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])(value, opts);
    return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$text$2d$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cachedTextEncoder"])().encode(value);
    if (typeof opts.size === "number") {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$assert$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertSize"])(bytes, {
            size: opts.size
        });
        return padBytes(bytes, {
            dir: "right",
            size: opts.size
        });
    }
    return bytes;
} //# sourceMappingURL=to-bytes.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/hashing/sha256.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "sha256": (()=>sha256)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@noble/hashes/esm/sha256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/hex.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js [app-ssr] (ecmascript)");
;
;
function sha256(value, to) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHex"])(value, {
        strict: false
    }) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hexToUint8Array"])(value) : value);
    if (to === "bytes") {
        return bytes;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["uint8ArrayToHex"])(bytes);
} //# sourceMappingURL=sha256.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/client-id.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "computeClientIdFromSecretKey": (()=>computeClientIdFromSecretKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/caching/lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$to$2d$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$hashing$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/hashing/sha256.js [app-ssr] (ecmascript)");
;
;
;
const cache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LruMap"](4096);
function computeClientIdFromSecretKey(secretKey) {
    if (cache.has(secretKey)) {
        return cache.get(secretKey);
    }
    // we slice off the leading `0x` and then take the first 32 chars
    const cId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$hashing$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$to$2d$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringToBytes"])(secretKey)).slice(2, 34);
    cache.set(secretKey, cId);
    return cId;
} //# sourceMappingURL=client-id.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/client/client.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createThirdwebClient": (()=>createThirdwebClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$client$2d$id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/client-id.js [app-ssr] (ecmascript)");
;
function createThirdwebClient(options) {
    const { clientId, secretKey, ...rest } = options;
    // if secretKey is provided, compute the clientId from it (and ignore any clientId passed in)
    if (secretKey) {
        return {
            ...rest,
            clientId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$client$2d$id$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["computeClientIdFromSecretKey"])(secretKey),
            secretKey
        };
    }
    // otherwise if clientId is provided, use it
    if (clientId) {
        return {
            ...rest,
            clientId: options.clientId,
            secretKey: undefined
        };
    }
    // otherwise throw an error
    throw new Error("clientId or secretKey must be provided");
} //# sourceMappingURL=client.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/domains.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_RPC_URL": (()=>DEFAULT_RPC_URL),
    "getThirdwebBaseUrl": (()=>getThirdwebBaseUrl),
    "getThirdwebDomains": (()=>getThirdwebDomains),
    "setThirdwebDomains": (()=>setThirdwebDomains)
});
const DEFAULT_RPC_URL = "rpc.thirdweb.com";
const DEFAULT_IN_APP_WALLET_URL = "embedded-wallet.thirdweb.com";
const DEFAULT_PAY_URL = "pay.thirdweb.com";
const DEFAULT_STORAGE_URL = "storage.thirdweb.com";
const DEFAULT_BUNDLER_URL = "bundler.thirdweb.com";
let domains = {
    rpc: DEFAULT_RPC_URL,
    inAppWallet: DEFAULT_IN_APP_WALLET_URL,
    pay: DEFAULT_PAY_URL,
    storage: DEFAULT_STORAGE_URL,
    bundler: DEFAULT_BUNDLER_URL
};
const setThirdwebDomains = (DomainOverrides)=>{
    domains = {
        rpc: DomainOverrides.rpc ?? DEFAULT_RPC_URL,
        inAppWallet: DomainOverrides.inAppWallet ?? DEFAULT_IN_APP_WALLET_URL,
        pay: DomainOverrides.pay ?? DEFAULT_PAY_URL,
        storage: DomainOverrides.storage ?? DEFAULT_STORAGE_URL,
        bundler: DomainOverrides.bundler ?? DEFAULT_BUNDLER_URL
    };
};
const getThirdwebDomains = ()=>{
    return domains;
};
const getThirdwebBaseUrl = (service)=>{
    const origin = domains[service];
    if (origin.startsWith("localhost")) {
        return `http://${origin}`;
    }
    return `https://${origin}`;
}; //# sourceMappingURL=domains.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/version.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "version": (()=>version)
});
const version = "5.29.6"; //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/detect-platform.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "detectOS": (()=>detectOS),
    "detectPlatform": (()=>detectPlatform)
});
const operatingSystemRules = [
    [
        "iOS",
        /iP(hone|od|ad)/
    ],
    [
        "Android OS",
        /Android/
    ],
    [
        "BlackBerry OS",
        /BlackBerry|BB10/
    ],
    [
        "Windows Mobile",
        /IEMobile/
    ],
    [
        "Amazon OS",
        /Kindle/
    ],
    [
        "Windows 3.11",
        /Win16/
    ],
    [
        "Windows 95",
        /(Windows 95)|(Win95)|(Windows_95)/
    ],
    [
        "Windows 98",
        /(Windows 98)|(Win98)/
    ],
    [
        "Windows 2000",
        /(Windows NT 5.0)|(Windows 2000)/
    ],
    [
        "Windows XP",
        /(Windows NT 5.1)|(Windows XP)/
    ],
    [
        "Windows Server 2003",
        /(Windows NT 5.2)/
    ],
    [
        "Windows Vista",
        /(Windows NT 6.0)/
    ],
    [
        "Windows 7",
        /(Windows NT 6.1)/
    ],
    [
        "Windows 8",
        /(Windows NT 6.2)/
    ],
    [
        "Windows 8.1",
        /(Windows NT 6.3)/
    ],
    [
        "Windows 10",
        /(Windows NT 10.0)/
    ],
    [
        "Windows ME",
        /Windows ME/
    ],
    [
        "Windows CE",
        /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
    ],
    [
        "Open BSD",
        /OpenBSD/
    ],
    [
        "Sun OS",
        /SunOS/
    ],
    [
        "Chrome OS",
        /CrOS/
    ],
    [
        "Linux",
        /(Linux)|(X11)/
    ],
    [
        "Mac OS",
        /(Mac_PowerPC)|(Macintosh)/
    ],
    [
        "QNX",
        /QNX/
    ],
    [
        "BeOS",
        /BeOS/
    ],
    [
        "OS/2",
        /OS\/2/
    ]
];
function detectPlatform() {
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        // react-native
        return "mobile";
    }
    if (typeof navigator !== "undefined") {
        return "browser";
    }
    return "node";
}
function detectOS(ua) {
    for(let ii = 0, count = operatingSystemRules.length; ii < count; ii++){
        const [os, regex] = operatingSystemRules[ii];
        const match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
} //# sourceMappingURL=detect-platform.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getClientFetch": (()=>getClientFetch),
    "getPlatformHeaders": (()=>getPlatformHeaders),
    "isThirdwebUrl": (()=>isThirdwebUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/version.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/caching/lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$detect$2d$platform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/detect-platform.js [app-ssr] (ecmascript)");
;
;
;
const DEFAULT_REQUEST_TIMEOUT = 60000;
const FETCH_CACHE = new WeakMap();
function getClientFetch(client) {
    if (FETCH_CACHE.has(client)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return FETCH_CACHE.get(client);
    }
    /**
     * @internal
     */ async function fetchWithHeaders(url, init) {
        const { requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT, ...restInit } = init || {};
        let headers = restInit.headers ? new Headers(restInit.headers) : undefined;
        // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)
        if (isThirdwebUrl(url)) {
            if (!headers) {
                headers = new Headers();
            }
            const authToken = getTWAuthToken();
            // if we have an auth token set, use that (thirdweb.com/dashboard sets this for the user)
            if (authToken) {
                headers.set("authorization", `Bearer ${authToken}`);
            } else if (client.secretKey) {
                headers.set("x-secret-key", client.secretKey);
            } else if (client.clientId) {
                headers.set("x-client-id", client.clientId);
            }
            // this already internally caches
            for (const [key, value] of getPlatformHeaders()){
                headers.set(key, value);
            }
        }
        let controller;
        let abortTimeout;
        if (requestTimeoutMs) {
            controller = new AbortController();
            abortTimeout = setTimeout(()=>{
                controller?.abort();
            }, requestTimeoutMs);
        }
        return fetch(url, {
            ...restInit,
            headers,
            signal: controller?.signal
        }).finally(()=>{
            if (abortTimeout) {
                clearTimeout(abortTimeout);
            }
        });
    }
    FETCH_CACHE.set(client, fetchWithHeaders);
    return fetchWithHeaders;
}
// NOTE: these all start with "." because we want to make sure we don't match (for example) "otherthirdweb.com"
const THIRDWEB_DOMAINS = [
    ".thirdweb.com",
    ".ipfscdn.io",
    // dev domains
    ".thirdweb.dev",
    ".thirdweb-dev.com"
];
const IS_THIRDWEB_URL_CACHE = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LruMap"](4096);
function isThirdwebUrl(url) {
    if (IS_THIRDWEB_URL_CACHE.has(url)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return IS_THIRDWEB_URL_CACHE.get(url);
    }
    try {
        const { hostname } = new URL(url);
        try {
            // special case for localhost in development only
            if ("TURBOPACK compile-time truthy", 1) {
                if (hostname === "localhost") {
                    IS_THIRDWEB_URL_CACHE.set(url, true);
                    return true;
                }
            }
        } catch  {}
        const is = THIRDWEB_DOMAINS.some((domain)=>hostname.endsWith(domain));
        IS_THIRDWEB_URL_CACHE.set(url, is);
        return is;
    } catch  {
        IS_THIRDWEB_URL_CACHE.set(url, false);
        return false;
    }
}
const SDK_NAME = "unified-sdk";
let previousPlatform;
function getPlatformHeaders() {
    if (previousPlatform) {
        return previousPlatform;
    }
    let os = null;
    if (typeof navigator !== "undefined") {
        os = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$detect$2d$platform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["detectOS"])(navigator.userAgent);
    }
    let bundleId = undefined;
    if (typeof globalThis !== "undefined" && "Application" in globalThis) {
        // shims use wallet connect RN module which injects Application info in globalThis
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        bundleId = globalThis.Application.applicationId;
    }
    previousPlatform = Object.entries({
        "x-sdk-platform": (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$detect$2d$platform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["detectPlatform"])(),
        "x-sdk-version": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"],
        "x-sdk-os": os ? parseOs(os) : "unknown",
        "x-sdk-name": SDK_NAME,
        ...bundleId ? {
            "x-bundle-id": bundleId
        } : {}
    });
    return previousPlatform;
}
/**
 * @internal
 */ function parseOs(os) {
    const osLowerCased = os.toLowerCase();
    if (osLowerCased.startsWith("win")) {
        return "win";
    }
    // we do NOT use the lowercase here
    switch(os){
        case "Mac OS":
            return "mac";
        case "iOS":
            return "ios";
        case "Android OS":
            return "android";
        default:
            // if we somehow fall through here, just replace all spaces with underscores and send it
            return osLowerCased.replace(/\s/gi, "_");
    }
}
function getTWAuthToken() {
    if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
    typeof globalThis.TW_AUTH_TOKEN === "string") {
        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing
        return globalThis.TW_AUTH_TOKEN;
    }
    return null;
} //# sourceMappingURL=fetch.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/promise/withCache.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// copy of: https://github.com/wevm/viem/blob/6cf2c3b5fe608bce9c828af867dfaa65103753a6/src/utils/promise/withCache.ts
// with slight adjustments made to comply with our linting rules
// TODO: explore extracting this from viem and instead having a separate general purpose library for this kind of thing
// alternatively viem could maybe export this helpful util
// TODO: explore using a LRU cache instead of a Map
__turbopack_context__.s({
    "getCache": (()=>getCache),
    "withCache": (()=>withCache)
});
const promiseCache = /*#__PURE__*/ new Map();
const responseCache = /*#__PURE__*/ new Map();
function getCache(cacheKey) {
    const buildCache = (cacheKey_, cache)=>({
            clear: ()=>cache.delete(cacheKey_),
            get: ()=>cache.get(cacheKey_),
            set: (data)=>cache.set(cacheKey_, data)
        });
    const promise = buildCache(cacheKey, promiseCache);
    const response = buildCache(cacheKey, responseCache);
    return {
        clear: ()=>{
            promise.clear();
            response.clear();
        },
        promise,
        response
    };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
    const cache = getCache(cacheKey);
    // If a response exists in the cache, and it's not expired, return it
    // and do not invoke the promise.
    // If the max age is 0, the cache is disabled.
    const response = cache.response.get();
    if (response && cacheTime > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < cacheTime) {
            return response.data;
        }
    }
    let promise = cache.promise.get();
    if (!promise) {
        promise = fn();
        // Store the promise in the cache so that subsequent invocations
        // will wait for the same promise to resolve (deduping).
        cache.promise.set(promise);
    }
    try {
        const data = await promise;
        // Store the response in the cache so that subsequent invocations
        // will return the same response.
        cache.response.set({
            created: new Date(),
            data
        });
        return data;
    } finally{
        // Clear the promise cache so that subsequent invocations will
        // invoke the promise again.
        cache.promise.clear();
    }
} //# sourceMappingURL=withCache.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/chains/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "convertApiChainToChain": (()=>convertApiChainToChain),
    "defineChain": (()=>defineChain),
    "getCachedChain": (()=>getCachedChain),
    "getChainDecimals": (()=>getChainDecimals),
    "getChainMetadata": (()=>getChainMetadata),
    "getChainNativeCurrencyName": (()=>getChainNativeCurrencyName),
    "getChainSymbol": (()=>getChainSymbol),
    "getRpcUrlForChain": (()=>getRpcUrlForChain)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/domains.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$withCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/promise/withCache.js [app-ssr] (ecmascript)");
;
;
;
const CUSTOM_CHAIN_MAP = new Map();
function defineChain(options) {
    if (typeof options === "number") {
        return {
            id: options,
            rpc: `https://${options}.rpc.thirdweb.com`
        };
    }
    if (isViemChain(options)) {
        return convertViemChain(options);
    }
    if (isLegacyChain(options)) {
        return convertLegacyChain(options);
    }
    // otherwise if it's not a viem chain, continue
    let rpc = options.rpc;
    if (!rpc) {
        rpc = `https://${options.id}.rpc.thirdweb.com`;
    }
    const chain = {
        ...options,
        rpc
    };
    CUSTOM_CHAIN_MAP.set(options.id, chain);
    return chain;
}
function getCachedChain(id) {
    if (CUSTOM_CHAIN_MAP.has(id)) {
        return CUSTOM_CHAIN_MAP.get(id);
    }
    const chain = {
        id: id,
        rpc: `https://${id}.rpc.thirdweb.com`
    };
    return chain;
}
function isLegacyChain(chain) {
    return "rpc" in chain && Array.isArray(chain.rpc) && "slug" in chain;
}
function convertLegacyChain(legacyChain) {
    const c = {
        id: legacyChain.chainId,
        name: legacyChain.name,
        rpc: legacyChain.rpc[0] ?? `https://${legacyChain.chainId}.rpc.thirdweb.com`,
        blockExplorers: legacyChain?.explorers?.map((explorer)=>({
                name: explorer.name,
                url: explorer.url,
                apiUrl: explorer.url
            })),
        nativeCurrency: {
            name: legacyChain.nativeCurrency.name,
            symbol: legacyChain.nativeCurrency.symbol,
            decimals: legacyChain.nativeCurrency.decimals
        }
    };
    if (legacyChain.testnet) {
        return {
            ...c,
            testnet: true
        };
    }
    return c;
}
function isViemChain(chain) {
    return "rpcUrls" in chain && !("rpc" in chain);
}
function convertViemChain(viemChain) {
    return defineChain({
        id: viemChain.id,
        name: viemChain.name,
        nativeCurrency: {
            name: viemChain.nativeCurrency.name,
            symbol: viemChain.nativeCurrency.symbol,
            decimals: viemChain.nativeCurrency.decimals
        },
        rpc: viemChain.rpcUrls.default.http[0] ?? `https://${viemChain.id}.rpc.thirdweb.com`,
        blockExplorers: viemChain?.blockExplorers ? Object.values(viemChain?.blockExplorers).map((explorer)=>{
            return {
                name: explorer.name,
                url: explorer.url,
                apiUrl: explorer.apiUrl
            };
        }) : []
    });
}
function getRpcUrlForChain(options) {
    const baseRpcUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().rpc;
    // if the chain is just a number, construct the RPC URL using the chain ID and client ID
    if (typeof options.chain === "number") {
        return `https://${options.chain}.${baseRpcUrl}/${options.client.clientId}`;
    }
    const { rpc } = options.chain;
    // add on the client ID to the RPC URL if it's a thirdweb URL
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isThirdwebUrl"])(rpc)) {
        const rpcUrl = new URL(options.chain.rpc.replace(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DEFAULT_RPC_URL"], baseRpcUrl));
        rpcUrl.pathname = `/${options.client.clientId}`;
        return rpcUrl.toString();
    }
    return rpc;
}
async function getChainSymbol(chain) {
    if (!chain.nativeCurrency?.symbol) {
        return getChainMetadata(chain).then((data)=>data.nativeCurrency.symbol).catch(()=>{
            // if we fail to fetch the chain data, return "ETH" as a fallback
            return "ETH";
        });
    }
    // if we have a symbol, return it
    return chain.nativeCurrency.symbol;
}
async function getChainDecimals(chain) {
    if (!chain.nativeCurrency?.decimals) {
        return getChainMetadata(chain).then((data)=>data.nativeCurrency.decimals).catch(()=>{
            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
            return 18;
        });
    }
    // if we have decimals, return it
    return chain.nativeCurrency.decimals;
}
async function getChainNativeCurrencyName(chain) {
    if (!chain.nativeCurrency?.name) {
        return getChainMetadata(chain).then((data)=>data.nativeCurrency.name).catch(()=>{
            // if we fail to fetch the chain data, return 18 as a fallback (most likely it's 18)
            return "ETH";
        });
    }
    // if we have a name, return it
    return chain.nativeCurrency.name;
}
function getChainMetadata(chain) {
    const chainId = chain.id;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$withCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withCache"])(async ()=>{
        try {
            const res = await fetch(`https://api.thirdweb.com/v1/chains/${chainId}`);
            if (!res.ok) {
                res.body?.cancel();
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            const response = await res.json();
            if (response.error) {
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            if (!response.data) {
                throw new Error(`Failed to fetch chain data for chainId ${chainId}`);
            }
            const data = response.data;
            return createChainMetadata(chain, data);
        } catch  {
            return createChainMetadata(chain);
        }
    }, {
        cacheKey: `chain:${chainId}`,
        cacheTime: 5 * 60 * 1000
    });
}
function convertApiChainToChain(apiChain) {
    return {
        id: apiChain.chainId,
        name: apiChain.name,
        rpc: apiChain.rpc[0] || "",
        testnet: apiChain.testnet === true ? true : undefined,
        nativeCurrency: apiChain.nativeCurrency,
        blockExplorers: apiChain.explorers?.map((explorer)=>{
            return {
                name: explorer.name,
                url: explorer.url,
                apiUrl: explorer.url
            };
        })
    };
}
function createChainMetadata(chain, data) {
    const nativeCurrency = chain.nativeCurrency ? {
        ...data?.nativeCurrency,
        ...chain.nativeCurrency
    } : data?.nativeCurrency;
    return {
        ...data,
        name: chain.name || data?.name || "",
        chainId: chain.id || data?.chainId || -1,
        rpc: chain.rpc ? [
            chain.rpc
        ] : data?.rpc || [
            ""
        ],
        testnet: chain.testnet || data?.testnet || false,
        nativeCurrency: {
            name: nativeCurrency?.name || "",
            symbol: nativeCurrency?.symbol || "",
            decimals: nativeCurrency?.decimals || 18
        },
        icon: chain.icon || data?.icon,
        chain: data?.chain || chain.name || "",
        shortName: data?.shortName || chain.name || "",
        slug: data?.slug || chain.name || "",
        explorers: chain.blockExplorers?.map((e)=>({
                name: e.name,
                url: e.url,
                standard: "EIP3091"
            })) || data?.explorers
    };
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/contract/contract.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Creates a Thirdweb contract by combining the Thirdweb client and contract options.
 * @param options - The options for creating the contract.
 * @returns The Thirdweb contract.
 * @example
 * ```ts
 * import { createThirdwebClient, getContract } from "thirdweb";
 * import { sepolia } from "thirdweb/chains";
 *
 * const client = createThirdwebClient({ clientId: "..." });
 * const contract = getContract({
 *  client,
 *  chain: sepolia,
 *  address: "0x123...",
 *  // optional ABI
 *  abi: [...],
 * });
 * ```
 * @contract
 */ __turbopack_context__.s({
    "getContract": (()=>getContract)
});
function getContract(options) {
    return options;
} //# sourceMappingURL=contract.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/units.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Converts a given number of units to a string representation with a specified number of decimal places.
 * @param units - The number of units to convert.
 * @param decimals - The number of decimal places to include in the string representation.
 * @returns The string representation of the converted units.
 * @example
 * ```ts
 * import { toTokens } from "thirdweb/utils";
 * toTokens(1000000000000000000n, 18)
 * // '1'
 * ```
 * @utils
 */ __turbopack_context__.s({
    "fromGwei": (()=>fromGwei),
    "toEther": (()=>toEther),
    "toTokens": (()=>toTokens),
    "toUnits": (()=>toUnits),
    "toWei": (()=>toWei)
});
function toTokens(units, decimals) {
    // Convert to string once and handle negativity.
    const stringValue = units.toString();
    const prefix = stringValue[0] === "-" ? "-" : "";
    // Abusing that string "-" is truthy
    const absStringValue = prefix ? stringValue.slice(1) : stringValue;
    // Ensure we have enough digits for the fractional part.
    const paddedValue = absStringValue.padStart(decimals + 1, "0");
    const splitIndex = paddedValue.length - decimals;
    // Extract integer and fraction parts directly.
    const integerPart = paddedValue.slice(0, splitIndex) || "0";
    let fractionPart = paddedValue.slice(splitIndex);
    // Manually trim trailing zeros from the fraction part.
    for(let i = fractionPart.length - 1; i >= 0; i--){
        if (fractionPart[i] !== "0") {
            fractionPart = fractionPart.slice(0, i + 1);
            break;
        }
        // check if the next digit is a zero also
        // If all zeros, make fraction part empty
        if (i === 0) {
            fractionPart = "";
        }
    }
    // Construct and return the formatted string.
    return `${prefix}${integerPart}${fractionPart ? `.${fractionPart}` : ""}`;
}
function toEther(wei) {
    return toTokens(wei, 18);
}
function toUnits(tokens, decimals) {
    let [integerPart, fractionPart = ""] = tokens.split(".");
    const prefix = integerPart.startsWith("-") ? "-" : "";
    if (prefix) {
        integerPart = integerPart.slice(1);
    }
    fractionPart = fractionPart.padEnd(decimals, "0"); // Ensure fraction part is at least 'decimals' long.
    if (decimals === 0) {
        // Check if there's any fraction part that would necessitate rounding up the integer part.
        if (fractionPart[0] && Number.parseInt(fractionPart[0]) >= 5) {
            integerPart = (BigInt(integerPart) + 1n).toString();
        }
        fractionPart = ""; // No fraction part is needed when decimals === 0.
    } else {
        // When decimals > 0, handle potential rounding based on the digit right after the specified decimal places.
        if (fractionPart.length > decimals) {
            const roundingDigit = fractionPart[decimals];
            if (roundingDigit && Number.parseInt(roundingDigit, 10) >= 5) {
                // If rounding is needed, add 1 to the last included digit of the fraction part.
                const roundedFraction = BigInt(fractionPart.substring(0, decimals)) + 1n;
                fractionPart = roundedFraction.toString().padStart(decimals, "0");
                if (fractionPart.length > decimals) {
                    // If rounding the fraction results in a length increase (e.g., .999 -> 1.000), increment the integer part.
                    integerPart = (BigInt(integerPart) + 1n).toString();
                    // Adjust the fraction part if it's longer than the specified decimals due to rounding up.
                    fractionPart = fractionPart.substring(fractionPart.length - decimals);
                }
            } else {
                // If no rounding is necessary, just truncate the fraction part to the specified number of decimals.
                fractionPart = fractionPart.substring(0, decimals);
            }
        }
    // If the fraction part is shorter than the specified decimals, it's already handled by padEnd() above.
    }
    // Combine the integer and fraction parts into the final BigInt representation.
    return BigInt(`${prefix}${integerPart}${fractionPart}`);
}
function toWei(tokens) {
    return toUnits(tokens, 18);
}
function fromGwei(gwei) {
    return toUnits(gwei, 9);
} //# sourceMappingURL=units.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "keccak256": (()=>keccak256)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/@noble/hashes/esm/sha3.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/hex.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/is-hex.js [app-ssr] (ecmascript)");
;
;
function keccak256(value, to) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$is$2d$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHex"])(value, {
        strict: false
    }) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["hexToUint8Array"])(value) : value);
    if (to === "bytes") {
        return bytes;
    }
    // default fall through to hex
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["uint8ArrayToHex"])(bytes);
} //# sourceMappingURL=keccak256.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/address.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "checksumAddress": (()=>checksumAddress),
    "getAddress": (()=>getAddress),
    "isAddress": (()=>isAddress),
    "shortenAddress": (()=>shortenAddress)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/caching/lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$to$2d$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/to-bytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$hashing$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/hashing/keccak256.js [app-ssr] (ecmascript)");
;
;
;
const ADRESS_REGEX = /^0x[a-fA-F0-9]{40}$/;
const IS_ADDRESS_CACHE = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LruMap"](4096);
function isAddress(address) {
    if (IS_ADDRESS_CACHE.has(address)) {
        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set
        return IS_ADDRESS_CACHE.get(address);
    }
    const result = (()=>{
        if (!ADRESS_REGEX.test(address)) {
            return false;
        }
        if (address.toLowerCase() === address) {
            return true;
        }
        return checksumAddress(address) === address;
    })();
    IS_ADDRESS_CACHE.set(address, result);
    return result;
}
function checksumAddress(address) {
    const hexAddress = address.substring(2).toLowerCase();
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$hashing$2f$keccak256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$to$2d$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringToBytes"])(hexAddress), "bytes");
    const address_ = hexAddress.split("");
    for(let i = 0; i < 40; i += 2){
        // biome-ignore lint/style/noNonNullAssertion: <explanation>
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
            // biome-ignore lint/style/noNonNullAssertion: <explanation>
            address_[i] = address_[i].toUpperCase();
        }
        // biome-ignore lint/style/noNonNullAssertion: <explanation>
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
            // biome-ignore lint/style/noNonNullAssertion: <explanation>
            address_[i + 1] = address_[i + 1].toUpperCase();
        }
    }
    return `0x${address_.join("")}`;
}
function getAddress(address) {
    if (!isAddress(address)) {
        throw new Error(`Invalid address: ${address}`);
    }
    return checksumAddress(address);
}
function shortenAddress(address, length = 4) {
    const _address = getAddress(address);
    return `${_address.slice(0, length + 2)}...${_address.slice(-length)}`;
} //# sourceMappingURL=address.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encodeAbiParameters": (()=>encodeAbiParameters),
    "encodeAddress": (()=>encodeAddress),
    "prepareParam": (()=>prepareParam)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/viem/_esm/utils/data/concat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/viem/_esm/utils/data/slice.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/helpers/byte-size.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/encoding/hex.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
function encodeAbiParameters(params, values) {
    if (params.length !== values.length) {
        throw new Error("The number of parameters and values must match.");
    }
    // Prepare the parameters to determine dynamic types to encode.
    const preparedParams = prepareParams({
        params: params,
        values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0) {
        return "0x";
    }
    return data;
}
function prepareParams({ params, values }) {
    const preparedParams = [];
    for(let i = 0; i < params.length; i++){
        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
        preparedParams.push(prepareParam({
            param: params[i],
            value: values[i]
        }));
    }
    return preparedParams;
}
function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, {
            length,
            param: {
                ...param,
                type
            }
        });
    }
    if (param.type === "tuple") {
        return encodeTuple(value, {
            param: param
        });
    }
    if (param.type === "address") {
        return encodeAddress(value);
    }
    if (param.type === "bool") {
        return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
        const signed = param.type.startsWith("int");
        return encodeNumber(value, {
            signed
        });
    }
    if (param.type.startsWith("bytes")) {
        return encodeBytes(value, {
            param
        });
    }
    if (param.type === "string") {
        return encodeString(value);
    }
    throw new Error(`Unsupported parameter type: ${param.type}`);
}
function encodeParams(preparedParams) {
    // 1. Compute the size of the static part of the parameters.
    let staticSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticSize += 32;
        } else {
            staticSize += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(encoded);
        }
    }
    // 2. Split the parameters into static and dynamic parts.
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticParams.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])(staticSize + dynamicSize, {
                size: 32
            }));
            dynamicParams.push(encoded);
            dynamicSize += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(encoded);
        } else {
            staticParams.push(encoded);
        }
    }
    // 3. Concatenate static and dynamic parts.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])([
        ...staticParams,
        ...dynamicParams
    ]);
}
function encodeAddress(value) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAddress"])(value)) {
        throw new Error("Invalid address.");
    }
    return {
        dynamic: false,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])(value.toLowerCase())
    };
}
function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value)) {
        throw new Error("Invalid array value.");
    }
    if (!dynamic && value.length !== length) {
        throw new Error("Invalid array length.");
    }
    let dynamicChild = false;
    const preparedParams = [];
    for(let i = 0; i < value.length; i++){
        const preparedParam = prepareParam({
            param,
            value: value[i]
        });
        if (preparedParam.dynamic) {
            dynamicChild = true;
        }
        preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
            const length_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])(preparedParams.length, {
                size: 32
            });
            return {
                dynamic: true,
                encoded: preparedParams.length > 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])([
                    length_,
                    data
                ]) : length_
            };
        }
        if (dynamicChild) {
            return {
                dynamic: true,
                encoded: data
            };
        }
    }
    return {
        dynamic: false,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(preparedParams.map(({ encoded })=>encoded))
    };
}
function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split("bytes");
    const bytesSize = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(value);
    if (!paramSize) {
        let value_ = value;
        // If the size is not divisible by 32 bytes, pad the end
        // with empty bytes to the ceiling 32 bytes.
        if (bytesSize % 32 !== 0) {
            value_ = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])(value_, {
                dir: "right",
                size: Math.ceil((value.length - 2) / 2 / 32) * 32
            });
        }
        return {
            dynamic: true,
            encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])(bytesSize, {
                    size: 32
                })),
                value_
            ])
        };
    }
    if (bytesSize !== Number.parseInt(paramSize)) {
        throw new Error(`Invalid bytes${paramSize} size: ${bytesSize}`);
    }
    return {
        dynamic: false,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])(value, {
            dir: "right"
        })
    };
}
function encodeBool(value) {
    return {
        dynamic: false,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["boolToHex"])(value))
    };
}
function encodeNumber(value, { signed }) {
    return {
        dynamic: false,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])(value, {
            size: 32,
            signed
        })
    };
}
function encodeString(value) {
    const hexValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["stringToHex"])(value);
    const partsLength = Math.ceil((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(hexValue) / 32);
    const parts = [];
    for(let i = 0; i < partsLength; i++){
        parts.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$slice$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["slice"])(hexValue, i * 32, (i + 1) * 32), {
            dir: "right"
        }));
    }
    return {
        dynamic: true,
        encoded: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["padHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$hex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["numberToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$encoding$2f$helpers$2f$byte$2d$size$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["byteSize"])(hexValue), {
                size: 32
            })),
            ...parts
        ])
    };
}
function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for(let i = 0; i < param.components.length; i++){
        // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
            param: param_,
            // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
            value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic) {
            dynamic = true;
        }
    }
    return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$data$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["concat"])(preparedParams.map(({ encoded })=>encoded))
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? // biome-ignore lint/style/noNonNullAssertion: we know the value is not `undefined`.
    [
        matches[2] ? Number(matches[2]) : null,
        matches[1]
    ] : undefined;
} //# sourceMappingURL=encodeAbiParameters.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/json.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Stringify a JSON object and convert all bigint values to string
 * @example
 * ```ts
 * import { stringify } from "thirdweb/utils";
 * const obj = { tokenId: 0n };
 * const str = stringify(obj); // "{"tokenId":"0"}"
 * ```
 * @utils
 */ __turbopack_context__.s({
    "stringify": (()=>stringify)
});
const stringify = (value, replacer, space)=>{
    const res = JSON.stringify(value, (key, value_)=>{
        const value__ = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key, value__) : value__;
    }, space);
    return res;
}; //# sourceMappingURL=json.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/abi/prepare-method.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prepareMethod": (()=>prepareMethod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/viem/_esm/utils/hash/toFunctionSelector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/caching/lru.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/json.js [app-ssr] (ecmascript)");
;
;
;
;
const prepareMethodCache = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$caching$2f$lru$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LruMap"](4096);
function prepareMethod(method) {
    const key = typeof method === "string" ? method : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(method);
    if (prepareMethodCache.has(key)) {
        return prepareMethodCache.get(key);
    }
    const abiFn = typeof method === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAbiItem"])(method) : method;
    // encode the method signature
    const sig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFunctionSelector"])(abiFn);
    const ret = [
        sig,
        abiFn.inputs,
        abiFn.outputs
    ];
    prepareMethodCache.set(key, ret);
    return ret;
} //# sourceMappingURL=prepare-method.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/promise/resolve-promised-value.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Resolves a possibly asynchronous value.
 * If the value is a function that returns a promise, it will be awaited and the resolved value will be returned.
 * Otherwise, the value itself will be returned.
 *
 * @param value - The value to resolve.
 * @returns A promise that resolves to the resolved value.
 * @internal
 */ __turbopack_context__.s({
    "resolvePromisedValue": (()=>resolvePromisedValue)
});
async function resolvePromisedValue(value) {
    return typeof value === "function" ? await value() : value;
} //# sourceMappingURL=resolve-promised-value.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/transaction/prepare-transaction.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Prepares a transaction with the given options.
 * @param options - The options for preparing the transaction.
 * @param info - Additional information about the ABI function.
 * @returns The prepared transaction.
 * @transaction
 * @example
 * ```ts
 * import { prepareTransaction, toWei } from "thirdweb";
 * import { ethereum } from "thirdweb/chains";
 * const transaction = prepareTransaction({
 *  to: "0x1234567890123456789012345678901234567890",
 *  chain: ethereum,
 *  client: thirdwebClient,
 *  value: toWei("1.0"),
 *  gasPrice: 30n
 * });
 * ```
 */ __turbopack_context__.s({
    "prepareTransaction": (()=>prepareTransaction)
});
function prepareTransaction(options, info) {
    if (info) {
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        options.__preparedMethod = info.preparedMethod;
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later
        options.__contract = info.contract;
    }
    return options;
} //# sourceMappingURL=prepare-transaction.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/transaction/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * @internal
 */ __turbopack_context__.s({
    "isAbiFunction": (()=>isAbiFunction)
});
function isAbiFunction(item) {
    return !!(item && typeof item === "object" && "type" in item && item.type === "function");
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/transaction/prepare-contract-call.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prepareContractCall": (()=>prepareContractCall)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$prepare$2d$method$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/abi/prepare-method.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$resolve$2d$promised$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/promise/resolve-promised-value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$prepare$2d$transaction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/transaction/prepare-transaction.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/transaction/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
function prepareContractCall(options) {
    const { contract, method, params, ...rest } = options;
    const preparedMethodPromise = ()=>(async ()=>{
            if (Array.isArray(method)) {
                return method;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isAbiFunction"])(method)) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$prepare$2d$method$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareMethod"])(method);
            }
            if (typeof method === "function") {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$prepare$2d$method$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareMethod"])(await method(contract));
            }
            // if the method starts with the string `function ` we always will want to try to parse it
            if (typeof method === "string" && method.startsWith("function ")) {
                // @ts-expect-error - method *is* string in this case
                const abiItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$parseAbiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAbiItem"])(method);
                if (abiItem.type === "function") {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$prepare$2d$method$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareMethod"])(abiItem);
                }
                throw new Error(`"method" passed is not of type "function"`);
            }
            // check if we have a "abi" on the contract
            if (contract.abi && contract.abi?.length > 0) {
                // extract the abiFunction from it
                const abiFunction = contract.abi?.find((item)=>item.type === "function" && item.name === method);
                // if we were able to find it -> return it
                if (abiFunction) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$prepare$2d$method$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareMethod"])(abiFunction);
                }
            }
            throw new Error(`Could not resolve method "${method}".`);
        })();
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$prepare$2d$transaction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareTransaction"])({
        ...rest,
        // these always inferred from the contract
        to: contract.address,
        chain: contract.chain,
        client: contract.client,
        data: async ()=>{
            let preparedM;
            if (Array.isArray(method)) {
                preparedM = method;
            } else {
                preparedM = await preparedMethodPromise();
            }
            if (preparedM[1].length === 0) {
                // just return the fn sig directly -> no params
                return preparedM[0];
            }
            // we do a "manual" concat here to avoid the overhead of the "concatHex" function
            // we can do this because we know the specific formats of the values
            return preparedM[0] + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAbiParameters"])(preparedM[1], // @ts-expect-error - TODO: fix this type issue
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$resolve$2d$promised$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolvePromisedValue"])(params ?? [])).slice(2);
        }
    }, {
        preparedMethod: preparedMethodPromise,
        contract: contract
    });
} //# sourceMappingURL=prepare-contract-call.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/promise/once.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "once": (()=>once)
});
function once(fn) {
    let result;
    return ()=>{
        if (!result) {
            result = fn();
        }
        return result;
    };
} //# sourceMappingURL=once.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/rpc/actions/eth_getCode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Retrieves the bytecode of a smart contract at the specified address.
 * @param request - The EIP1193 request function.
 * @param params - The parameters for the eth_getCode method.
 * @returns A promise that resolves to the bytecode of the smart contract.
 * @rpc
 * @example
 * ```ts
 * import { getRpcClient, eth_getCode } from "thirdweb/rpc";
 * const rpcRequest = getRpcClient({ client, chain });
 * const bytecode = await eth_getCode(rpcRequest, {
 *  address: "0x...",
 * });
 * ```
 */ __turbopack_context__.s({
    "eth_getCode": (()=>eth_getCode)
});
async function eth_getCode(request, params) {
    return request({
        method: "eth_getCode",
        params: [
            params.address,
            params.blockTag || "latest"
        ]
    });
} //# sourceMappingURL=eth_getCode.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/rpc/fetch-rpc.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fetchRpc": (()=>fetchRpc),
    "fetchSingleRpc": (()=>fetchSingleRpc)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/json.js [app-ssr] (ecmascript)");
;
;
async function fetchRpc(rpcUrl, client, options) {
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientFetch"])(client)(rpcUrl, {
        headers: {
            ...client.config?.rpc?.fetch?.headers,
            "Content-Type": "application/json"
        },
        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(options.requests),
        method: "POST",
        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
        keepalive: client.config?.rpc?.fetch?.keepalive
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`RPC request failed with status ${response.status} - ${response.statusText}`);
    }
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        return await response.json();
    }
    const text = await response.text();
    try {
        return JSON.parse(text);
    } catch (err) {
        console.error("Error parsing response", err, text);
        throw err;
    }
}
async function fetchSingleRpc(rpcUrl, client, options) {
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientFetch"])(client)(rpcUrl, {
        headers: {
            ...client.config?.rpc?.fetch?.headers || {},
            "Content-Type": "application/json"
        },
        body: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(options.request),
        method: "POST",
        requestTimeoutMs: options.requestTimeoutMs ?? client.config?.rpc?.fetch?.requestTimeoutMs,
        keepalive: client.config?.rpc?.fetch?.keepalive
    });
    if (!response.ok) {
        response.body?.cancel();
        throw new Error(`RPC request failed with status ${response.status}`);
    }
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        return await response.json();
    }
    const text = await response.text();
    try {
        return JSON.parse(text);
    } catch (err) {
        console.error("Error parsing response", err, text);
        throw err;
    }
} //# sourceMappingURL=fetch-rpc.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/rpc/rpc.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getRpcClient": (()=>getRpcClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$chains$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/chains/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$fetch$2d$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/rpc/fetch-rpc.js [app-ssr] (ecmascript)");
;
;
const RPC_CLIENT_MAP = new WeakMap();
/**
 * @internal
 */ function getRpcClientMap(client) {
    if (RPC_CLIENT_MAP.has(client)) {
        return RPC_CLIENT_MAP.get(client);
    }
    const rpcClientMap = new Map();
    RPC_CLIENT_MAP.set(client, rpcClientMap);
    return rpcClientMap;
}
/**
 * @internal
 */ function rpcRequestKey(request) {
    return `${request.method}:${JSON.stringify(request.params)}`;
}
const DEFAULT_MAX_BATCH_SIZE = 100;
// default to no timeout (next tick)
const DEFAULT_BATCH_TIMEOUT_MS = 0;
function getRpcClient(options) {
    const rpcClientMap = getRpcClientMap(options.client);
    const chainId = options.chain.id;
    if (rpcClientMap.has(options.chain.rpc)) {
        return rpcClientMap.get(options.chain.rpc);
    }
    const rpcClient = (()=>{
        // we can do this upfront because it cannot change later
        const rpcUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$chains$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRpcUrlForChain"])({
            client: options.client,
            chain: options.chain
        });
        const batchSize = // look at the direct options passed
        options.config?.maxBatchSize ?? // look at the client options
        options.client.config?.rpc?.maxBatchSize ?? // use defaults
        DEFAULT_MAX_BATCH_SIZE;
        const batchTimeoutMs = // look at the direct options passed
        options.config?.batchTimeoutMs ?? // look at the client options
        options.client.config?.rpc?.batchTimeoutMs ?? DEFAULT_BATCH_TIMEOUT_MS;
        // inflight requests
        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
        const inflightRequests = new Map();
        let pendingBatch = [];
        let pendingBatchTimeout = null;
        /**
         * Sends the pending batch of requests.
         * @internal
         */ function sendPendingBatch() {
            // clear the timeout if any
            if (pendingBatchTimeout) {
                clearTimeout(pendingBatchTimeout);
                pendingBatchTimeout = null;
            }
            // prepare the requests array (we know the size)
            const requests = new Array(pendingBatch.length);
            const activeBatch = pendingBatch.slice().map((inflight, index)=>{
                // assign the id to the request
                inflight.request.id = index;
                // also assign the jsonrpc version
                inflight.request.jsonrpc = "2.0";
                // assing the request to the requests array (so we don't have to map it again later)
                requests[index] = inflight.request;
                return inflight;
            });
            // reset pendingBatch to empty
            pendingBatch = [];
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$fetch$2d$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fetchRpc"])(rpcUrl, options.client, {
                requests,
                requestTimeoutMs: options.config?.requestTimeoutMs
            }).then((responses)=>{
                // for each response, resolve the inflight request
                activeBatch.forEach((inflight, index)=>{
                    const response = responses[index];
                    // if we didn't get a response at all, reject the inflight request
                    if (!response) {
                        inflight.reject(new Error("No response"));
                        return;
                    }
                    // handle errors in the response
                    if (response instanceof Error) {
                        inflight.reject(response);
                        return;
                    }
                    // handle strings as responses??
                    if (typeof response === "string") {
                        inflight.reject(new Error(response));
                        return;
                    }
                    if ("error" in response) {
                        inflight.reject(response.error);
                    // otherwise, resolve the inflight request
                    } else if (response.method === "eth_subscription") {
                        // TODO: handle subscription responses
                        throw new Error("Subscriptions not supported yet");
                    } else {
                        inflight.resolve(response.result);
                    }
                    // remove the inflight request from the inflightRequests map
                    inflightRequests.delete(inflight.requestKey);
                });
            }).catch((err)=>{
                // http call failed, reject all inflight requests
                for (const inflight of activeBatch){
                    inflight.reject(err);
                    // remove the inflight request from the inflightRequests map
                    inflightRequests.delete(inflight.requestKey);
                }
            });
        }
        // shortcut everything if we do not need to batch
        if (batchSize === 1) {
            return async (request)=>{
                // we can hard-code the id and jsonrpc version
                // we also mutate the request object here to avoid copying it
                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
                request.id = 1;
                // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
                request.jsonrpc = "2.0";
                const rpcResponse = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$fetch$2d$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fetchSingleRpc"])(rpcUrl, options.client, {
                    request: request,
                    requestTimeoutMs: options.config?.requestTimeoutMs
                });
                if (!rpcResponse) {
                    throw new Error("No response");
                }
                if ("error" in rpcResponse) {
                    throw rpcResponse.error;
                }
                return rpcResponse.result;
            };
        }
        return async (request)=>{
            const requestKey = rpcRequestKey(request);
            // if the request for this key is already inflight, return the promise directly
            if (inflightRequests.has(requestKey)) {
                // biome-ignore lint/style/noNonNullAssertion: the `has` check ensures this is defined
                return inflightRequests.get(requestKey);
            }
            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
            let resolve;
            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
            let reject;
            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any
            const promise = new Promise((resolve_, reject_)=>{
                resolve = resolve_;
                reject = reject_;
            });
            inflightRequests.set(requestKey, promise);
            // @ts-expect-error - they *are* definitely assgined within the promise constructor
            pendingBatch.push({
                request,
                resolve,
                reject,
                requestKey
            });
            if (batchSize > 1) {
                // if there is no timeout, set one
                if (!pendingBatchTimeout) {
                    pendingBatchTimeout = setTimeout(sendPendingBatch, batchTimeoutMs);
                }
                // if the batch is full, send it
                if (pendingBatch.length >= batchSize) {
                    sendPendingBatch();
                }
            } else {
                sendPendingBatch();
            }
            return promise;
        };
    })();
    rpcClientMap.set(chainId, rpcClient);
    return rpcClient;
} //# sourceMappingURL=rpc.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/contract/actions/get-bytecode.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getBytecode": (()=>getBytecode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$actions$2f$eth_getCode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/rpc/actions/eth_getCode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/rpc/rpc.js [app-ssr] (ecmascript)");
;
;
const BYTECODE_CACHE = new WeakMap();
function getBytecode(contract) {
    if (BYTECODE_CACHE.has(contract)) {
        return BYTECODE_CACHE.get(contract);
    }
    const prom = (async ()=>{
        const rpcRequest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$rpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getRpcClient"])(contract);
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$rpc$2f$actions$2f$eth_getCode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["eth_getCode"])(rpcRequest, {
            address: contract.address,
            blockTag: "latest"
        });
        if (result === "0x") {
            BYTECODE_CACHE.delete(contract);
        }
        return result;
    })();
    BYTECODE_CACHE.set(contract, prom);
    return prom;
} //# sourceMappingURL=get-bytecode.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/utils/bytecode/detectExtension.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "detectMethod": (()=>detectMethod)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/node_modules/viem/_esm/utils/hash/toFunctionSelector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$contract$2f$actions$2f$get$2d$bytecode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/contract/actions/get-bytecode.js [app-ssr] (ecmascript)");
;
;
async function detectMethod(options) {
    const bytecode = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$contract$2f$actions$2f$get$2d$bytecode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getBytecode"])(options.contract);
    return detectMethodInBytecode({
        bytecode,
        method: options.method
    });
}
/**
 * Detects if a specific method is present in the bytecode of a contract.
 * @param options - The options for detecting the method in the bytecode.
 * @returns A boolean indicating whether the method is present in the bytecode.
 * @internal
 */ function detectMethodInBytecode(options) {
    // if we can't get the bytecode we know the contract is not deployed
    if (options.bytecode === "0x") {
        return false;
    }
    // we strip the leading `0x` from the function selector
    const fnSelector = Array.isArray(options.method) ? options.method[0] : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$hash$2f$toFunctionSelector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFunctionSelector"])(options.method);
    // indexOf is slightly faster than includes
    return options.bytecode.indexOf(fnSelector.slice(2)) > -1;
} //# sourceMappingURL=detectExtension.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FN_SELECTOR": (()=>FN_SELECTOR),
    "approve": (()=>approve),
    "encodeApprove": (()=>encodeApprove),
    "encodeApproveParams": (()=>encodeApproveParams),
    "isApproveSupported": (()=>isApproveSupported)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$prepare$2d$contract$2d$call$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/transaction/prepare-contract-call.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/abi/encodeAbiParameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$once$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/promise/once.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$bytecode$2f$detectExtension$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/bytecode/detectExtension.js [app-ssr] (ecmascript)");
;
;
;
;
const FN_SELECTOR = "0x095ea7b3";
const FN_INPUTS = [
    {
        type: "address",
        name: "spender"
    },
    {
        type: "uint256",
        name: "value"
    }
];
const FN_OUTPUTS = [
    {
        type: "bool"
    }
];
async function isApproveSupported(contract) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$bytecode$2f$detectExtension$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["detectMethod"])({
        contract,
        method: [
            FN_SELECTOR,
            FN_INPUTS,
            FN_OUTPUTS
        ]
    });
}
function encodeApproveParams(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$abi$2f$encodeAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeAbiParameters"])(FN_INPUTS, [
        options.spender,
        options.value
    ]);
}
function encodeApprove(options) {
    // we do a "manual" concat here to avoid the overhead of the "concatHex" function
    // we can do this because we know the specific formats of the values
    return FN_SELECTOR + encodeApproveParams(options).slice(2);
}
function approve(options) {
    const asyncOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$promise$2f$once$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["once"])(async ()=>{
        return "asyncParams" in options ? await options.asyncParams() : options;
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$transaction$2f$prepare$2d$contract$2d$call$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepareContractCall"])({
        contract: options.contract,
        method: [
            FN_SELECTOR,
            FN_INPUTS,
            FN_OUTPUTS
        ],
        params: async ()=>{
            const resolvedOptions = await asyncOptions();
            return [
                resolvedOptions.spender,
                resolvedOptions.value
            ];
        },
        value: async ()=>(await asyncOptions()).overrides?.value,
        accessList: async ()=>(await asyncOptions()).overrides?.accessList,
        gas: async ()=>(await asyncOptions()).overrides?.gas,
        gasPrice: async ()=>(await asyncOptions()).overrides?.gasPrice,
        maxFeePerGas: async ()=>(await asyncOptions()).overrides?.maxFeePerGas,
        maxPriorityFeePerGas: async ()=>(await asyncOptions()).overrides?.maxPriorityFeePerGas,
        nonce: async ()=>(await asyncOptions()).overrides?.nonce,
        extraGas: async ()=>(await asyncOptions()).overrides?.extraGas
    });
} //# sourceMappingURL=approve.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "approve": (()=>approve)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/units.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$extensions$2f$erc20$2f$_$5f$generated_$5f2f$IERC20$2f$write$2f$approve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/extensions/erc20/__generated__/IERC20/write/approve.js [app-ssr] (ecmascript)");
;
;
function approve(options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$extensions$2f$erc20$2f$_$5f$generated_$5f2f$IERC20$2f$write$2f$approve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["approve"])({
        contract: options.contract,
        asyncParams: async ()=>{
            let amount;
            if ("amount" in options) {
                // if we need to parse the amount from ether to gwei then we pull in the decimals extension
                const { decimals } = await __turbopack_context__.r("[project]/node_modules/thirdweb/dist/esm/extensions/erc20/read/decimals.js [app-ssr] (ecmascript, async loader)")(__turbopack_context__.i);
                // if this fails we fall back to `18` decimals
                const d = await decimals(options).catch(()=>18);
                // turn ether into gwei
                amount = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$units$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toUnits"])(options.amount.toString(), d);
            } else {
                amount = options.amountWei;
            }
            return {
                spender: options.spender,
                value: amount
            };
        }
    });
} //# sourceMappingURL=approve.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/pay/utils/definitions.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getPayBuyHistoryEndpoint": (()=>getPayBuyHistoryEndpoint),
    "getPayBuyWithCryptoHistoryEndpoint": (()=>getPayBuyWithCryptoHistoryEndpoint),
    "getPayBuyWithCryptoQuoteEndpoint": (()=>getPayBuyWithCryptoQuoteEndpoint),
    "getPayBuyWithCryptoStatusUrl": (()=>getPayBuyWithCryptoStatusUrl),
    "getPayBuyWithFiatHistoryEndpoint": (()=>getPayBuyWithFiatHistoryEndpoint),
    "getPayBuyWithFiatQuoteEndpoint": (()=>getPayBuyWithFiatQuoteEndpoint),
    "getPayBuyWithFiatStatusEndpoint": (()=>getPayBuyWithFiatStatusEndpoint),
    "getPaySupportedDestinations": (()=>getPaySupportedDestinations),
    "getPaySupportedSources": (()=>getPaySupportedSources)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/domains.js [app-ssr] (ecmascript)");
;
const getPayBuyWithCryptoStatusUrl = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-crypto/status/v1`;
const getPayBuyWithCryptoQuoteEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-crypto/quote/v1`;
const getPayBuyWithFiatQuoteEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-fiat/quote/v1`;
const getPayBuyWithFiatStatusEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-fiat/status/v1`;
const getPayBuyWithFiatHistoryEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-fiat/history/v1`;
const getPayBuyWithCryptoHistoryEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-crypto/history/v1`;
const getPaySupportedDestinations = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/destination-tokens/v1`;
const getPaySupportedSources = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/buy-with-crypto/source-tokens/v1`;
const getPayBuyHistoryEndpoint = ()=>`https://${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$domains$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getThirdwebDomains"])().pay}/wallet/history/v1`; //# sourceMappingURL=definitions.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getQuote.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getBuyWithCryptoQuote": (()=>getBuyWithCryptoQuote)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$chains$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/chains/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$contract$2f$contract$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/contract/contract.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$extensions$2f$erc20$2f$write$2f$approve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/extensions/erc20/write/approve.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/pay/utils/definitions.js [app-ssr] (ecmascript)");
;
;
;
;
;
async function getBuyWithCryptoQuote(params) {
    try {
        const queryParams = new URLSearchParams({
            fromAddress: params.fromAddress,
            fromChainId: params.fromChainId.toString(),
            fromTokenAddress: params.fromTokenAddress.toLowerCase(),
            toChainId: params.toChainId.toString(),
            toTokenAddress: params.toTokenAddress.toLowerCase()
        });
        if ("fromAmount" in params && params.fromAmount) {
            queryParams.append("fromAmount", params.fromAmount);
        }
        if ("toAmount" in params && params.toAmount) {
            queryParams.append("toAmount", params.toAmount);
        }
        if (params.maxSlippageBPS) {
            queryParams.append("maxSlippageBPS", params.maxSlippageBPS.toString());
        }
        if (params.intentId) {
            queryParams.append("intentId", params.intentId);
        }
        const queryString = queryParams.toString();
        const url = `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPayBuyWithCryptoQuoteEndpoint"])()}?${queryString}`;
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientFetch"])(params.client)(url);
        // Assuming the response directly matches the SwapResponse interface
        if (!response.ok) {
            const errorObj = await response.json();
            if (errorObj && "error" in errorObj && typeof errorObj.error === "object" && "message" in errorObj.error) {
                throw new Error(errorObj.error.message);
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json()).result;
        const swapRoute = {
            transactionRequest: {
                chain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$chains$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCachedChain"])(data.transactionRequest.chainId),
                client: params.client,
                data: data.transactionRequest.data,
                to: data.transactionRequest.to,
                value: BigInt(data.transactionRequest.value),
                gas: BigInt(data.transactionRequest.gasLimit),
                gasPrice: BigInt(data.transactionRequest.gasPrice)
            },
            approval: data.approval ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$extensions$2f$erc20$2f$write$2f$approve$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["approve"])({
                contract: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$contract$2f$contract$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getContract"])({
                    client: params.client,
                    address: data.approval.tokenAddress,
                    chain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$chains$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getCachedChain"])(data.approval.chainId)
                }),
                spender: data.approval?.spenderAddress,
                amountWei: BigInt(data.approval.amountWei)
            }) : undefined,
            swapDetails: {
                fromAddress: data.fromAddress,
                toAddress: data.toAddress,
                fromToken: data.fromToken,
                toToken: data.toToken,
                fromAmount: data.fromAmount,
                fromAmountWei: data.fromAmountWei,
                toAmountMinWei: data.toAmountMinWei,
                toAmountMin: data.toAmountMin,
                toAmountWei: data.toAmountWei,
                toAmount: data.toAmount,
                estimated: data.estimated,
                maxSlippageBPS: data.maxSlippageBPS
            },
            paymentTokens: data.paymentTokens,
            processingFees: data.processingFees,
            client: params.client
        };
        return swapRoute;
    } catch (error) {
        console.error("Fetch error:", error);
        throw new Error(`Fetch failed: ${error}`);
    }
} //# sourceMappingURL=getQuote.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getHistory.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getBuyWithCryptoHistory": (()=>getBuyWithCryptoHistory)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/pay/utils/definitions.js [app-ssr] (ecmascript)");
;
;
async function getBuyWithCryptoHistory(params) {
    try {
        const queryParams = new URLSearchParams();
        queryParams.append("walletAddress", params.walletAddress);
        queryParams.append("start", params.start.toString());
        queryParams.append("count", params.count.toString());
        const queryString = queryParams.toString();
        const url = `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPayBuyWithCryptoHistoryEndpoint"])()}?${queryString}`;
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientFetch"])(params.client)(url);
        // Assuming the response directly matches the SwapResponse interface
        if (!response.ok) {
            response.body?.cancel();
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json()).result;
        return data;
    } catch (error) {
        throw new Error(`Fetch failed: ${error}`);
    }
} //# sourceMappingURL=getHistory.js.map
}}),
"[project]/node_modules/thirdweb/dist/esm/pay/buyWithCrypto/getStatus.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getBuyWithCryptoStatus": (()=>getBuyWithCryptoStatus)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/utils/fetch.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/thirdweb/dist/esm/pay/utils/definitions.js [app-ssr] (ecmascript)");
;
;
async function getBuyWithCryptoStatus(buyWithCryptoTransaction) {
    try {
        if (!buyWithCryptoTransaction.transactionHash) {
            throw new Error("Transaction hash is required");
        }
        const queryString = new URLSearchParams({
            transactionHash: buyWithCryptoTransaction.transactionHash
        }).toString();
        const url = `${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$pay$2f$utils$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getPayBuyWithCryptoStatusUrl"])()}?${queryString}`;
        const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$thirdweb$2f$dist$2f$esm$2f$utils$2f$fetch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getClientFetch"])(buyWithCryptoTransaction.client)(url);
        // Assuming the response directly matches the BuyWithCryptoStatus interface
        if (!response.ok) {
            response.body?.cancel();
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = (await response.json()).result;
        return data;
    } catch (error) {
        console.error("Fetch error:", error);
        throw new Error(`Fetch failed: ${error}`);
    }
} //# sourceMappingURL=getStatus.js.map
}}),

};

//# sourceMappingURL=node_modules_thirdweb_dist_esm_9dc14c22._.js.map