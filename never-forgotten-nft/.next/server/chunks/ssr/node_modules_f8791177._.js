module.exports = {

"[project]/node_modules/@eth-optimism/core-utils/dist/common/basic-types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=basic-types.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/common/hex-strings.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bytes32ify = exports.hexStringEquals = exports.encodeHex = exports.padHexString = exports.toRpcHexString = exports.toHexString = exports.fromHexString = exports.add0x = exports.remove0x = void 0;
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const bytes_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bytes/lib.esm/index.js [app-ssr] (ecmascript)");
const remove0x = (str)=>{
    if (str === undefined) {
        return str;
    }
    return str.startsWith('0x') ? str.slice(2) : str;
};
exports.remove0x = remove0x;
const add0x = (str)=>{
    if (str === undefined) {
        return str;
    }
    return str.startsWith('0x') ? str : '0x' + str;
};
exports.add0x = add0x;
const fromHexString = (inp)=>{
    if (typeof inp === 'string' && inp.startsWith('0x')) {
        return Buffer.from(inp.slice(2), 'hex');
    }
    return Buffer.from(inp);
};
exports.fromHexString = fromHexString;
const toHexString = (inp)=>{
    if (typeof inp === 'number') {
        return bignumber_1.BigNumber.from(inp).toHexString();
    } else {
        return '0x' + (0, exports.fromHexString)(inp).toString('hex');
    }
};
exports.toHexString = toHexString;
const toRpcHexString = (n)=>{
    let num;
    if (typeof n === 'number') {
        num = '0x' + n.toString(16);
    } else {
        num = n.toHexString();
    }
    if (num === '0x0') {
        return num;
    } else {
        return num.replace(/^0x0/, '0x');
    }
};
exports.toRpcHexString = toRpcHexString;
const padHexString = (str, length)=>{
    if (str.length === 2 + length * 2) {
        return str;
    } else {
        return '0x' + str.slice(2).padStart(length * 2, '0');
    }
};
exports.padHexString = padHexString;
const encodeHex = (val, len)=>(0, exports.remove0x)(bignumber_1.BigNumber.from(val).toHexString()).padStart(len, '0');
exports.encodeHex = encodeHex;
const hexStringEquals = (stringA, stringB)=>{
    if (!(0, bytes_1.isHexString)(stringA)) {
        throw new Error(`input is not a hex string: ${stringA}`);
    }
    if (!(0, bytes_1.isHexString)(stringB)) {
        throw new Error(`input is not a hex string: ${stringB}`);
    }
    return stringA.toLowerCase() === stringB.toLowerCase();
};
exports.hexStringEquals = hexStringEquals;
const bytes32ify = (value)=>{
    return (0, bytes_1.hexZeroPad)(bignumber_1.BigNumber.from(value).toHexString(), 32);
};
exports.bytes32ify = bytes32ify; //# sourceMappingURL=hex-strings.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/common/bn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bnToAddress = void 0;
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const address_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/address/lib.esm/index.js [app-ssr] (ecmascript)");
const hex_strings_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/hex-strings.js [app-ssr] (ecmascript)");
const bnToAddress = (bn)=>{
    bn = bignumber_1.BigNumber.from(bn);
    if (bn.isNegative()) {
        bn = bignumber_1.BigNumber.from('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF').add(bn).add(1);
    }
    let addr = bn.toHexString();
    addr = (0, hex_strings_1.remove0x)(addr);
    addr = addr.padStart(40, '0');
    addr = addr.slice(addr.length - 40, addr.length);
    addr = (0, hex_strings_1.add0x)(addr);
    addr = (0, address_1.getAddress)(addr);
    return addr;
};
exports.bnToAddress = bnToAddress; //# sourceMappingURL=bn.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/common/misc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.compareAddrs = exports.getenv = exports.reqenv = exports.clone = exports.sleep = void 0;
const sleep = async (ms)=>{
    return new Promise((resolve)=>{
        setTimeout(()=>{
            resolve(null);
        }, ms);
    });
};
exports.sleep = sleep;
const clone = (obj)=>{
    if (typeof obj === 'undefined') {
        throw new Error(`Trying to clone undefined object`);
    }
    return Object.assign({}, obj);
};
exports.clone = clone;
const reqenv = (name)=>{
    const value = process.env[name];
    if (value === undefined) {
        throw new Error(`missing env var ${name}`);
    }
    return value;
};
exports.reqenv = reqenv;
const getenv = (name, fallback)=>{
    return process.env[name] || fallback;
};
exports.getenv = getenv;
const compareAddrs = (a, b)=>{
    return a.toLowerCase() === b.toLowerCase();
};
exports.compareAddrs = compareAddrs; //# sourceMappingURL=misc.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/common/test-utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.expectApprox = exports.awaitCondition = void 0;
const chai_1 = __turbopack_context__.r("[project]/node_modules/chai/index.js [app-ssr] (ecmascript)");
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/misc.js [app-ssr] (ecmascript)");
const awaitCondition = async (cond, rate = 1000, attempts = 10)=>{
    for(let i = 0; i < attempts; i++){
        const ok = await cond();
        if (ok) {
            return;
        }
        await (0, misc_1.sleep)(rate);
    }
    throw new Error('Timed out.');
};
exports.awaitCondition = awaitCondition;
const expectApprox = (actual, target, { percentUpperDeviation, percentLowerDeviation, absoluteUpperDeviation, absoluteLowerDeviation })=>{
    actual = bignumber_1.BigNumber.from(actual);
    target = bignumber_1.BigNumber.from(target);
    const nonNullDeviations = percentUpperDeviation || percentLowerDeviation || absoluteUpperDeviation || absoluteLowerDeviation;
    if (!nonNullDeviations) {
        throw new Error('Must define at least one parameter to limit the deviation of the actual value.');
    }
    let upper;
    const upperPcnt = !percentUpperDeviation ? null : target.mul(100 + percentUpperDeviation).div(100);
    const upperAbs = !absoluteUpperDeviation ? null : target.add(absoluteUpperDeviation);
    if (upperPcnt && upperAbs) {
        upper = upperPcnt.lte(upperAbs) ? upperPcnt : upperAbs;
    } else {
        upper = upperPcnt || upperAbs;
    }
    let lower;
    const lowerPcnt = !percentLowerDeviation ? null : target.mul(100 - percentLowerDeviation).div(100);
    const lowerAbs = !absoluteLowerDeviation ? null : target.sub(absoluteLowerDeviation);
    if (lowerPcnt && lowerAbs) {
        lower = lowerPcnt.gte(lowerAbs) ? lowerPcnt : lowerAbs;
    } else {
        lower = lowerPcnt || lowerAbs;
    }
    if (upper) {
        (0, chai_1.expect)(actual.lte(upper), `Actual value (${actual}) is greater than the calculated upper bound of (${upper})`).to.be.true;
    }
    if (lower) {
        (0, chai_1.expect)(actual.gte(lower), `Actual value (${actual}) is less than the calculated lower bound of (${lower})`).to.be.true;
    }
};
exports.expectApprox = expectApprox; //# sourceMappingURL=test-utils.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/common/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/basic-types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/bn.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/hex-strings.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/misc.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/test-utils.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/external/bcfg/bcfg-types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=bcfg-types.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/external/bcfg/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/external/bcfg/bcfg-types.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/external/ethers/network.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getChainId = void 0;
const getChainId = async (provider)=>{
    const network = await provider.getNetwork();
    return network.chainId;
};
exports.getChainId = getChainId; //# sourceMappingURL=network.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/external/ethers/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/external/ethers/network.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/external/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/external/bcfg/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/external/ethers/index.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/alias.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.L1_TO_L2_ALIAS_OFFSET = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/address/lib.esm/index.js [app-ssr] (ecmascript)");
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/index.js [app-ssr] (ecmascript)");
exports.L1_TO_L2_ALIAS_OFFSET = '0x1111000000000000000000000000000000001111';
const applyL1ToL2Alias = (address)=>{
    if (!(0, address_1.isAddress)(address)) {
        throw new Error(`not a valid address: ${address}`);
    }
    return (0, common_1.bnToAddress)(bignumber_1.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET));
};
exports.applyL1ToL2Alias = applyL1ToL2Alias;
const undoL1ToL2Alias = (address)=>{
    if (!(0, address_1.isAddress)(address)) {
        throw new Error(`not a valid address: ${address}`);
    }
    return (0, common_1.bnToAddress)(bignumber_1.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET));
};
exports.undoL1ToL2Alias = undoL1ToL2Alias; //# sourceMappingURL=alias.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/fees.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calldataCost = exports.zeroesAndOnes = exports.calculateL1Fee = exports.calculateL1GasUsed = exports.scaleDecimals = exports.txDataNonZeroGasEIP2028 = exports.txDataZeroGas = void 0;
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const common_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/index.js [app-ssr] (ecmascript)");
exports.txDataZeroGas = 4;
exports.txDataNonZeroGasEIP2028 = 16;
const big10 = bignumber_1.BigNumber.from(10);
const scaleDecimals = (value, decimals)=>{
    value = bignumber_1.BigNumber.from(value);
    decimals = bignumber_1.BigNumber.from(decimals);
    const divisor = big10.pow(decimals);
    return value.div(divisor);
};
exports.scaleDecimals = scaleDecimals;
const calculateL1GasUsed = (data, overhead)=>{
    const [zeroes, ones] = (0, exports.zeroesAndOnes)(data);
    const zeroesCost = zeroes * exports.txDataZeroGas;
    const onesCost = (ones + 68) * exports.txDataNonZeroGasEIP2028;
    return bignumber_1.BigNumber.from(onesCost).add(zeroesCost).add(overhead);
};
exports.calculateL1GasUsed = calculateL1GasUsed;
const calculateL1Fee = (data, overhead, l1GasPrice, scalar, decimals)=>{
    const l1GasUsed = (0, exports.calculateL1GasUsed)(data, overhead);
    const l1Fee = l1GasUsed.mul(l1GasPrice);
    const scaled = l1Fee.mul(scalar);
    const result = (0, exports.scaleDecimals)(scaled, decimals);
    return result;
};
exports.calculateL1Fee = calculateL1Fee;
const zeroesAndOnes = (data)=>{
    if (typeof data === 'string') {
        data = Buffer.from((0, common_1.remove0x)(data), 'hex');
    }
    let zeros = 0;
    let ones = 0;
    for (const byte of data){
        if (byte === 0) {
            zeros++;
        } else {
            ones++;
        }
    }
    return [
        zeros,
        ones
    ];
};
exports.zeroesAndOnes = zeroesAndOnes;
const calldataCost = (data)=>{
    const [zeros, ones] = (0, exports.zeroesAndOnes)(data);
    const zeroCost = bignumber_1.BigNumber.from(zeros).mul(exports.txDataZeroGas);
    const nonZeroCost = bignumber_1.BigNumber.from(ones).mul(exports.txDataNonZeroGasEIP2028);
    return zeroCost.add(nonZeroCost);
};
exports.calldataCost = calldataCost; //# sourceMappingURL=fees.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/op-node.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=op-node.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/deposit-transaction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DepositTx = exports.SourceHashDomain = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/address/lib.esm/index.js [app-ssr] (ecmascript)");
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const keccak256_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/keccak256/lib.esm/index.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-ssr] (ecmascript)");
const RLP = __importStar(__turbopack_context__.r("[project]/node_modules/@ethersproject/rlp/lib.esm/index.js [app-ssr] (ecmascript)"));
const bytes_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bytes/lib.esm/index.js [app-ssr] (ecmascript)");
const formatBoolean = (value)=>{
    return value ? new Uint8Array([
        1
    ]) : new Uint8Array([]);
};
const formatNumber = (value, name)=>{
    const result = (0, bytes_1.stripZeros)(bignumber_1.BigNumber.from(value).toHexString());
    if (result.length > 32) {
        throw new Error(`invalid length for ${name}`);
    }
    return result;
};
const handleBoolean = (value)=>{
    if (value === '0x') {
        return false;
    }
    if (value === '0x01') {
        return true;
    }
    throw new Error(`invalid boolean RLP hex value ${value}`);
};
const handleNumber = (value)=>{
    if (value === '0x') {
        return constants_1.Zero;
    }
    return bignumber_1.BigNumber.from(value);
};
const handleAddress = (value)=>{
    if (value === '0x') {
        return null;
    }
    return (0, address_1.getAddress)(value);
};
var SourceHashDomain;
(function(SourceHashDomain) {
    SourceHashDomain[SourceHashDomain["UserDeposit"] = 0] = "UserDeposit";
    SourceHashDomain[SourceHashDomain["L1InfoDeposit"] = 1] = "L1InfoDeposit";
})(SourceHashDomain || (exports.SourceHashDomain = SourceHashDomain = {}));
class DepositTx {
    constructor(opts = {}){
        this.type = 0x7e;
        this.version = 0x00;
        this._sourceHash = opts.sourceHash;
        this.from = opts.from;
        this.to = opts.to;
        this.mint = opts.mint;
        this.value = opts.value;
        this.gas = opts.gas;
        this.isSystemTransaction = opts.isSystemTransaction || false;
        this.data = opts.data;
        this.domain = opts.domain;
        this.l1BlockHash = opts.l1BlockHash;
        this.logIndex = opts.logIndex;
        this.sequenceNumber = opts.sequenceNumber;
    }
    hash() {
        const encoded = this.encode();
        return (0, keccak256_1.keccak256)(encoded);
    }
    sourceHash() {
        if (!this._sourceHash) {
            let marker;
            switch(this.domain){
                case SourceHashDomain.UserDeposit:
                    marker = bignumber_1.BigNumber.from(this.logIndex).toHexString();
                    break;
                case SourceHashDomain.L1InfoDeposit:
                    marker = bignumber_1.BigNumber.from(this.sequenceNumber).toHexString();
                    break;
                default:
                    throw new Error(`Unknown domain: ${this.domain}`);
            }
            if (!this.l1BlockHash) {
                throw new Error('Need l1BlockHash to compute sourceHash');
            }
            const l1BlockHash = this.l1BlockHash;
            const input = (0, bytes_1.hexConcat)([
                l1BlockHash,
                (0, bytes_1.zeroPad)(marker, 32)
            ]);
            const depositIDHash = (0, keccak256_1.keccak256)(input);
            const domain = bignumber_1.BigNumber.from(this.domain).toHexString();
            const domainInput = (0, bytes_1.hexConcat)([
                (0, bytes_1.zeroPad)(domain, 32),
                depositIDHash
            ]);
            this._sourceHash = (0, keccak256_1.keccak256)(domainInput);
        }
        return this._sourceHash;
    }
    encode() {
        const fields = [
            this.sourceHash() || '0x',
            (0, address_1.getAddress)(this.from) || '0x',
            this.to != null ? (0, address_1.getAddress)(this.to) : '0x',
            formatNumber(this.mint || 0, 'mint'),
            formatNumber(this.value || 0, 'value'),
            formatNumber(this.gas || 0, 'gas'),
            formatBoolean(this.isSystemTransaction),
            this.data || '0x'
        ];
        return (0, bytes_1.hexConcat)([
            bignumber_1.BigNumber.from(this.type).toHexString(),
            RLP.encode(fields)
        ]);
    }
    decode(raw, extra = {}) {
        const payload = (0, bytes_1.arrayify)(raw);
        if (payload[0] !== this.type) {
            throw new Error(`Invalid type ${payload[0]}`);
        }
        this.version = payload[1];
        const transaction = RLP.decode(payload.slice(1));
        this._sourceHash = transaction[0];
        this.from = handleAddress(transaction[1]);
        this.to = handleAddress(transaction[2]);
        this.mint = handleNumber(transaction[3]);
        this.value = handleNumber(transaction[4]);
        this.gas = handleNumber(transaction[5]);
        this.isSystemTransaction = handleBoolean(transaction[6]);
        this.data = transaction[7];
        if ('l1BlockHash' in extra) {
            this.l1BlockHash = extra.l1BlockHash;
        }
        if ('domain' in extra) {
            this.domain = extra.domain;
        }
        if ('logIndex' in extra) {
            this.logIndex = extra.logIndex;
        }
        if ('sequenceNumber' in extra) {
            this.sequenceNumber = extra.sequenceNumber;
        }
        return this;
    }
    static decode(raw, extra) {
        return new this().decode(raw, extra);
    }
    fromL1Receipt(receipt, index) {
        if (!receipt.events) {
            throw new Error('cannot parse receipt');
        }
        const event = receipt.events[index];
        if (!event) {
            throw new Error(`event index ${index} does not exist`);
        }
        return this.fromL1Event(event);
    }
    static fromL1Receipt(receipt, index) {
        return new this({}).fromL1Receipt(receipt, index);
    }
    fromL1Event(event) {
        if (event.event !== 'TransactionDeposited') {
            throw new Error(`incorrect event type: ${event.event}`);
        }
        if (typeof event.args === 'undefined') {
            throw new Error('no event args');
        }
        if (typeof event.args.from === 'undefined') {
            throw new Error('"from" undefined');
        }
        this.from = event.args.from;
        if (typeof event.args.to === 'undefined') {
            throw new Error('"to" undefined');
        }
        if (typeof event.args.version === 'undefined') {
            throw new Error(`"verison" undefined`);
        }
        if (!event.args.version.eq(0)) {
            throw new Error(`Unsupported version ${event.args.version.toString()}`);
        }
        if (typeof event.args.opaqueData === 'undefined') {
            throw new Error(`"opaqueData" undefined`);
        }
        const opaqueData = event.args.opaqueData;
        if (opaqueData.length < 32 + 32 + 8 + 1) {
            throw new Error(`invalid opaqueData size: ${opaqueData.length}`);
        }
        let offset = 0;
        this.mint = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(opaqueData, offset, offset + 32));
        offset += 32;
        this.value = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(opaqueData, offset, offset + 32));
        offset += 32;
        this.gas = bignumber_1.BigNumber.from((0, bytes_1.hexDataSlice)(opaqueData, offset, offset + 8));
        offset += 8;
        const isCreation = bignumber_1.BigNumber.from(opaqueData[offset]).eq(1);
        offset += 1;
        this.to = isCreation === true ? null : event.args.to;
        const length = opaqueData.length - offset;
        this.isSystemTransaction = false;
        this.data = (0, bytes_1.hexDataSlice)(opaqueData, offset, offset + length);
        this.domain = SourceHashDomain.UserDeposit;
        this.l1BlockHash = event.blockHash;
        this.logIndex = event.logIndex;
        return this;
    }
    static fromL1Event(event) {
        return new this({}).fromL1Event(event);
    }
}
exports.DepositTx = DepositTx; //# sourceMappingURL=deposit-transaction.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/encoding.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeCrossDomainMessage = exports.encodeCrossDomainMessageV1 = exports.encodeCrossDomainMessageV0 = exports.decodeVersionedNonce = exports.encodeVersionedNonce = void 0;
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const abi_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/abi/lib.esm/index.js [app-ssr] (ecmascript)");
const iface = new abi_1.Interface([
    'function relayMessage(address,address,bytes,uint256)',
    'function relayMessage(uint256,address,address,uint256,uint256,bytes)'
]);
const nonceMask = bignumber_1.BigNumber.from('0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const encodeVersionedNonce = (nonce, version)=>{
    return version.or(nonce.shl(240));
};
exports.encodeVersionedNonce = encodeVersionedNonce;
const decodeVersionedNonce = (nonce)=>{
    return {
        version: nonce.shr(240),
        nonce: nonce.and(nonceMask)
    };
};
exports.decodeVersionedNonce = decodeVersionedNonce;
const encodeCrossDomainMessageV0 = (target, sender, data, nonce)=>{
    return iface.encodeFunctionData('relayMessage(address,address,bytes,uint256)', [
        target,
        sender,
        data,
        nonce
    ]);
};
exports.encodeCrossDomainMessageV0 = encodeCrossDomainMessageV0;
const encodeCrossDomainMessageV1 = (nonce, sender, target, value, gasLimit, data)=>{
    return iface.encodeFunctionData('relayMessage(uint256,address,address,uint256,uint256,bytes)', [
        nonce,
        sender,
        target,
        value,
        gasLimit,
        data
    ]);
};
exports.encodeCrossDomainMessageV1 = encodeCrossDomainMessageV1;
const encodeCrossDomainMessage = (nonce, sender, target, value, gasLimit, data)=>{
    const { version } = (0, exports.decodeVersionedNonce)(nonce);
    if (version.eq(0)) {
        return (0, exports.encodeCrossDomainMessageV0)(target, sender, data, nonce);
    } else if (version.eq(1)) {
        return (0, exports.encodeCrossDomainMessageV1)(nonce, sender, target, value, gasLimit, data);
    }
    throw new Error(`unknown version ${version.toString()}`);
};
exports.encodeCrossDomainMessage = encodeCrossDomainMessage; //# sourceMappingURL=encoding.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/hashing.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashOutputRootProof = exports.hashWithdrawal = exports.hashCrossDomainMessagev1 = exports.hashCrossDomainMessagev0 = exports.hashCrossDomainMessage = void 0;
const keccak256_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/keccak256/lib.esm/index.js [app-ssr] (ecmascript)");
const abi_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/abi/lib.esm/index.js [app-ssr] (ecmascript)");
const encoding_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/encoding.js [app-ssr] (ecmascript)");
const hashCrossDomainMessage = (nonce, sender, target, value, gasLimit, message)=>{
    const { version } = (0, encoding_1.decodeVersionedNonce)(nonce);
    if (version.eq(0)) {
        return (0, exports.hashCrossDomainMessagev0)(target, sender, message, nonce);
    } else if (version.eq(1)) {
        return (0, exports.hashCrossDomainMessagev1)(nonce, sender, target, value, gasLimit, message);
    }
    throw new Error(`unknown version ${version.toString()}`);
};
exports.hashCrossDomainMessage = hashCrossDomainMessage;
const hashCrossDomainMessagev0 = (target, sender, message, nonce)=>{
    return (0, keccak256_1.keccak256)((0, encoding_1.encodeCrossDomainMessageV0)(target, sender, message, nonce));
};
exports.hashCrossDomainMessagev0 = hashCrossDomainMessagev0;
const hashCrossDomainMessagev1 = (nonce, sender, target, value, gasLimit, message)=>{
    return (0, keccak256_1.keccak256)((0, encoding_1.encodeCrossDomainMessageV1)(nonce, sender, target, value, gasLimit, message));
};
exports.hashCrossDomainMessagev1 = hashCrossDomainMessagev1;
const hashWithdrawal = (nonce, sender, target, value, gasLimit, message)=>{
    const types = [
        'uint256',
        'address',
        'address',
        'uint256',
        'uint256',
        'bytes'
    ];
    const encoded = abi_1.defaultAbiCoder.encode(types, [
        nonce,
        sender,
        target,
        value,
        gasLimit,
        message
    ]);
    return (0, keccak256_1.keccak256)(encoded);
};
exports.hashWithdrawal = hashWithdrawal;
const hashOutputRootProof = (proof)=>{
    return (0, keccak256_1.keccak256)(abi_1.defaultAbiCoder.encode([
        'bytes32',
        'bytes32',
        'bytes32',
        'bytes32'
    ], [
        proof.version,
        proof.stateRoot,
        proof.messagePasserStorageRoot,
        proof.latestBlockhash
    ]));
};
exports.hashOutputRootProof = hashOutputRootProof; //# sourceMappingURL=hashing.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/op-provider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OpNodeProvider = void 0;
const events_1 = __importDefault(__turbopack_context__.r("[externals]/events [external] (events, cjs)"));
const bignumber_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)");
const properties_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/properties/lib.esm/index.js [app-ssr] (ecmascript)");
const web_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/web/lib.esm/index.js [app-ssr] (ecmascript)");
const getResult = (payload)=>{
    if (payload.error) {
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
};
class OpNodeProvider extends events_1.default {
    constructor(url){
        super();
        this._nextId = 0;
        if (typeof url === 'string') {
            this.connection = {
                url
            };
        } else {
            this.connection = url;
        }
    }
    async syncStatus() {
        const result = await this.send('optimism_syncStatus', []);
        return {
            currentL1: {
                hash: result.current_l1.hash,
                number: bignumber_1.BigNumber.from(result.current_l1.number),
                parentHash: result.current_l1.parentHash,
                timestamp: bignumber_1.BigNumber.from(result.current_l1.timestamp)
            },
            headL1: {
                hash: result.head_l1.hash,
                number: bignumber_1.BigNumber.from(result.head_l1.number),
                parentHash: result.head_l1.parentHash,
                timestamp: bignumber_1.BigNumber.from(result.head_l1.timestamp)
            },
            unsafeL2: {
                hash: result.unsafe_l2.hash,
                number: bignumber_1.BigNumber.from(result.unsafe_l2.number),
                parentHash: result.unsafe_l2.parentHash,
                timestamp: bignumber_1.BigNumber.from(result.unsafe_l2.timestamp),
                l1Origin: {
                    hash: result.unsafe_l2.l1origin.hash,
                    number: bignumber_1.BigNumber.from(result.unsafe_l2.l1origin.number)
                },
                sequencerNumber: bignumber_1.BigNumber.from(result.unsafe_l2.sequenceNumber)
            },
            safeL2: {
                hash: result.safe_l2.hash,
                number: bignumber_1.BigNumber.from(result.safe_l2.number),
                parentHash: result.safe_l2.parentHash,
                timestamp: bignumber_1.BigNumber.from(result.safe_l2.timestamp),
                l1Origin: {
                    hash: result.safe_l2.l1origin.hash,
                    number: bignumber_1.BigNumber.from(result.safe_l2.l1origin.number)
                },
                sequencerNumber: bignumber_1.BigNumber.from(result.safe_l2.sequenceNumber)
            },
            finalizedL2: {
                hash: result.finalized_l2.hash,
                number: bignumber_1.BigNumber.from(result.finalized_l2.number),
                parentHash: result.finalized_l2.parentHash,
                timestamp: bignumber_1.BigNumber.from(result.finalized_l2.timestamp),
                l1Origin: {
                    hash: result.finalized_l2.l1origin.hash,
                    number: bignumber_1.BigNumber.from(result.finalized_l2.l1origin.number)
                },
                sequencerNumber: bignumber_1.BigNumber.from(result.finalized_l2.sequenceNumber)
            }
        };
    }
    async rollupConfig() {
        const result = await this.send('optimism_rollupConfig', []);
        return result;
    }
    send(method, params) {
        const request = {
            method,
            params,
            id: this._nextId++,
            jsonrpc: '2.0'
        };
        this.emit('debug', {
            action: 'request',
            request: (0, properties_1.deepCopy)(request),
            provider: this
        });
        const result = (0, web_1.fetchJson)(this.connection, JSON.stringify(request), getResult).then((res)=>{
            this.emit('debug', {
                action: 'response',
                request,
                response: res,
                provider: this
            });
            return res;
        }, (error)=>{
            this.emit('debug', {
                action: 'response',
                error,
                request,
                provider: this
            });
            throw error;
        });
        return result;
    }
}
exports.OpNodeProvider = OpNodeProvider; //# sourceMappingURL=op-provider.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultResourceConfig = exports.predeploys = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-ssr] (ecmascript)");
exports.predeploys = {
    L2ToL1MessagePasser: '0x4200000000000000000000000000000000000016',
    DeployerWhitelist: '0x4200000000000000000000000000000000000002',
    L2CrossDomainMessenger: '0x4200000000000000000000000000000000000007',
    GasPriceOracle: '0x420000000000000000000000000000000000000F',
    L2StandardBridge: '0x4200000000000000000000000000000000000010',
    SequencerFeeVault: '0x4200000000000000000000000000000000000011',
    OptimismMintableERC20Factory: '0x4200000000000000000000000000000000000012',
    L1BlockNumber: '0x4200000000000000000000000000000000000013',
    L1Block: '0x4200000000000000000000000000000000000015',
    LegacyERC20ETH: '0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000',
    WETH9: '0x4200000000000000000000000000000000000006',
    GovernanceToken: '0x4200000000000000000000000000000000000042',
    LegacyMessagePasser: '0x4200000000000000000000000000000000000000',
    L2ERC721Bridge: '0x4200000000000000000000000000000000000014',
    OptimismMintableERC721Factory: '0x4200000000000000000000000000000000000017',
    ProxyAdmin: '0x4200000000000000000000000000000000000018',
    BaseFeeVault: '0x4200000000000000000000000000000000000019',
    L1FeeVault: '0x420000000000000000000000000000000000001a'
};
const uint128Max = ethers_1.ethers.BigNumber.from('0xffffffffffffffffffffffffffffffff');
exports.defaultResourceConfig = {
    maxResourceLimit: 20000000,
    elasticityMultiplier: 10,
    baseFeeMaxChangeDenominator: 8,
    minimumBaseFee: ethers_1.ethers.utils.parseUnits('1', 'gwei'),
    systemTxMaxGas: 1000000,
    maximumBaseFee: uint128Max
}; //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/optimism/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/alias.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/fees.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/op-node.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/deposit-transaction.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/encoding.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/hashing.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/op-provider.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/constants.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/gnosis-safe-checksum.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addChecksum = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-ssr] (ecmascript)");
const stringifyReplacer = (_, value)=>value === undefined ? null : value;
const serializeJSONObject = (json)=>{
    if (Array.isArray(json)) {
        return `[${json.map((el)=>serializeJSONObject(el)).join(',')}]`;
    }
    if (typeof json === 'object' && json !== null) {
        let acc = '';
        const keys = Object.keys(json).sort();
        acc += `{${JSON.stringify(keys, stringifyReplacer)}`;
        for (const key of keys){
            acc += `${serializeJSONObject(json[key])},`;
        }
        return `${acc}}`;
    }
    return `${JSON.stringify(json, stringifyReplacer)}`;
};
const calculateChecksum = (batchFile)=>{
    const serialized = serializeJSONObject(Object.assign(Object.assign({}, batchFile), {
        meta: Object.assign(Object.assign({}, batchFile.meta), {
            name: null
        })
    }));
    const sha = ethers_1.ethers.utils.solidityKeccak256([
        'string'
    ], [
        serialized
    ]);
    return sha || undefined;
};
const addChecksum = (batchFile)=>{
    return Object.assign(Object.assign({}, batchFile), {
        meta: Object.assign(Object.assign({}, batchFile.meta), {
            checksum: calculateChecksum(batchFile)
        })
    });
};
exports.addChecksum = addChecksum; //# sourceMappingURL=gnosis-safe-checksum.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/etherscan.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Etherscan = void 0;
const node_fetch_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/node-fetch/lib/index.mjs [app-ssr] (ecmascript)"));
const networks = {
    1: {
        chainId: 1,
        names: [
            'mainnet',
            'main',
            'eth',
            'ethereum'
        ],
        etherscanApiUrl: 'https://api.etherscan.io'
    },
    3: {
        chainId: 3,
        names: [
            'ropsten'
        ],
        etherscanApiUrl: 'https://api-ropsten.etherscan.io'
    },
    4: {
        chainId: 4,
        names: [
            'rinkeby'
        ],
        etherscanApiUrl: 'https://api-rinkeby.etherscan.io'
    },
    5: {
        chainId: 5,
        names: [
            'goerli'
        ],
        etherscanApiUrl: 'https://api-goerli.etherscan.io'
    },
    10: {
        chainId: 10,
        names: [
            'optimism'
        ],
        etherscanApiUrl: 'https://api-optimistic.etherscan.io'
    },
    42: {
        chainId: 42,
        names: [
            'kovan'
        ],
        etherscanApiUrl: 'https://api-kovan.etherscan.io'
    },
    69: {
        chainId: 69,
        names: [
            'opkovan',
            'kovan-optimism',
            'optimistic-kovan'
        ],
        etherscanApiUrl: 'https://api-kovan-optimistic.etherscan.io'
    }
};
class Etherscan {
    constructor(apiKey, network){
        this.apiKey = apiKey;
        this.network = network;
        if (typeof network === 'string') {
            this.net = Object.values(networks).find((net)=>{
                return net.names.includes(network);
            });
        } else {
            this.net = networks[this.network];
        }
    }
    async getContractSource(address) {
        const url = new URL(`${this.net.etherscanApiUrl}/api`);
        url.searchParams.append('module', 'contract');
        url.searchParams.append('action', 'getsourcecode');
        url.searchParams.append('address', address);
        url.searchParams.append('apikey', this.apiKey);
        const response = await (0, node_fetch_1.default)(url);
        const result = await response.json();
        return result.result[0];
    }
    async getContractABI(address) {
        const source = await this.getContractSource(address);
        if (source.Proxy === '1') {
            const impl = await this.getContractSource(source.Implementation);
            return impl.ABI;
        } else {
            return source.ABI;
        }
    }
}
exports.Etherscan = Etherscan; //# sourceMappingURL=etherscan.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/helpers/setupProxyContract.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setupProxyContract = void 0;
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-ssr] (ecmascript)");
const { getAddress } = ethers_1.utils;
const setupProxyContract = async (proxyContract, signer, { targetImplAddress, targetProxyOwnerAddress, postUpgradeCallCalldata })=>{
    const currentAdmin = await proxyContract.connect(ethers_1.ethers.constants.AddressZero).callStatic.admin();
    const signerAddress = await signer.getAddress();
    const currentImplementation = await proxyContract.connect(ethers_1.ethers.constants.AddressZero).callStatic.implementation();
    console.log(`implementation currently set to ${currentImplementation}`);
    if (getAddress(currentImplementation) !== getAddress(targetImplAddress)) {
        console.log('implementation not set to correct contract');
        console.log(`Setting implementation to ${targetImplAddress}`);
        (0, assert_1.default)(signerAddress === currentAdmin, 'the passed signer is not the admin, cannot update implementation');
        let tx;
        if (!postUpgradeCallCalldata) {
            console.log('postUpgradeCallCalldata is not provided. Using Proxy.upgrade()');
            tx = await proxyContract.connect(signer).upgradeTo(targetImplAddress);
        } else {
            console.log('postUpgradeCallCalldata is provided. Using Proxy.upgradeAndCall()');
            tx = await proxyContract.connect(signer).upgradeToAndCall(targetImplAddress, postUpgradeCallCalldata);
        }
        const receipt = await tx.wait();
        console.log(`implementation set in ${receipt.transactionHash}`);
    } else {
        console.log(`implementation already set correctly to ${targetImplAddress}`);
    }
    console.log(`admin set to ${currentAdmin}`);
    if (getAddress(currentAdmin) !== getAddress(targetProxyOwnerAddress)) {
        console.log('detected admin is not set correctly');
        console.log(`Setting admin to ${targetProxyOwnerAddress}`);
        (0, assert_1.default)(signerAddress === currentAdmin, 'proxyOwnerSigner is not the admin, cannot update admin');
        const tx = await proxyContract.connect(signer).changeAdmin(targetProxyOwnerAddress);
        const receipt = await tx.wait();
        console.log(`admin set in ${receipt.transactionHash}`);
    } else {
        console.log(`admin already set correctly to ${targetProxyOwnerAddress}`);
    }
    const updatedImplementation = await proxyContract.connect(ethers_1.ethers.constants.AddressZero).callStatic.implementation();
    const updatedAdmin = await proxyContract.connect(ethers_1.ethers.constants.AddressZero).callStatic.admin();
    (0, assert_1.default)(getAddress(updatedAdmin) === getAddress(targetProxyOwnerAddress), 'Something went wrong - admin not set correctly after transaction');
    (0, assert_1.default)(getAddress(updatedImplementation) === getAddress(targetImplAddress), 'Something went wrong - implementation not set correctly after transaction');
    console.log(`Proxy at ${proxyContract.address} is set up with implementation: ${updatedImplementation} and admin: ${updatedAdmin}`);
};
exports.setupProxyContract = setupProxyContract; //# sourceMappingURL=setupProxyContract.js.map
}}),
"[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/common/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/external/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/optimism/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/gnosis-safe-checksum.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/etherscan.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/helpers/setupProxyContract.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
;
;
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <exports>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BigNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BigNumber"]),
    "FixedFormat": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$fixednumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FixedFormat"]),
    "FixedNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$fixednumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["FixedNumber"]),
    "_base16To36": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_base16To36"]),
    "_base36To16": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_base36To16"]),
    "formatFixed": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$fixednumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatFixed"]),
    "parseFixed": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$fixednumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseFixed"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$fixednumber$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BigNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["BigNumber"]),
    "FixedFormat": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["FixedFormat"]),
    "FixedNumber": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["FixedNumber"]),
    "_base16To36": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["_base16To36"]),
    "_base36To16": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["_base36To16"]),
    "formatFixed": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["formatFixed"]),
    "parseFixed": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__["parseFixed"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$exports$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/index.js [app-ssr] (ecmascript) <exports>");
}}),
"[project]/node_modules/assertion-error/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */ /*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */ function exclude() {
    var excludes = [].slice.call(arguments);
    function excludeProps(res, obj) {
        Object.keys(obj).forEach(function(key) {
            if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
    }
    return function extendExclude() {
        var args = [].slice.call(arguments), i = 0, res = {};
        for(; i < args.length; i++){
            excludeProps(res, args[i]);
        }
        return res;
    };
}
;
/*!
 * Primary Exports
 */ module.exports = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */ function AssertionError(message, _props, ssf) {
    var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'), props = extend(_props || {});
    // default values
    this.message = message || 'Unspecified AssertionError';
    this.showDiff = false;
    // copy from properties
    for(var key in props){
        this[key] = props[key];
    }
    // capture stack trace
    ssf = ssf || AssertionError;
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
    } else {
        try {
            throw new Error();
        } catch (e) {
            this.stack = e.stack;
        }
    }
}
/*!
 * Inherit from Error.prototype
 */ AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */ AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */ AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */ AssertionError.prototype.toJSON = function(stack) {
    var extend = exclude('constructor', 'toJSON', 'stack'), props = extend({
        name: this.name
    }, this);
    // include stack if exists and not turned off
    if (false !== stack && this.stack) {
        props.stack = this.stack;
    }
    return props;
};
}}),
"[project]/node_modules/pathval/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* !
 * Chai - pathval utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * @see https://github.com/logicalparadox/filtr
 * MIT Licensed
 */ /**
 * ### .hasProperty(object, name)
 *
 * This allows checking whether an object has own
 * or inherited from prototype chain named property.
 *
 * Basically does the same thing as the `in`
 * operator but works properly with null/undefined values
 * and other primitives.
 *
 *     var obj = {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *
 * The following would be the results.
 *
 *     hasProperty(obj, 'str');  // true
 *     hasProperty(obj, 'constructor');  // true
 *     hasProperty(obj, 'bar');  // false
 *
 *     hasProperty(obj.str, 'length'); // true
 *     hasProperty(obj.str, 1);  // true
 *     hasProperty(obj.str, 5);  // false
 *
 *     hasProperty(obj.arr, 'length');  // true
 *     hasProperty(obj.arr, 2);  // true
 *     hasProperty(obj.arr, 3);  // false
 *
 * @param {Object} object
 * @param {String|Symbol} name
 * @returns {Boolean} whether it exists
 * @namespace Utils
 * @name hasProperty
 * @api public
 */ function hasProperty(obj, name) {
    if (typeof obj === 'undefined' || obj === null) {
        return false;
    }
    // The `in` operator does not work with primitives.
    return name in Object(obj);
}
/* !
 * ## parsePath(path)
 *
 * Helper function used to parse string object
 * paths. Use in conjunction with `internalGetPathValue`.
 *
 *      var parsed = parsePath('myobject.property.subprop');
 *
 * ### Paths:
 *
 * * Can be infinitely deep and nested.
 * * Arrays are also valid using the formal `myobject.document[3].property`.
 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
 *
 * @param {String} path
 * @returns {Object} parsed
 * @api private
 */ function parsePath(path) {
    var str = path.replace(/([^\\])\[/g, '$1.[');
    var parts = str.match(/(\\\.|[^.]+?)+/g);
    return parts.map(function mapMatches(value) {
        if (value === 'constructor' || value === '__proto__' || value === 'prototype') {
            return {};
        }
        var regexp = /^\[(\d+)\]$/;
        var mArr = regexp.exec(value);
        var parsed = null;
        if (mArr) {
            parsed = {
                i: parseFloat(mArr[1])
            };
        } else {
            parsed = {
                p: value.replace(/\\([.[\]])/g, '$1')
            };
        }
        return parsed;
    });
}
/* !
 * ## internalGetPathValue(obj, parsed[, pathDepth])
 *
 * Helper companion function for `.parsePath` that returns
 * the value located at the parsed address.
 *
 *      var value = getPathValue(obj, parsed);
 *
 * @param {Object} object to search against
 * @param {Object} parsed definition from `parsePath`.
 * @param {Number} depth (nesting level) of the property we want to retrieve
 * @returns {Object|Undefined} value
 * @api private
 */ function internalGetPathValue(obj, parsed, pathDepth) {
    var temporaryValue = obj;
    var res = null;
    pathDepth = typeof pathDepth === 'undefined' ? parsed.length : pathDepth;
    for(var i = 0; i < pathDepth; i++){
        var part = parsed[i];
        if (temporaryValue) {
            if (typeof part.p === 'undefined') {
                temporaryValue = temporaryValue[part.i];
            } else {
                temporaryValue = temporaryValue[part.p];
            }
            if (i === pathDepth - 1) {
                res = temporaryValue;
            }
        }
    }
    return res;
}
/* !
 * ## internalSetPathValue(obj, value, parsed)
 *
 * Companion function for `parsePath` that sets
 * the value located at a parsed address.
 *
 *  internalSetPathValue(obj, 'value', parsed);
 *
 * @param {Object} object to search and define on
 * @param {*} value to use upon set
 * @param {Object} parsed definition from `parsePath`
 * @api private
 */ function internalSetPathValue(obj, val, parsed) {
    var tempObj = obj;
    var pathDepth = parsed.length;
    var part = null;
    // Here we iterate through every part of the path
    for(var i = 0; i < pathDepth; i++){
        var propName = null;
        var propVal = null;
        part = parsed[i];
        // If it's the last part of the path, we set the 'propName' value with the property name
        if (i === pathDepth - 1) {
            propName = typeof part.p === 'undefined' ? part.i : part.p;
            // Now we set the property with the name held by 'propName' on object with the desired val
            tempObj[propName] = val;
        } else if (typeof part.p !== 'undefined' && tempObj[part.p]) {
            tempObj = tempObj[part.p];
        } else if (typeof part.i !== 'undefined' && tempObj[part.i]) {
            tempObj = tempObj[part.i];
        } else {
            // If the obj doesn't have the property we create one with that name to define it
            var next = parsed[i + 1];
            // Here we set the name of the property which will be defined
            propName = typeof part.p === 'undefined' ? part.i : part.p;
            // Here we decide if this property will be an array or a new object
            propVal = typeof next.p === 'undefined' ? [] : {};
            tempObj[propName] = propVal;
            tempObj = tempObj[propName];
        }
    }
}
/**
 * ### .getPathInfo(object, path)
 *
 * This allows the retrieval of property info in an
 * object given a string path.
 *
 * The path info consists of an object with the
 * following properties:
 *
 * * parent - The parent object of the property referenced by `path`
 * * name - The name of the final property, a number if it was an array indexer
 * * value - The value of the property, if it exists, otherwise `undefined`
 * * exists - Whether the property exists or not
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} info
 * @namespace Utils
 * @name getPathInfo
 * @api public
 */ function getPathInfo(obj, path) {
    var parsed = parsePath(path);
    var last = parsed[parsed.length - 1];
    var info = {
        parent: parsed.length > 1 ? internalGetPathValue(obj, parsed, parsed.length - 1) : obj,
        name: last.p || last.i,
        value: internalGetPathValue(obj, parsed)
    };
    info.exists = hasProperty(info.parent, info.name);
    return info;
}
/**
 * ### .getPathValue(object, path)
 *
 * This allows the retrieval of values in an
 * object given a string path.
 *
 *     var obj = {
 *         prop1: {
 *             arr: ['a', 'b', 'c']
 *           , str: 'Hello'
 *         }
 *       , prop2: {
 *             arr: [ { nested: 'Universe' } ]
 *           , str: 'Hello again!'
 *         }
 *     }
 *
 * The following would be the results.
 *
 *     getPathValue(obj, 'prop1.str'); // Hello
 *     getPathValue(obj, 'prop1.att[2]'); // b
 *     getPathValue(obj, 'prop2.arr[0].nested'); // Universe
 *
 * @param {Object} object
 * @param {String} path
 * @returns {Object} value or `undefined`
 * @namespace Utils
 * @name getPathValue
 * @api public
 */ function getPathValue(obj, path) {
    var info = getPathInfo(obj, path);
    return info.value;
}
/**
 * ### .setPathValue(object, path, value)
 *
 * Define the value in an object at a given string path.
 *
 * ```js
 * var obj = {
 *     prop1: {
 *         arr: ['a', 'b', 'c']
 *       , str: 'Hello'
 *     }
 *   , prop2: {
 *         arr: [ { nested: 'Universe' } ]
 *       , str: 'Hello again!'
 *     }
 * };
 * ```
 *
 * The following would be acceptable.
 *
 * ```js
 * var properties = require('tea-properties');
 * properties.set(obj, 'prop1.str', 'Hello Universe!');
 * properties.set(obj, 'prop1.arr[2]', 'B');
 * properties.set(obj, 'prop2.arr[0].nested.value', { hello: 'universe' });
 * ```
 *
 * @param {Object} object
 * @param {String} path
 * @param {Mixed} value
 * @api private
 */ function setPathValue(obj, path, val) {
    var parsed = parsePath(path);
    internalSetPathValue(obj, val, parsed);
    return obj;
}
module.exports = {
    hasProperty: hasProperty,
    getPathInfo: getPathInfo,
    getPathValue: getPathValue,
    setPathValue: setPathValue
};
}}),
"[project]/node_modules/type-detect/type-detect.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : ("TURBOPACK unreachable", undefined);
})(this, function() {
    'use strict';
    var promiseExists = typeof Promise === 'function';
    var globalObject = function(Obj) {
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        Object.defineProperty(Obj, 'typeDetectGlobalObject', {
            get: function get() {
                return this;
            },
            configurable: true
        });
        var global = typeDetectGlobalObject;
        delete Obj.typeDetectGlobalObject;
        return global;
    }(Object.prototype);
    var symbolExists = typeof Symbol !== 'undefined';
    var mapExists = typeof Map !== 'undefined';
    var setExists = typeof Set !== 'undefined';
    var weakMapExists = typeof WeakMap !== 'undefined';
    var weakSetExists = typeof WeakSet !== 'undefined';
    var dataViewExists = typeof DataView !== 'undefined';
    var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== 'undefined';
    var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== 'undefined';
    var setEntriesExists = setExists && typeof Set.prototype.entries === 'function';
    var mapEntriesExists = mapExists && typeof Map.prototype.entries === 'function';
    var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
    var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
    var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === 'function';
    var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
    var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === 'function';
    var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(''[Symbol.iterator]());
    var toStringLeftSliceLength = 8;
    var toStringRightSliceLength = -1;
    function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== 'object') {
            return typeofObj;
        }
        if (obj === null) {
            return 'null';
        }
        if (obj === globalObject) {
            return 'global';
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
            return 'Array';
        }
        if (typeof window === 'object' && window !== null) {
            if (typeof window.location === 'object' && obj === window.location) {
                return 'Location';
            }
            if (typeof window.document === 'object' && obj === window.document) {
                return 'Document';
            }
            if (typeof window.navigator === 'object') {
                if (typeof window.navigator.mimeTypes === 'object' && obj === window.navigator.mimeTypes) {
                    return 'MimeTypeArray';
                }
                if (typeof window.navigator.plugins === 'object' && obj === window.navigator.plugins) {
                    return 'PluginArray';
                }
            }
            if ((typeof window.HTMLElement === 'function' || typeof window.HTMLElement === 'object') && obj instanceof window.HTMLElement) {
                if (obj.tagName === 'BLOCKQUOTE') {
                    return 'HTMLQuoteElement';
                }
                if (obj.tagName === 'TD') {
                    return 'HTMLTableDataCellElement';
                }
                if (obj.tagName === 'TH') {
                    return 'HTMLTableHeaderCellElement';
                }
            }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === 'string') {
            return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
            return 'RegExp';
        }
        if (objPrototype === Date.prototype) {
            return 'Date';
        }
        if (promiseExists && objPrototype === Promise.prototype) {
            return 'Promise';
        }
        if (setExists && objPrototype === Set.prototype) {
            return 'Set';
        }
        if (mapExists && objPrototype === Map.prototype) {
            return 'Map';
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
            return 'WeakSet';
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
            return 'WeakMap';
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
            return 'DataView';
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
            return 'Map Iterator';
        }
        if (setExists && objPrototype === setIteratorPrototype) {
            return 'Set Iterator';
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
            return 'Array Iterator';
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
            return 'String Iterator';
        }
        if (objPrototype === null) {
            return 'Object';
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
    }
    return typeDetect;
});
}}),
"[project]/node_modules/get-func-name/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* !
 * Chai - getFuncName utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ /**
 * ### .getFuncName(constructorFn)
 *
 * Returns the name of a function.
 * When a non-function instance is passed, returns `null`.
 * This also includes a polyfill function if `aFunc.name` is not defined.
 *
 * @name getFuncName
 * @param {Function} funct
 * @namespace Utils
 * @api public
 */ var toString = Function.prototype.toString;
var functionNameMatch = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/;
var maxFunctionSourceLength = 512;
function getFuncName(aFunc) {
    if (typeof aFunc !== 'function') {
        return null;
    }
    var name = '';
    if (typeof Function.prototype.name === 'undefined' && typeof aFunc.name === 'undefined') {
        // eslint-disable-next-line prefer-reflect
        var functionSource = toString.call(aFunc);
        // To avoid unconstrained resource consumption due to pathalogically large function names,
        // we limit the available return value to be less than 512 characters.
        if (functionSource.indexOf('(') > maxFunctionSourceLength) {
            return name;
        }
        // Here we run a polyfill if Function does not support the `name` property and if aFunc.name is not defined
        var match = functionSource.match(functionNameMatch);
        if (match) {
            name = match[1];
        }
    } else {
        // If we've got a `name` property we just use it
        name = aFunc.name;
    }
    return name;
}
module.exports = getFuncName;
}}),
"[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "inspectList": (()=>inspectList),
    "inspectProperty": (()=>inspectProperty),
    "normaliseOptions": (()=>normaliseOptions),
    "truncate": (()=>truncate),
    "truncator": (()=>truncator)
});
const ansiColors = {
    bold: [
        '1',
        '22'
    ],
    dim: [
        '2',
        '22'
    ],
    italic: [
        '3',
        '23'
    ],
    underline: [
        '4',
        '24'
    ],
    // 5 & 6 are blinking
    inverse: [
        '7',
        '27'
    ],
    hidden: [
        '8',
        '28'
    ],
    strike: [
        '9',
        '29'
    ],
    // 10-20 are fonts
    // 21-29 are resets for 1-9
    black: [
        '30',
        '39'
    ],
    red: [
        '31',
        '39'
    ],
    green: [
        '32',
        '39'
    ],
    yellow: [
        '33',
        '39'
    ],
    blue: [
        '34',
        '39'
    ],
    magenta: [
        '35',
        '39'
    ],
    cyan: [
        '36',
        '39'
    ],
    white: [
        '37',
        '39'
    ],
    brightblack: [
        '30;1',
        '39'
    ],
    brightred: [
        '31;1',
        '39'
    ],
    brightgreen: [
        '32;1',
        '39'
    ],
    brightyellow: [
        '33;1',
        '39'
    ],
    brightblue: [
        '34;1',
        '39'
    ],
    brightmagenta: [
        '35;1',
        '39'
    ],
    brightcyan: [
        '36;1',
        '39'
    ],
    brightwhite: [
        '37;1',
        '39'
    ],
    grey: [
        '90',
        '39'
    ]
};
const styles = {
    special: 'cyan',
    number: 'yellow',
    bigint: 'yellow',
    boolean: 'yellow',
    undefined: 'grey',
    null: 'bold',
    string: 'green',
    symbol: 'green',
    date: 'magenta',
    regexp: 'red'
};
const truncator = '';
function colorise(value, styleType) {
    const color = ansiColors[styles[styleType]] || ansiColors[styleType];
    if (!color) {
        return String(value);
    }
    return `\u001b[${color[0]}m${String(value)}\u001b[${color[1]}m`;
}
function normaliseOptions({ showHidden = false, depth = 2, colors = false, customInspect = true, showProxy = false, maxArrayLength = Infinity, breakLength = Infinity, seen = [], // eslint-disable-next-line no-shadow
truncate = Infinity, stylize = String } = {}) {
    const options = {
        showHidden: Boolean(showHidden),
        depth: Number(depth),
        colors: Boolean(colors),
        customInspect: Boolean(customInspect),
        showProxy: Boolean(showProxy),
        maxArrayLength: Number(maxArrayLength),
        breakLength: Number(breakLength),
        truncate: Number(truncate),
        seen,
        stylize
    };
    if (options.colors) {
        options.stylize = colorise;
    }
    return options;
}
function truncate(string, length, tail = truncator) {
    string = String(string);
    const tailLength = tail.length;
    const stringLength = string.length;
    if (tailLength > length && stringLength > tailLength) {
        return tail;
    }
    if (stringLength > length && stringLength > tailLength) {
        return `${string.slice(0, length - tailLength)}${tail}`;
    }
    return string;
}
function inspectList(list, options, inspectItem, separator = ', ') {
    inspectItem = inspectItem || options.inspect;
    const size = list.length;
    if (size === 0) return '';
    const originalLength = options.truncate;
    let output = '';
    let peek = '';
    let truncated = '';
    for(let i = 0; i < size; i += 1){
        const last = i + 1 === list.length;
        const secondToLast = i + 2 === list.length;
        truncated = `${truncator}(${list.length - i})`;
        const value = list[i];
        // If there is more than one remaining we need to account for a separator of `, `
        options.truncate = originalLength - output.length - (last ? 0 : separator.length);
        const string = peek || inspectItem(value, options) + (last ? '' : separator);
        const nextLength = output.length + string.length;
        const truncatedLength = nextLength + truncated.length;
        // If this is the last element, and adding it would
        // take us over length, but adding the truncator wouldn't - then break now
        if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
            break;
        }
        // If this isn't the last or second to last element to scan,
        // but the string is already over length then break here
        if (!last && !secondToLast && truncatedLength > originalLength) {
            break;
        }
        // Peek at the next string to determine if we should
        // break early before adding this item to the output
        peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator);
        // If we have one element left, but this element and
        // the next takes over length, the break early
        if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
            break;
        }
        output += string;
        // If the next element takes us to length -
        // but there are more after that, then we should truncate now
        if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
            truncated = `${truncator}(${list.length - i - 1})`;
            break;
        }
        truncated = '';
    }
    return `${output}${truncated}`;
}
function quoteComplexKey(key) {
    if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
        return key;
    }
    return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}
function inspectProperty([key, value], options) {
    options.truncate -= 2;
    if (typeof key === 'string') {
        key = quoteComplexKey(key);
    } else if (typeof key !== 'number') {
        key = `[${options.inspect(key, options)}]`;
    }
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key}: ${value}`;
}
}}),
"[project]/node_modules/loupe/lib/array.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectArray(array, options) {
    // Object.keys will always output the Array indices first, so we can slice by
    // `array.length` to get non-index properties
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return '[]';
    options.truncate -= 4;
    const listContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(array, options);
    options.truncate -= listContents.length;
    let propertyContents = '';
    if (nonIndexProperties.length) {
        propertyContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(nonIndexProperties.map((key)=>[
                key,
                array[key]
            ]), options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectProperty"]);
    }
    return `[ ${listContents}${propertyContents ? `, ${propertyContents}` : ''} ]`;
}
}}),
"[project]/node_modules/loupe/lib/typedarray.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectTypedArray)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-func-name/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
;
const getArrayName = (array)=>{
    // We need to special case Node.js' Buffers, which report to be Uint8Array
    if (typeof Buffer === 'function' && array instanceof Buffer) {
        return 'Buffer';
    }
    if (array[Symbol.toStringTag]) {
        return array[Symbol.toStringTag];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(array.constructor);
};
function inspectTypedArray(array, options) {
    const name = getArrayName(array);
    options.truncate -= name.length + 4;
    // Object.keys will always output the Array indices first, so we can slice by
    // `array.length` to get non-index properties
    const nonIndexProperties = Object.keys(array).slice(array.length);
    if (!array.length && !nonIndexProperties.length) return `${name}[]`;
    // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply
    // stylise the toString() value of them
    let output = '';
    for(let i = 0; i < array.length; i++){
        const string = `${options.stylize((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(array[i], options.truncate), 'number')}${i === array.length - 1 ? '' : ', '}`;
        options.truncate -= string.length;
        if (array[i] !== array.length && options.truncate <= 3) {
            output += `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncator"]}(${array.length - array[i] + 1})`;
            break;
        }
        output += string;
    }
    let propertyContents = '';
    if (nonIndexProperties.length) {
        propertyContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(nonIndexProperties.map((key)=>[
                key,
                array[key]
            ]), options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectProperty"]);
    }
    return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`;
}
}}),
"[project]/node_modules/loupe/lib/date.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectDate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectDate(dateObject, options) {
    const stringRepresentation = dateObject.toJSON();
    if (stringRepresentation === null) {
        return 'Invalid Date';
    }
    const split = stringRepresentation.split('T');
    const date = split[0];
    // If we need to - truncate the time portion, but never the date
    return options.stylize(`${date}T${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(split[1], options.truncate - date.length - 1)}`, 'date');
}
}}),
"[project]/node_modules/loupe/lib/function.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-func-name/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
;
function inspectFunction(func, options) {
    const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(func);
    if (!name) {
        return options.stylize('[Function]', 'special');
    }
    return options.stylize(`[Function ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(name, options.truncate - 11)}]`, 'special');
}
}}),
"[project]/node_modules/loupe/lib/map.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectMap)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectMapEntry([key, value], options) {
    options.truncate -= 4;
    key = options.inspect(key, options);
    options.truncate -= key.length;
    value = options.inspect(value, options);
    return `${key} => ${value}`;
}
// IE11 doesn't support `map.entries()`
function mapToEntries(map) {
    const entries = [];
    map.forEach((value, key)=>{
        entries.push([
            key,
            value
        ]);
    });
    return entries;
}
function inspectMap(map, options) {
    const size = map.size - 1;
    if (size <= 0) {
        return 'Map{}';
    }
    options.truncate -= 7;
    return `Map{ ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(mapToEntries(map), options, inspectMapEntry)} }`;
}
}}),
"[project]/node_modules/loupe/lib/number.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
const isNaN = Number.isNaN || ((i)=>i !== i) // eslint-disable-line no-self-compare
;
function inspectNumber(number, options) {
    if (isNaN(number)) {
        return options.stylize('NaN', 'number');
    }
    if (number === Infinity) {
        return options.stylize('Infinity', 'number');
    }
    if (number === -Infinity) {
        return options.stylize('-Infinity', 'number');
    }
    if (number === 0) {
        return options.stylize(1 / number === Infinity ? '+0' : '-0', 'number');
    }
    return options.stylize((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(number, options.truncate), 'number');
}
}}),
"[project]/node_modules/loupe/lib/bigint.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectBigInt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectBigInt(number, options) {
    let nums = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(number.toString(), options.truncate - 1);
    if (nums !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncator"]) nums += 'n';
    return options.stylize(nums, 'bigint');
}
}}),
"[project]/node_modules/loupe/lib/regexp.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectRegExp)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectRegExp(value, options) {
    const flags = value.toString().split('/')[2];
    const sourceLength = options.truncate - (2 + flags.length);
    const source = value.source;
    return options.stylize(`/${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(source, sourceLength)}/${flags}`, 'regexp');
}
}}),
"[project]/node_modules/loupe/lib/set.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectSet)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
// IE11 doesn't support `Array.from(set)`
function arrayFromSet(set) {
    const values = [];
    set.forEach((value)=>{
        values.push(value);
    });
    return values;
}
function inspectSet(set, options) {
    if (set.size === 0) return 'Set{}';
    options.truncate -= 7;
    return `Set{ ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(arrayFromSet(set), options)} }`;
}
}}),
"[project]/node_modules/loupe/lib/string.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectString)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
const stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5" + '\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]', 'g');
const escapeCharacters = {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    "'": "\\'",
    '\\': '\\\\'
};
const hex = 16;
const unicodeLength = 4;
function escape(char) {
    return escapeCharacters[char] || `\\u${`0000${char.charCodeAt(0).toString(hex)}`.slice(-unicodeLength)}`;
}
function inspectString(string, options) {
    if (stringEscapeChars.test(string)) {
        string = string.replace(stringEscapeChars, escape);
    }
    return options.stylize(`'${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(string, options.truncate - 2)}'`, 'string');
}
}}),
"[project]/node_modules/loupe/lib/symbol.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectSymbol)
});
function inspectSymbol(value) {
    if ('description' in Symbol.prototype) {
        return value.description ? `Symbol(${value.description})` : 'Symbol()';
    }
    return value.toString();
}
}}),
"[project]/node_modules/loupe/lib/promise.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
let getPromiseValue = ()=>'Promise{}';
try {
    const { getPromiseDetails, kPending, kRejected } = process.binding('util');
    if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
        getPromiseValue = (value, options)=>{
            const [state, innerValue] = getPromiseDetails(value);
            if (state === kPending) {
                return 'Promise{<pending>}';
            }
            return `Promise${state === kRejected ? '!' : ''}{${options.inspect(innerValue, options)}}`;
        };
    }
} catch (notNode) {
/* ignore */ }
const __TURBOPACK__default__export__ = getPromiseValue;
}}),
"[project]/node_modules/loupe/lib/object.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectObject)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectObject(object, options) {
    const properties = Object.getOwnPropertyNames(object);
    const symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];
    if (properties.length === 0 && symbols.length === 0) {
        return '{}';
    }
    options.truncate -= 4;
    options.seen = options.seen || [];
    if (options.seen.indexOf(object) >= 0) {
        return '[Circular]';
    }
    options.seen.push(object);
    const propertyContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(properties.map((key)=>[
            key,
            object[key]
        ]), options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectProperty"]);
    const symbolContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(symbols.map((key)=>[
            key,
            object[key]
        ]), options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectProperty"]);
    options.seen.pop();
    let sep = '';
    if (propertyContents && symbolContents) {
        sep = ', ';
    }
    return `{ ${propertyContents}${sep}${symbolContents} }`;
}
}}),
"[project]/node_modules/loupe/lib/class.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectClass)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/get-func-name/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/object.js [app-ssr] (ecmascript)");
;
;
const toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag ? Symbol.toStringTag : false;
function inspectClass(value, options) {
    let name = '';
    if (toStringTag && toStringTag in value) {
        name = value[toStringTag];
    }
    name = name || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$get$2d$func$2d$name$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value.constructor);
    // Babel transforms anonymous classes to the name `_class`
    if (!name || name === '_class') {
        name = '<Anonymous Class>';
    }
    options.truncate -= name.length;
    return `${name}${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options)}`;
}
}}),
"[project]/node_modules/loupe/lib/arguments.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectArguments)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectArguments(args, options) {
    if (args.length === 0) return 'Arguments[]';
    options.truncate -= 13;
    return `Arguments[ ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(args, options)} ]`;
}
}}),
"[project]/node_modules/loupe/lib/error.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectObject)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
const errorKeys = [
    'stack',
    'line',
    'column',
    'name',
    'message',
    'fileName',
    'lineNumber',
    'columnNumber',
    'number',
    'description'
];
function inspectObject(error, options) {
    const properties = Object.getOwnPropertyNames(error).filter((key)=>errorKeys.indexOf(key) === -1);
    const name = error.name;
    options.truncate -= name.length;
    let message = '';
    if (typeof error.message === 'string') {
        message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncate"])(error.message, options.truncate);
    } else {
        properties.unshift('message');
    }
    message = message ? `: ${message}` : '';
    options.truncate -= message.length + 5;
    const propertyContents = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(properties.map((key)=>[
            key,
            error[key]
        ]), options, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectProperty"]);
    return `${name}${message}${propertyContents ? ` { ${propertyContents} }` : ''}`;
}
}}),
"[project]/node_modules/loupe/lib/html.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>inspectHTML),
    "inspectAttribute": (()=>inspectAttribute),
    "inspectHTMLCollection": (()=>inspectHTMLCollection)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
function inspectAttribute([key, value], options) {
    options.truncate -= 3;
    if (!value) {
        return `${options.stylize(key, 'yellow')}`;
    }
    return `${options.stylize(key, 'yellow')}=${options.stylize(`"${value}"`, 'string')}`;
}
function inspectHTMLCollection(collection, options) {
    // eslint-disable-next-line no-use-before-define
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(collection, options, inspectHTML, '\n');
}
function inspectHTML(element, options) {
    const properties = element.getAttributeNames();
    const name = element.tagName.toLowerCase();
    const head = options.stylize(`<${name}`, 'special');
    const headClose = options.stylize(`>`, 'special');
    const tail = options.stylize(`</${name}>`, 'special');
    options.truncate -= name.length * 2 + 5;
    let propertyContents = '';
    if (properties.length > 0) {
        propertyContents += ' ';
        propertyContents += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectList"])(properties.map((key)=>[
                key,
                element.getAttribute(key)
            ]), options, inspectAttribute, ' ');
    }
    options.truncate -= propertyContents.length;
    const truncate = options.truncate;
    let children = inspectHTMLCollection(element.children, options);
    if (children && children.length > truncate) {
        children = `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["truncator"]}(${element.children.length})`;
    }
    return `${head}${propertyContents}${headClose}${children}${tail}`;
}
}}),
"[project]/node_modules/loupe/index.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* !
 * loupe
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ __turbopack_context__.s({
    "custom": (()=>custom),
    "default": (()=>__TURBOPACK__default__export__),
    "inspect": (()=>inspect),
    "registerConstructor": (()=>registerConstructor),
    "registerStringTag": (()=>registerStringTag)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/array.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/typedarray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$date$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/date.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/function.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/map.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/bigint.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$regexp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/regexp.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$set$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/set.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/symbol.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$promise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/promise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$class$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/class.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/object.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$arguments$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/arguments.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/error.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$html$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/html.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/loupe/lib/helpers.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const symbolsSupported = typeof Symbol === 'function' && typeof Symbol.for === 'function';
const chaiInspect = symbolsSupported ? Symbol.for('chai/inspect') : '@@chai/inspect';
let nodeInspect = false;
try {
    // eslint-disable-next-line global-require
    const nodeUtil = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
    nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
} catch (noNodeInspect) {
    nodeInspect = false;
}
function FakeMap() {
    // eslint-disable-next-line prefer-template
    this.key = 'chai/loupe__' + Math.random() + Date.now();
}
FakeMap.prototype = {
    // eslint-disable-next-line object-shorthand
    get: function get(key) {
        return key[this.key];
    },
    // eslint-disable-next-line object-shorthand
    has: function has(key) {
        return this.key in key;
    },
    // eslint-disable-next-line object-shorthand
    set: function set(key, value) {
        if (Object.isExtensible(key)) {
            Object.defineProperty(key, this.key, {
                // eslint-disable-next-line object-shorthand
                value: value,
                configurable: true
            });
        }
    }
};
const constructorMap = new (typeof WeakMap === 'function' ? WeakMap : FakeMap)();
const stringTagMap = {};
const baseTypesMap = {
    undefined: (value, options)=>options.stylize('undefined', 'undefined'),
    null: (value, options)=>options.stylize(null, 'null'),
    boolean: (value, options)=>options.stylize(value, 'boolean'),
    Boolean: (value, options)=>options.stylize(value, 'boolean'),
    number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    bigint: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    BigInt: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$bigint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    string: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    String: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Function: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    symbol: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
    Symbol: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$symbol$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$array$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Date: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$date$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Map: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Set: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$set$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    RegExp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$regexp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Promise: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$promise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    // WeakSet, WeakMap are totally opaque to us
    WeakSet: (value, options)=>options.stylize('WeakSet{}', 'special'),
    WeakMap: (value, options)=>options.stylize('WeakMap{}', 'special'),
    Arguments: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$arguments$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Int8Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Uint8Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Uint8ClampedArray: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Int16Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Uint16Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Int32Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Uint32Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Float32Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Float64Array: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$typedarray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    Generator: ()=>'',
    DataView: ()=>'',
    ArrayBuffer: ()=>'',
    Error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"],
    HTMLCollection: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$html$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectHTMLCollection"],
    NodeList: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$html$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inspectHTMLCollection"]
};
// eslint-disable-next-line complexity
const inspectCustom = (value, options, type)=>{
    if (chaiInspect in value && typeof value[chaiInspect] === 'function') {
        return value[chaiInspect](options);
    }
    if (nodeInspect && nodeInspect in value && typeof value[nodeInspect] === 'function') {
        return value[nodeInspect](options.depth, options);
    }
    if ('inspect' in value && typeof value.inspect === 'function') {
        return value.inspect(options.depth, options);
    }
    if ('constructor' in value && constructorMap.has(value.constructor)) {
        return constructorMap.get(value.constructor)(value, options);
    }
    if (stringTagMap[type]) {
        return stringTagMap[type](value, options);
    }
    return '';
};
const toString = Object.prototype.toString;
function inspect(value, options) {
    options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["normaliseOptions"])(options);
    options.inspect = inspect;
    const { customInspect } = options;
    let type = value === null ? 'null' : typeof value;
    if (type === 'object') {
        type = toString.call(value).slice(8, -1);
    }
    // If it is a base value that we already support, then use Loupe's inspector
    if (baseTypesMap[type]) {
        return baseTypesMap[type](value, options);
    }
    // If `options.customInspect` is set to true then try to use the custom inspector
    if (customInspect && value) {
        const output = inspectCustom(value, options, type);
        if (output) {
            if (typeof output === 'string') return output;
            return inspect(output, options);
        }
    }
    const proto = value ? Object.getPrototypeOf(value) : false;
    // If it's a plain Object then use Loupe's inspector
    if (proto === Object.prototype || proto === null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options);
    }
    // Specifically account for HTMLElements
    // eslint-disable-next-line no-undef
    if (value && typeof HTMLElement === 'function' && value instanceof HTMLElement) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$html$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options);
    }
    if ('constructor' in value) {
        // If it is a class, inspect it like an object but add the constructor name
        if (value.constructor !== Object) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$class$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options);
        }
        // If it is an object with an anonymous prototype, display it as an object.
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options);
    }
    // last chance to check if it's an object
    if (value === Object(value)) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$loupe$2f$lib$2f$object$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(value, options);
    }
    // We have run out of options! Just stringify the value
    return options.stylize(String(value), type);
}
function registerConstructor(constructor, inspector) {
    if (constructorMap.has(constructor)) {
        return false;
    }
    constructorMap.set(constructor, inspector);
    return true;
}
function registerStringTag(stringTag, inspector) {
    if (stringTag in stringTagMap) {
        return false;
    }
    stringTagMap[stringTag] = inspector;
    return true;
}
const custom = chaiInspect;
const __TURBOPACK__default__export__ = inspect;
}}),
"[project]/node_modules/deep-eql/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* globals Symbol: false, Uint8Array: false, WeakMap: false */ /*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ var type = __turbopack_context__.r("[project]/node_modules/type-detect/type-detect.js [app-ssr] (ecmascript)");
function FakeMap() {
    this._key = 'chai/deep-eql__' + Math.random() + Date.now();
}
FakeMap.prototype = {
    get: function get(key) {
        return key[this._key];
    },
    set: function set(key, value) {
        if (Object.isExtensible(key)) {
            Object.defineProperty(key, this._key, {
                value: value,
                configurable: true
            });
        }
    }
};
var MemoizeMap = typeof WeakMap === 'function' ? WeakMap : FakeMap;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/ function memoizeCompare(leftHandOperand, rightHandOperand, memoizeMap) {
    // Technically, WeakMap keys can *only* be objects, not primitives.
    if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        return null;
    }
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) {
        var result = leftHandMap.get(rightHandOperand);
        if (typeof result === 'boolean') {
            return result;
        }
    }
    return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/ function memoizeSet(leftHandOperand, rightHandOperand, memoizeMap, result) {
    // Technically, WeakMap keys can *only* be objects, not primitives.
    if (!memoizeMap || isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        return;
    }
    var leftHandMap = memoizeMap.get(leftHandOperand);
    if (leftHandMap) {
        leftHandMap.set(rightHandOperand, result);
    } else {
        leftHandMap = new MemoizeMap();
        leftHandMap.set(rightHandOperand, result);
        memoizeMap.set(leftHandOperand, leftHandMap);
    }
}
/*!
 * Primary Export
 */ module.exports = deepEqual;
module.exports.MemoizeMap = MemoizeMap;
/**
 * Assert deeply nested sameValue equality between two objects of any type.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
 */ function deepEqual(leftHandOperand, rightHandOperand, options) {
    // If we have a comparator, we can't assume anything; so bail to its check first.
    if (options && options.comparator) {
        return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
    }
    var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
    if (simpleResult !== null) {
        return simpleResult;
    }
    // Deeper comparisons are pushed through to a larger function
    return extensiveDeepEqual(leftHandOperand, rightHandOperand, options);
}
/**
 * Many comparisons can be canceled out early via simple equality or primitive checks.
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @return {Boolean|null} equal match
 */ function simpleEqual(leftHandOperand, rightHandOperand) {
    // Equal references (except for Numbers) can be returned early
    if (leftHandOperand === rightHandOperand) {
        // Handle +-0 cases
        return leftHandOperand !== 0 || 1 / leftHandOperand === 1 / rightHandOperand;
    }
    // handle NaN cases
    if (leftHandOperand !== leftHandOperand && // eslint-disable-line no-self-compare
    rightHandOperand !== rightHandOperand // eslint-disable-line no-self-compare
    ) {
        return true;
    }
    // Anything that is not an 'object', i.e. symbols, functions, booleans, numbers,
    // strings, and undefined, can be compared by reference.
    if (isPrimitive(leftHandOperand) || isPrimitive(rightHandOperand)) {
        // Easy out b/c it would have passed the first equality check
        return false;
    }
    return null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/ function extensiveDeepEqual(leftHandOperand, rightHandOperand, options) {
    options = options || {};
    options.memoize = options.memoize === false ? false : options.memoize || new MemoizeMap();
    var comparator = options && options.comparator;
    // Check if a memoized result exists.
    var memoizeResultLeft = memoizeCompare(leftHandOperand, rightHandOperand, options.memoize);
    if (memoizeResultLeft !== null) {
        return memoizeResultLeft;
    }
    var memoizeResultRight = memoizeCompare(rightHandOperand, leftHandOperand, options.memoize);
    if (memoizeResultRight !== null) {
        return memoizeResultRight;
    }
    // If a comparator is present, use it.
    if (comparator) {
        var comparatorResult = comparator(leftHandOperand, rightHandOperand);
        // Comparators may return null, in which case we want to go back to default behavior.
        if (comparatorResult === false || comparatorResult === true) {
            memoizeSet(leftHandOperand, rightHandOperand, options.memoize, comparatorResult);
            return comparatorResult;
        }
        // To allow comparators to override *any* behavior, we ran them first. Since it didn't decide
        // what to do, we need to make sure to return the basic tests first before we move on.
        var simpleResult = simpleEqual(leftHandOperand, rightHandOperand);
        if (simpleResult !== null) {
            // Don't memoize this, it takes longer to set/retrieve than to just compare.
            return simpleResult;
        }
    }
    var leftHandType = type(leftHandOperand);
    if (leftHandType !== type(rightHandOperand)) {
        memoizeSet(leftHandOperand, rightHandOperand, options.memoize, false);
        return false;
    }
    // Temporarily set the operands in the memoize object to prevent blowing the stack
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, true);
    var result = extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options);
    memoizeSet(leftHandOperand, rightHandOperand, options.memoize, result);
    return result;
}
function extensiveDeepEqualByType(leftHandOperand, rightHandOperand, leftHandType, options) {
    switch(leftHandType){
        case 'String':
        case 'Number':
        case 'Boolean':
        case 'Date':
            // If these types are their instance types (e.g. `new Number`) then re-deepEqual against their values
            return deepEqual(leftHandOperand.valueOf(), rightHandOperand.valueOf());
        case 'Promise':
        case 'Symbol':
        case 'function':
        case 'WeakMap':
        case 'WeakSet':
            return leftHandOperand === rightHandOperand;
        case 'Error':
            return keysEqual(leftHandOperand, rightHandOperand, [
                'name',
                'message',
                'code'
            ], options);
        case 'Arguments':
        case 'Int8Array':
        case 'Uint8Array':
        case 'Uint8ClampedArray':
        case 'Int16Array':
        case 'Uint16Array':
        case 'Int32Array':
        case 'Uint32Array':
        case 'Float32Array':
        case 'Float64Array':
        case 'Array':
            return iterableEqual(leftHandOperand, rightHandOperand, options);
        case 'RegExp':
            return regexpEqual(leftHandOperand, rightHandOperand);
        case 'Generator':
            return generatorEqual(leftHandOperand, rightHandOperand, options);
        case 'DataView':
            return iterableEqual(new Uint8Array(leftHandOperand.buffer), new Uint8Array(rightHandOperand.buffer), options);
        case 'ArrayBuffer':
            return iterableEqual(new Uint8Array(leftHandOperand), new Uint8Array(rightHandOperand), options);
        case 'Set':
            return entriesEqual(leftHandOperand, rightHandOperand, options);
        case 'Map':
            return entriesEqual(leftHandOperand, rightHandOperand, options);
        case 'Temporal.PlainDate':
        case 'Temporal.PlainTime':
        case 'Temporal.PlainDateTime':
        case 'Temporal.Instant':
        case 'Temporal.ZonedDateTime':
        case 'Temporal.PlainYearMonth':
        case 'Temporal.PlainMonthDay':
            return leftHandOperand.equals(rightHandOperand);
        case 'Temporal.Duration':
            return leftHandOperand.total('nanoseconds') === rightHandOperand.total('nanoseconds');
        case 'Temporal.TimeZone':
        case 'Temporal.Calendar':
            return leftHandOperand.toString() === rightHandOperand.toString();
        default:
            return objectEqual(leftHandOperand, rightHandOperand, options);
    }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */ function regexpEqual(leftHandOperand, rightHandOperand) {
    return leftHandOperand.toString() === rightHandOperand.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */ function entriesEqual(leftHandOperand, rightHandOperand, options) {
    try {
        // IE11 doesn't support Set#entries or Set#@@iterator, so we need manually populate using Set#forEach
        if (leftHandOperand.size !== rightHandOperand.size) {
            return false;
        }
        if (leftHandOperand.size === 0) {
            return true;
        }
    } catch (sizeError) {
        // things that aren't actual Maps or Sets will throw here
        return false;
    }
    var leftHandItems = [];
    var rightHandItems = [];
    leftHandOperand.forEach(function gatherEntries(key, value) {
        leftHandItems.push([
            key,
            value
        ]);
    });
    rightHandOperand.forEach(function gatherEntries(key, value) {
        rightHandItems.push([
            key,
            value
        ]);
    });
    return iterableEqual(leftHandItems.sort(), rightHandItems.sort(), options);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */ function iterableEqual(leftHandOperand, rightHandOperand, options) {
    var length = leftHandOperand.length;
    if (length !== rightHandOperand.length) {
        return false;
    }
    if (length === 0) {
        return true;
    }
    var index = -1;
    while(++index < length){
        if (deepEqual(leftHandOperand[index], rightHandOperand[index], options) === false) {
            return false;
        }
    }
    return true;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */ function generatorEqual(leftHandOperand, rightHandOperand, options) {
    return iterableEqual(getGeneratorEntries(leftHandOperand), getGeneratorEntries(rightHandOperand), options);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */ function hasIteratorFunction(target) {
    return typeof Symbol !== 'undefined' && typeof target === 'object' && typeof Symbol.iterator !== 'undefined' && typeof target[Symbol.iterator] === 'function';
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */ function getIteratorEntries(target) {
    if (hasIteratorFunction(target)) {
        try {
            return getGeneratorEntries(target[Symbol.iterator]());
        } catch (iteratorError) {
            return [];
        }
    }
    return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */ function getGeneratorEntries(generator) {
    var generatorResult = generator.next();
    var accumulator = [
        generatorResult.value
    ];
    while(generatorResult.done === false){
        generatorResult = generator.next();
        accumulator.push(generatorResult.value);
    }
    return accumulator;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */ function getEnumerableKeys(target) {
    var keys = [];
    for(var key in target){
        keys.push(key);
    }
    return keys;
}
function getEnumerableSymbols(target) {
    var keys = [];
    var allKeys = Object.getOwnPropertySymbols(target);
    for(var i = 0; i < allKeys.length; i += 1){
        var key = allKeys[i];
        if (Object.getOwnPropertyDescriptor(target, key).enumerable) {
            keys.push(key);
        }
    }
    return keys;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */ function keysEqual(leftHandOperand, rightHandOperand, keys, options) {
    var length = keys.length;
    if (length === 0) {
        return true;
    }
    for(var i = 0; i < length; i += 1){
        if (deepEqual(leftHandOperand[keys[i]], rightHandOperand[keys[i]], options) === false) {
            return false;
        }
    }
    return true;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */ function objectEqual(leftHandOperand, rightHandOperand, options) {
    var leftHandKeys = getEnumerableKeys(leftHandOperand);
    var rightHandKeys = getEnumerableKeys(rightHandOperand);
    var leftHandSymbols = getEnumerableSymbols(leftHandOperand);
    var rightHandSymbols = getEnumerableSymbols(rightHandOperand);
    leftHandKeys = leftHandKeys.concat(leftHandSymbols);
    rightHandKeys = rightHandKeys.concat(rightHandSymbols);
    if (leftHandKeys.length && leftHandKeys.length === rightHandKeys.length) {
        if (iterableEqual(mapSymbols(leftHandKeys).sort(), mapSymbols(rightHandKeys).sort()) === false) {
            return false;
        }
        return keysEqual(leftHandOperand, rightHandOperand, leftHandKeys, options);
    }
    var leftHandEntries = getIteratorEntries(leftHandOperand);
    var rightHandEntries = getIteratorEntries(rightHandOperand);
    if (leftHandEntries.length && leftHandEntries.length === rightHandEntries.length) {
        leftHandEntries.sort();
        rightHandEntries.sort();
        return iterableEqual(leftHandEntries, rightHandEntries, options);
    }
    if (leftHandKeys.length === 0 && leftHandEntries.length === 0 && rightHandKeys.length === 0 && rightHandEntries.length === 0) {
        return true;
    }
    return false;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */ function isPrimitive(value) {
    return value === null || typeof value !== 'object';
}
function mapSymbols(arr) {
    return arr.map(function mapSymbol(entry) {
        if (typeof entry === 'symbol') {
            return entry.toString();
        }
        return entry;
    });
}
}}),
"[project]/node_modules/check-error/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* !
 * Chai - checkError utility
 * Copyright(c) 2012-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */ var getFunctionName = __turbopack_context__.r("[project]/node_modules/get-func-name/index.js [app-ssr] (ecmascript)");
/**
 * ### .checkError
 *
 * Checks that an error conforms to a given set of criteria and/or retrieves information about it.
 *
 * @api public
 */ /**
 * ### .compatibleInstance(thrown, errorLike)
 *
 * Checks if two instances are compatible (strict equal).
 * Returns false if errorLike is not an instance of Error, because instances
 * can only be compatible if they're both error instances.
 *
 * @name compatibleInstance
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */ function compatibleInstance(thrown, errorLike) {
    return errorLike instanceof Error && thrown === errorLike;
}
/**
 * ### .compatibleConstructor(thrown, errorLike)
 *
 * Checks if two constructors are compatible.
 * This function can receive either an error constructor or
 * an error instance as the `errorLike` argument.
 * Constructors are compatible if they're the same or if one is
 * an instance of another.
 *
 * @name compatibleConstructor
 * @param {Error} thrown error
 * @param {Error|ErrorConstructor} errorLike object to compare against
 * @namespace Utils
 * @api public
 */ function compatibleConstructor(thrown, errorLike) {
    if (errorLike instanceof Error) {
        // If `errorLike` is an instance of any error we compare their constructors
        return thrown.constructor === errorLike.constructor || thrown instanceof errorLike.constructor;
    } else if (errorLike.prototype instanceof Error || errorLike === Error) {
        // If `errorLike` is a constructor that inherits from Error, we compare `thrown` to `errorLike` directly
        return thrown.constructor === errorLike || thrown instanceof errorLike;
    }
    return false;
}
/**
 * ### .compatibleMessage(thrown, errMatcher)
 *
 * Checks if an error's message is compatible with a matcher (String or RegExp).
 * If the message contains the String or passes the RegExp test,
 * it is considered compatible.
 *
 * @name compatibleMessage
 * @param {Error} thrown error
 * @param {String|RegExp} errMatcher to look for into the message
 * @namespace Utils
 * @api public
 */ function compatibleMessage(thrown, errMatcher) {
    var comparisonString = typeof thrown === 'string' ? thrown : thrown.message;
    if (errMatcher instanceof RegExp) {
        return errMatcher.test(comparisonString);
    } else if (typeof errMatcher === 'string') {
        return comparisonString.indexOf(errMatcher) !== -1; // eslint-disable-line no-magic-numbers
    }
    return false;
}
/**
 * ### .getConstructorName(errorLike)
 *
 * Gets the constructor name for an Error instance or constructor itself.
 *
 * @name getConstructorName
 * @param {Error|ErrorConstructor} errorLike
 * @namespace Utils
 * @api public
 */ function getConstructorName(errorLike) {
    var constructorName = errorLike;
    if (errorLike instanceof Error) {
        constructorName = getFunctionName(errorLike.constructor);
    } else if (typeof errorLike === 'function') {
        // If `err` is not an instance of Error it is an error constructor itself or another function.
        // If we've got a common function we get its name, otherwise we may need to create a new instance
        // of the error just in case it's a poorly-constructed error. Please see chaijs/chai/issues/45 to know more.
        constructorName = getFunctionName(errorLike);
        if (constructorName === '') {
            var newConstructorName = getFunctionName(new errorLike()); // eslint-disable-line new-cap
            constructorName = newConstructorName || constructorName;
        }
    }
    return constructorName;
}
/**
 * ### .getMessage(errorLike)
 *
 * Gets the error message from an error.
 * If `err` is a String itself, we return it.
 * If the error has no message, we return an empty string.
 *
 * @name getMessage
 * @param {Error|String} errorLike
 * @namespace Utils
 * @api public
 */ function getMessage(errorLike) {
    var msg = '';
    if (errorLike && errorLike.message) {
        msg = errorLike.message;
    } else if (typeof errorLike === 'string') {
        msg = errorLike;
    }
    return msg;
}
module.exports = {
    compatibleInstance: compatibleInstance,
    compatibleConstructor: compatibleConstructor,
    compatibleMessage: compatibleMessage,
    getMessage: getMessage,
    getConstructorName: getConstructorName
};
}}),
"[project]/node_modules/rlp/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getLength = exports.decode = exports.encode = void 0;
const bn_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bn.js/lib/bn.js [app-ssr] (ecmascript)"));
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/ function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for(let i = 0; i < input.length; i++){
            output.push(encode(input[i]));
        }
        const buf = Buffer.concat(output);
        return Buffer.concat([
            encodeLength(buf.length, 192),
            buf
        ]);
    } else {
        const inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : Buffer.concat([
            encodeLength(inputBuf.length, 128),
            inputBuf
        ]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */ function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([
            len + offset
        ]);
    } else {
        const hexLength = intToHex(len);
        const lLength = hexLength.length / 2;
        const firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */ function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    const inputBuffer = toBuffer(input);
    const firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    } else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    } else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    } else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    } else {
        // a list  over 55 bytes long
        const llength = firstByte - 0xf6;
        const length = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */ function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1)
        };
    } else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        } else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length)
        };
    } else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength)
        };
    } else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while(innerRemainder.length){
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length)
        };
    } else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while(innerRemainder.length){
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength)
        };
    }
}
/** Check if a string is prefixed by 0x */ function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */ function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */ function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */ function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Transform an integer into a Buffer */ function intToBuffer(integer) {
    const hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */ function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            } else {
                return Buffer.from(v);
            }
        } else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            } else {
                return intToBuffer(v);
            }
        } else if (v === null || v === undefined) {
            return Buffer.from([]);
        } else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        } else if (bn_js_1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        } else {
            throw new Error('invalid type');
        }
    }
    return v;
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
};
}}),
"[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const debug = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
module.exports = debug;
}}),
"[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const safeSrc = exports.safeSrc = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        '\\s',
        1
    ],
    [
        '\\d',
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.
createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)');
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
}}),
"[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== 'object') {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;
}}),
"[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};
}}),
"[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const { compareIdentifiers } = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split('.').map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug('build compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
            if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
            }
            // Avoid an invalid semver results
            if (identifier) {
                const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier) {
                    throw new Error(`invalid identifier: ${identifier}`);
                }
            }
        }
        switch(release){
            case 'premajor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'preminor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'prepatch':
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc('patch', identifier, identifierBase);
                this.inc('pre', identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case 'prerelease':
                if (this.prerelease.length === 0) {
                    this.inc('patch', identifier, identifierBase);
                }
                this.inc('pre', identifier, identifierBase);
                break;
            case 'release':
                if (this.prerelease.length === 0) {
                    throw new Error(`version ${this.raw} is not a prerelease`);
                }
                this.prerelease.length = 0;
                break;
            case 'major':
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'minor':
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'patch':
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case 'pre':
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === 'number') {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier already exists');
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
        }
        return this;
    }
}
module.exports = SemVer;
}}),
"[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;
}}),
"[project]/node_modules/semver/functions/valid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;
}}),
"[project]/node_modules/semver/functions/clean.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
};
module.exports = clean;
}}),
"[project]/node_modules/semver/functions/inc.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;
}}),
"[project]/node_modules/semver/functions/diff.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
        return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
            return 'major';
        }
        // If the main part has no difference
        if (lowVersion.compareMain(highVersion) === 0) {
            if (lowVersion.minor && !lowVersion.patch) {
                return 'minor';
            }
            return 'patch';
        }
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? 'pre' : '';
    if (v1.major !== v2.major) {
        return prefix + 'major';
    }
    if (v1.minor !== v2.minor) {
        return prefix + 'minor';
    }
    if (v1.patch !== v2.patch) {
        return prefix + 'patch';
    }
    // high and low are preleases
    return 'prerelease';
};
module.exports = diff;
}}),
"[project]/node_modules/semver/functions/major.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;
}}),
"[project]/node_modules/semver/functions/minor.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;
}}),
"[project]/node_modules/semver/functions/patch.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;
}}),
"[project]/node_modules/semver/functions/prerelease.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;
}}),
"[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;
}}),
"[project]/node_modules/semver/functions/rcompare.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;
}}),
"[project]/node_modules/semver/functions/compare-loose.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;
}}),
"[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;
}}),
"[project]/node_modules/semver/functions/sort.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;
}}),
"[project]/node_modules/semver/functions/rsort.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;
}}),
"[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;
}}),
"[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;
}}),
"[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;
}}),
"[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;
}}),
"[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;
}}),
"[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;
}}),
"[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case '===':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a === b;
        case '!==':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a !== b;
        case '':
        case '=':
        case '==':
            return eq(a, b, loose);
        case '!=':
            return neq(a, b, loose);
        case '>':
            return gt(a, b, loose);
        case '>=':
            return gte(a, b, loose);
        case '<':
            return lt(a, b, loose);
        case '<=':
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;
}}),
"[project]/node_modules/semver/functions/coerce.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === 'number') {
        version = String(version);
    }
    if (typeof version !== 'string') {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    const major = match[2];
    const minor = match[3] || '0';
    const patch = match[4] || '0';
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;
}}),
"[project]/node_modules/semver/internal/lrucache.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) {
            return undefined;
        } else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;
}}),
"[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        // First, split on ||
        this.set = this.raw.split('||')// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = '';
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) {
                    this.formatted += '||';
                }
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) {
                        this.formatted += ' ';
                    }
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug('loose invalid filter', comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug('range list', rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __turbopack_context__.r("[project]/node_modules/semver/internal/lrucache.js [app-ssr] (ecmascript)");
const cache = new LRU();
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const isNullSet = (c)=>c.value === '<0.0.0-0';
const isAny = (c)=>c.value === '';
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === 'x' || id === '*';
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
};
const replaceCaret = (comp, options)=>{
    debug('caret', comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === '0') {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug('no pr');
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug('caret return', ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
            gtlt = '';
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
            if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                ret = '<0.0.0-0';
            } else {
                // nothing is forbidden
                ret = '*';
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = '>=';
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<';
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === '<') {
                pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
};
const replaceGTE0 = (comp, options)=>{
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) {
            from = '';
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
            to = '';
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};
}}),
"[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
            this.operator = '';
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
            if (this.value === '') {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
            if (comp.value === '') {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
}}),
"[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;
}}),
"[project]/node_modules/semver/ranges/to-comparators.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
module.exports = toComparators;
}}),
"[project]/node_modules/semver/ranges/max-satisfying.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;
}}),
"[project]/node_modules/semver/ranges/min-satisfying.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;
}}),
"[project]/node_modules/semver/ranges/min-version.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer('0.0.0');
    if (range.test(minver)) {
        return minver;
    }
    minver = new SemVer('0.0.0-0');
    if (range.test(minver)) {
        return minver;
    }
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case '>':
                    if (compver.prerelease.length === 0) {
                        compver.patch++;
                    } else {
                        compver.prerelease.push(0);
                    }
                    compver.raw = compver.format();
                /* fallthrough */ case '':
                case '>=':
                    if (!setMin || gt(compver, setMin)) {
                        setMin = compver;
                    }
                    break;
                case '<':
                case '<=':
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
        }
    }
    if (minver && range.test(minver)) {
        return minver;
    }
    return null;
};
module.exports = minVersion;
}}),
"[project]/node_modules/semver/ranges/valid.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*';
    } catch (er) {
        return null;
    }
};
module.exports = validRange;
}}),
"[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const { ANY } = Comparator;
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case '>':
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = '>';
            ecomp = '>=';
            break;
        case '<':
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = '<';
            ecomp = '<=';
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
        return false;
    }
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) {
                comparator = new Comparator('>=0.0.0');
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
            }
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
            return false;
        }
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
        }
    }
    return true;
};
module.exports = outside;
}}),
"[project]/node_modules/semver/ranges/gtr.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// Determine if version is greater than all the versions possible in the range.
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
const gtr = (version, range, options)=>outside(version, range, '>', options);
module.exports = gtr;
}}),
"[project]/node_modules/semver/ranges/ltr.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, '<', options);
module.exports = ltr;
}}),
"[project]/node_modules/semver/ranges/intersects.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;
}}),
"[project]/node_modules/semver/ranges/simplify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) {
                first = version;
            }
        } else {
            if (prev) {
                set.push([
                    first,
                    prev
                ]);
            }
            prev = null;
            first = null;
        }
    }
    if (first) {
        set.push([
            first,
            null
        ]);
    }
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) {
            ranges.push(min);
        } else if (!max && min === v[0]) {
            ranges.push('*');
        } else if (!max) {
            ranges.push(`>=${min}`);
        } else if (min === v[0]) {
            ranges.push(`<=${max}`);
        } else {
            ranges.push(`${min} - ${max}`);
        }
    }
    const simplified = ranges.join(' || ');
    const original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};
}}),
"[project]/node_modules/semver/ranges/subset.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const { ANY } = Comparator;
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) {
        return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
                continue OUTER;
            }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
            return false;
        }
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator('>=0.0.0-0')
];
const minimumVersion = [
    new Comparator('>=0.0.0')
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) {
        return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
        } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
        } else {
            sub = minimumVersion;
        }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
            return true;
        } else {
            dom = minimumVersion;
        }
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === '>' || c.operator === '>=') {
            gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
            lt = lowerLT(lt, c, options);
        } else {
            eqSet.add(c.semver);
        }
    }
    if (eqSet.size > 1) {
        return null;
    }
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
            return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
            return null;
        }
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) {
            return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
            return null;
        }
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) {
                return false;
            }
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
    }
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                    needDomGTPre = false;
                }
            }
            if (c.operator === '>' || c.operator === '>=') {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) {
                    return false;
                }
            } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
                return false;
            }
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                    needDomLTPre = false;
                }
            }
            if (c.operator === '<' || c.operator === '<=') {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) {
                    return false;
                }
            } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
                return false;
            }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
        }
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
    }
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
        return false;
    }
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};
module.exports = subset;
}}),
"[project]/node_modules/semver/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// just pre-load all the stuff that index.js lazily exports
const internalRe = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const identifiers = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const valid = __turbopack_context__.r("[project]/node_modules/semver/functions/valid.js [app-ssr] (ecmascript)");
const clean = __turbopack_context__.r("[project]/node_modules/semver/functions/clean.js [app-ssr] (ecmascript)");
const inc = __turbopack_context__.r("[project]/node_modules/semver/functions/inc.js [app-ssr] (ecmascript)");
const diff = __turbopack_context__.r("[project]/node_modules/semver/functions/diff.js [app-ssr] (ecmascript)");
const major = __turbopack_context__.r("[project]/node_modules/semver/functions/major.js [app-ssr] (ecmascript)");
const minor = __turbopack_context__.r("[project]/node_modules/semver/functions/minor.js [app-ssr] (ecmascript)");
const patch = __turbopack_context__.r("[project]/node_modules/semver/functions/patch.js [app-ssr] (ecmascript)");
const prerelease = __turbopack_context__.r("[project]/node_modules/semver/functions/prerelease.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const rcompare = __turbopack_context__.r("[project]/node_modules/semver/functions/rcompare.js [app-ssr] (ecmascript)");
const compareLoose = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-loose.js [app-ssr] (ecmascript)");
const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const sort = __turbopack_context__.r("[project]/node_modules/semver/functions/sort.js [app-ssr] (ecmascript)");
const rsort = __turbopack_context__.r("[project]/node_modules/semver/functions/rsort.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)");
const coerce = __turbopack_context__.r("[project]/node_modules/semver/functions/coerce.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const toComparators = __turbopack_context__.r("[project]/node_modules/semver/ranges/to-comparators.js [app-ssr] (ecmascript)");
const maxSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/max-satisfying.js [app-ssr] (ecmascript)");
const minSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-satisfying.js [app-ssr] (ecmascript)");
const minVersion = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-version.js [app-ssr] (ecmascript)");
const validRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/valid.js [app-ssr] (ecmascript)");
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
const gtr = __turbopack_context__.r("[project]/node_modules/semver/ranges/gtr.js [app-ssr] (ecmascript)");
const ltr = __turbopack_context__.r("[project]/node_modules/semver/ranges/ltr.js [app-ssr] (ecmascript)");
const intersects = __turbopack_context__.r("[project]/node_modules/semver/ranges/intersects.js [app-ssr] (ecmascript)");
const simplifyRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/simplify.js [app-ssr] (ecmascript)");
const subset = __turbopack_context__.r("[project]/node_modules/semver/ranges/subset.js [app-ssr] (ecmascript)");
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};
}}),
"[project]/node_modules/buffer-reverse/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function reverse(src) {
    var buffer = new Buffer(src.length);
    for(var i = 0, j = src.length - 1; i <= j; ++i, --j){
        buffer[i] = src[j];
        buffer[j] = src[i];
    }
    return buffer;
};
}}),
"[project]/node_modules/treeify/treeify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
//     treeify.js
//     Luke Plaster <notatestuser@gmail.com>
//     https://github.com/notatestuser/treeify.js
// do the universal module definition dance
(function(root, factory) {
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = factory();
    } else {
        "TURBOPACK unreachable";
    }
})(this, function() {
    function makePrefix(key, last) {
        var str = last ? '' : '';
        if (key) {
            str += ' ';
        } else {
            str += '';
        }
        return str;
    }
    function filterKeys(obj, hideFunctions) {
        var keys = [];
        for(var branch in obj){
            // always exclude anything in the object's prototype
            if (!obj.hasOwnProperty(branch)) {
                continue;
            }
            // ... and hide any keys mapped to functions if we've been told to
            if (hideFunctions && typeof obj[branch] === "function") {
                continue;
            }
            keys.push(branch);
        }
        return keys;
    }
    function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([
            root,
            last
        ]) && lastStates.length > 0) {
            // based on the "was last element" states of whatever we're nested within,
            // we need to append either blankness or a branch to our line
            lastStates.forEach(function(lastState, idx) {
                if (idx > 0) {
                    line += (lastState[1] ? ' ' : '') + '  ';
                }
                if (!circular && lastState[0] === root) {
                    circular = true;
                }
            });
            // the prefix varies based on whether the key contains something to show and
            // whether we're dealing with the last element in this collection
            line += makePrefix(key, last) + key;
            // append values and the circular reference indicator
            showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);
            circular && (line += ' (circular ref.)');
            callback(line);
        }
        // can we descend into the next item?
        if (!circular && typeof root === 'object') {
            var keys = filterKeys(root, hideFunctions);
            keys.forEach(function(branch) {
                // the last key is always printed with a different prefix, so we'll need to know if we have it
                lastKey = ++index === keys.length;
                // hold your breath for recursive action
                growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
            });
        }
    }
    ;
    // --------------------
    var Treeify = {};
    // Treeify.asLines
    // --------------------
    // Outputs the tree line-by-line, calling the lineCallback when each one is available.
    Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */ var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;
        growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
    };
    // Treeify.asTree
    // --------------------
    // Outputs the entire tree, returning it as a string with line breaks.
    Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = '';
        growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {
            tree += line + '\n';
        });
        return tree;
    };
    // --------------------
    return Treeify;
});
}}),
"[project]/node_modules/merkletreejs/dist/Base.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Base = void 0;
const buffer_1 = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const crypto_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/crypto-js/index.js [app-ssr] (ecmascript)"));
class Base {
    /**
     * print
     * @desc Prints out a visual representation of the merkle tree.
     * @example
     *```js
     *tree.print()
     *```
     */ print() {
        Base.print(this);
    }
    /**
     * bufferIndexOf
     * @desc Returns the first index of which given buffer is found in array.
     * @param {Buffer[]} haystack - Array of buffers.
     * @param {Buffer} needle - Buffer to find.
     * @return {Number} - Index number
     *
     * @example
     * ```js
     *const index = tree.bufferIndexOf(haystack, needle)
     *```
     */ bufferIndexOf(array, element, isSorted = false) {
        if (isSorted) {
            return this.binarySearch(array, element, buffer_1.Buffer.compare);
        }
        const eqChecker = (buffer1, buffer2)=>buffer1.equals(buffer2);
        return this.linearSearch(array, element, eqChecker);
    }
    /**
     * binarySearch
     * @desc Returns the first index of which given item is found in array using binary search.
     * @param {Buffer[]} array - Array of items.
     * @param {Buffer} element - Item to find.
     * @param {Function} compareFunction
     * @return {Number} - Index number
     *
     * @example
     * ```js
     *const index = MerkleTree.binarySearch(array, element, Buffer.compare)
     *```
     */ static binarySearch(array, element, compareFunction) {
        let start = 0;
        let end = array.length - 1;
        // Iterate while start not meets end
        while(start <= end){
            // Find the mid index
            const mid = Math.floor((start + end) / 2);
            // Check if the mid value is greater than, equal to, or less than search element.
            const ordering = compareFunction(array[mid], element);
            // If element is present at mid, start iterating for searching first appearance.
            if (ordering === 0) {
                // Linear reverse iteration until the first matching item index is found.
                for(let i = mid - 1; i >= 0; i--){
                    if (compareFunction(array[i], element) === 0) continue;
                    return i + 1;
                }
                return 0;
            } else if (ordering < 0) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }
    /**
     * binarySearch
     * @desc Returns the first index of which given item is found in array using binary search.
     * @param {Buffer[]} array - Array of items.
     * @param {Buffer} element - Item to find.
     * @param {Function} compareFunction
     * @return {Number} - Index number
     *
     * @example
     * ```js
     *const index = tree.binarySearch(array, element, Buffer.compare)
     *```
     */ binarySearch(array, element, compareFunction) {
        return Base.binarySearch(array, element, compareFunction);
    }
    /**
     * linearSearch
     * @desc Returns the first index of which given item is found in array using linear search.
     * @param {Buffer[]} array - Array of items.
     * @param {Buffer} element - Item to find.
     * @param {Function} eqChecker
     * @return {Number} - Index number
     *
     * @example
     * ```js
     *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)
     *```
     */ static linearSearch(array, element, eqChecker) {
        for(let i = 0; i < array.length; i++){
            if (eqChecker(array[i], element)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * linearSearch
     * @desc Returns the first index of which given item is found in array using linear search.
     * @param {Buffer[]} array - Array of items.
     * @param {Buffer} element - Item to find.
     * @param {Function} eqChecker
     * @return {Number} - Index number
     *
     * @example
     * ```js
     *const index = tree.linearSearch(array, element, (a, b) => a === b)
     *```
     */ linearSearch(array, element, eqChecker) {
        return Base.linearSearch(array, element, eqChecker);
    }
    /**
     * bufferify
     * @desc Returns a buffer type for the given value.
     * @param {String|Number|Object|Buffer|ArrayBuffer} value
     * @return {Buffer}
     *
     * @example
     * ```js
     *const buf = MerkleTree.bufferify('0x1234')
     *```
     */ static bufferify(value) {
        if (!buffer_1.Buffer.isBuffer(value)) {
            // crypto-js support
            if (typeof value === 'object' && value.words) {
                return buffer_1.Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');
            } else if (Base.isHexString(value)) {
                return buffer_1.Buffer.from(value.replace(/^0x/, ''), 'hex');
            } else if (typeof value === 'string') {
                return buffer_1.Buffer.from(value);
            } else if (typeof value === 'bigint') {
                return buffer_1.Buffer.from(value.toString(16), 'hex');
            } else if (value instanceof Uint8Array) {
                return buffer_1.Buffer.from(value.buffer);
            } else if (typeof value === 'number') {
                let s = value.toString();
                if (s.length % 2) {
                    s = `0${s}`;
                }
                return buffer_1.Buffer.from(s, 'hex');
            } else if (ArrayBuffer.isView(value)) {
                return buffer_1.Buffer.from(value.buffer, value.byteOffset, value.byteLength);
            }
        }
        return value;
    }
    bigNumberify(value) {
        return Base.bigNumberify(value);
    }
    static bigNumberify(value) {
        if (typeof value === 'bigint') {
            return value;
        }
        if (typeof value === 'string') {
            if (value.startsWith('0x') && Base.isHexString(value)) {
                return BigInt('0x' + value.replace('0x', '').toString());
            }
            return BigInt(value);
        }
        if (buffer_1.Buffer.isBuffer(value)) {
            return BigInt('0x' + value.toString('hex'));
        }
        if (value instanceof Uint8Array) {
            return BigInt(value);
        }
        if (typeof value === 'number') {
            return BigInt(value);
        }
        throw new Error('cannot bigNumberify');
    }
    /**
     * isHexString
     * @desc Returns true if value is a hex string.
     * @param {String} value
     * @return {Boolean}
     *
     * @example
     * ```js
     *console.log(MerkleTree.isHexString('0x1234'))
     *```
     */ static isHexString(v) {
        return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);
    }
    /**
     * print
     * @desc Prints out a visual representation of the given merkle tree.
     * @param {Object} tree - Merkle tree instance.
     * @return {String}
     * @example
     *```js
     *MerkleTree.print(tree)
     *```
     */ static print(tree) {
        console.log(tree.toString());
    }
    /**
     * bufferToHex
     * @desc Returns a hex string with 0x prefix for given buffer.
     * @param {Buffer} value
     * @return {String}
     * @example
     *```js
     *const hexStr = tree.bufferToHex(Buffer.from('A'))
     *```
     */ bufferToHex(value, withPrefix = true) {
        return Base.bufferToHex(value, withPrefix);
    }
    /**
     * bufferToHex
     * @desc Returns a hex string with 0x prefix for given buffer.
     * @param {Buffer} value
     * @return {String}
     * @example
     *```js
     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))
     *```
     */ static bufferToHex(value, withPrefix = true) {
        return `${withPrefix ? '0x' : ''}${(value || buffer_1.Buffer.alloc(0)).toString('hex')}`;
    }
    /**
     * bufferify
     * @desc Returns a buffer type for the given value.
     * @param {String|Number|Object|Buffer} value
     * @return {Buffer}
     *
     * @example
     * ```js
     *const buf = tree.bufferify('0x1234')
     *```
     */ bufferify(value) {
        return Base.bufferify(value);
    }
    /**
     * bufferifyFn
     * @desc Returns a function that will bufferify the return value.
     * @param {Function}
     * @return {Function}
     *
     * @example
     * ```js
     *const fn = tree.bufferifyFn((value) => sha256(value))
     *```
     */ bufferifyFn(f) {
        return (value)=>{
            const v = f(value);
            if (buffer_1.Buffer.isBuffer(v)) {
                return v;
            }
            if (this.isHexString(v)) {
                return buffer_1.Buffer.from(v.replace('0x', ''), 'hex');
            }
            if (typeof v === 'string') {
                return buffer_1.Buffer.from(v);
            }
            if (typeof v === 'bigint') {
                return buffer_1.Buffer.from(value.toString(16), 'hex');
            }
            if (ArrayBuffer.isView(v)) {
                return buffer_1.Buffer.from(v.buffer, v.byteOffset, v.byteLength);
            }
            // crypto-js support
            return buffer_1.Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');
        };
    }
    /**
     * isHexString
     * @desc Returns true if value is a hex string.
     * @param {String} value
     * @return {Boolean}
     *
     * @example
     * ```js
     *console.log(MerkleTree.isHexString('0x1234'))
     *```
     */ isHexString(value) {
        return Base.isHexString(value);
    }
    /**
     * log2
     * @desc Returns the log2 of number.
     * @param {Number} value
     * @return {Number}
     */ log2(n) {
        return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);
    }
    /**
     * zip
     * @desc Returns true if value is a hex string.
     * @param {String[]|Number[]|Buffer[]} a - first array
     * @param {String[]|Number[]|Buffer[]} b -  second array
     * @return {String[][]|Number[][]|Buffer[][]}
     *
     * @example
     * ```js
     *const zipped = tree.zip(['a', 'b'],['A', 'B'])
     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]
     *```
     */ zip(a, b) {
        return a.map((e, i)=>[
                e,
                b[i]
            ]);
    }
    static hexZeroPad(hexStr, length) {
        return '0x' + hexStr.replace('0x', '').padStart(length, '0');
    }
}
exports.Base = Base;
exports.default = Base;
}}),
"[project]/node_modules/merkletreejs/dist/MerkleTree.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleTree = void 0;
const buffer_1 = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const buffer_reverse_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/buffer-reverse/index.js [app-ssr] (ecmascript)"));
const sha256_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/crypto-js/sha256.js [app-ssr] (ecmascript)"));
const treeify_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/treeify/treeify.js [app-ssr] (ecmascript)"));
const Base_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/merkletreejs/dist/Base.js [app-ssr] (ecmascript)"));
/**
 * Class reprensenting a Merkle Tree
 * @namespace MerkleTree
 */ class MerkleTree extends Base_1.default {
    /**
     * @desc Constructs a Merkle Tree.
     * All nodes and leaves are stored as Buffers.
     * Lonely leaf nodes are promoted to the next level up without being hashed again.
     * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.
     * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes
     * @param {Object} options - Additional options
     * @example
     *```js
     *const MerkleTree = require('merkletreejs')
     *const crypto = require('crypto')
     *
     *function sha256(data) {
     *  // returns Buffer
     *  return crypto.createHash('sha256').update(data).digest()
     *}
     *
     *const leaves = ['a', 'b', 'c'].map(value => keccak(value))
     *
     *const tree = new MerkleTree(leaves, sha256)
     *```
     */ constructor(leaves, hashFn = sha256_1.default, options = {}){
        super();
        this.duplicateOdd = false;
        this.concatenator = buffer_1.Buffer.concat;
        this.hashLeaves = false;
        this.isBitcoinTree = false;
        this.leaves = [];
        this.layers = [];
        this.sortLeaves = false;
        this.sortPairs = false;
        this.sort = false;
        this.fillDefaultHash = null;
        this.complete = false;
        if (options.complete) {
            if (options.isBitcoinTree) {
                throw new Error('option "complete" is incompatible with "isBitcoinTree"');
            }
            if (options.duplicateOdd) {
                throw new Error('option "complete" is incompatible with "duplicateOdd"');
            }
        }
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        this.complete = !!options.complete;
        if (options.fillDefaultHash) {
            if (typeof options.fillDefaultHash === 'function') {
                this.fillDefaultHash = options.fillDefaultHash;
            } else if (buffer_1.Buffer.isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === 'string') {
                this.fillDefaultHash = (idx, hashFn)=>options.fillDefaultHash;
            } else {
                throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
            }
        }
        this.sort = !!options.sort;
        if (this.sort) {
            this.sortLeaves = true;
            this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        if (options.concatenator) {
            this.concatenator = options.concatenator;
        }
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
    }
    getOptions() {
        var _a, _b;
        return {
            complete: this.complete,
            isBitcoinTree: this.isBitcoinTree,
            hashLeaves: this.hashLeaves,
            sortLeaves: this.sortLeaves,
            sortPairs: this.sortPairs,
            sort: this.sort,
            fillDefaultHash: (_b = (_a = this.fillDefaultHash) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : null,
            duplicateOdd: this.duplicateOdd
        };
    }
    processLeaves(leaves) {
        if (this.hashLeaves) {
            leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
            this.leaves = this.leaves.sort(buffer_1.Buffer.compare);
        }
        if (this.fillDefaultHash) {
            for(let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++){
                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
            }
        }
        this.createHashes(this.leaves);
    }
    createHashes(nodes) {
        this.layers = [
            nodes
        ];
        while(nodes.length > 1){
            const layerIndex = this.layers.length;
            this.layers.push([]);
            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - Math.pow(2, Math.ceil(Math.log2(nodes.length))) : nodes.length;
            for(let i = 0; i < nodes.length; i += 2){
                if (i >= layerLimit) {
                    this.layers[layerIndex].push(...nodes.slice(layerLimit));
                    break;
                } else if (i + 1 === nodes.length) {
                    if (nodes.length % 2 === 1) {
                        const data = nodes[nodes.length - 1];
                        let hash = data;
                        // is bitcoin tree
                        if (this.isBitcoinTree) {
                            // Bitcoin method of duplicating the odd ending nodes
                            hash = this.hashFn(this.concatenator([
                                buffer_reverse_1.default(data),
                                buffer_reverse_1.default(data)
                            ]));
                            hash = buffer_reverse_1.default(this.hashFn(hash));
                            this.layers[layerIndex].push(hash);
                            continue;
                        } else {
                            if (this.duplicateOdd) {
                            // continue with creating layer
                            } else {
                                // push copy of hash and continue iteration
                                this.layers[layerIndex].push(nodes[i]);
                                continue;
                            }
                        }
                    }
                }
                const left = nodes[i];
                const right = i + 1 === nodes.length ? left : nodes[i + 1];
                let combined = null;
                if (this.isBitcoinTree) {
                    combined = [
                        buffer_reverse_1.default(left),
                        buffer_reverse_1.default(right)
                    ];
                } else {
                    combined = [
                        left,
                        right
                    ];
                }
                if (this.sortPairs) {
                    combined.sort(buffer_1.Buffer.compare);
                }
                let hash = this.hashFn(this.concatenator(combined));
                // double hash if bitcoin tree
                if (this.isBitcoinTree) {
                    hash = buffer_reverse_1.default(this.hashFn(hash));
                }
                this.layers[layerIndex].push(hash);
            }
            nodes = this.layers[layerIndex];
        }
    }
    /**
     * addLeaf
     * @desc Adds a leaf to the tree and re-calculates layers.
     * @param {String|Buffer} - Leaf
     * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.
     * @example
     *```js
     *tree.addLeaf(newLeaf)
     *```
     */ addLeaf(leaf, shouldHash = false) {
        if (shouldHash) {
            leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
    }
    /**
     * addLeaves
     * @desc Adds multiple leaves to the tree and re-calculates layers.
     * @param {String[]|Buffer[]} - Array of leaves
     * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.
     * @example
     *```js
     *tree.addLeaves(newLeaves)
     *```
     */ addLeaves(leaves, shouldHash = false) {
        if (shouldHash) {
            leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
    }
    /**
     * getLeaves
     * @desc Returns array of leaves of Merkle Tree.
     * @return {Buffer[]}
     * @example
     *```js
     *const leaves = tree.getLeaves()
     *```
     */ getLeaves(values) {
        if (Array.isArray(values)) {
            if (this.hashLeaves) {
                values = values.map(this.hashFn);
                if (this.sortLeaves) {
                    values = values.sort(buffer_1.Buffer.compare);
                }
            }
            return this.leaves.filter((leaf)=>this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);
        }
        return this.leaves;
    }
    /**
     * getLeaf
     * @desc Returns the leaf at the given index.
     * @param {Number} - Index number
     * @return {Buffer}
     * @example
     *```js
     *const leaf = tree.getLeaf(1)
     *```
     */ getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
            return buffer_1.Buffer.from([]);
        }
        return this.leaves[index];
    }
    /**
     * getLeafIndex
     * @desc Returns the index of the given leaf, or -1 if the leaf is not found.
     * @param {String|Buffer} - Target leaf
     * @return {number}
     * @example
     *```js
     *const leaf = Buffer.from('abc')
     *const index = tree.getLeafIndex(leaf)
     *```
     */ getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for(let i = 0; i < leaves.length; i++){
            const leaf = leaves[i];
            if (leaf.equals(target)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * getLeafCount
     * @desc Returns the total number of leaves.
     * @return {number}
     * @example
     *```js
     *const count = tree.getLeafCount()
     *```
     */ getLeafCount() {
        return this.leaves.length;
    }
    /**
     * getHexLeaves
     * @desc Returns array of leaves of Merkle Tree as hex strings.
     * @return {String[]}
     * @example
     *```js
     *const leaves = tree.getHexLeaves()
     *```
     */ getHexLeaves() {
        return this.leaves.map((leaf)=>this.bufferToHex(leaf));
    }
    /**
     * marshalLeaves
     * @desc Returns array of leaves of Merkle Tree as a JSON string.
     * @param {String[]|Buffer[]} - Merkle tree leaves
     * @return {String} - List of leaves as JSON string
     * @example
     *```js
     *const jsonStr = MerkleTree.marshalLeaves(leaves)
     *```
     */ static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf)=>MerkleTree.bufferToHex(leaf)), null, 2);
    }
    /**
     * unmarshalLeaves
     * @desc Returns array of leaves of Merkle Tree as a Buffers.
     * @param {String|Object} - JSON stringified leaves
     * @return {Buffer[]} - Unmarshalled list of leaves
     * @example
     *```js
     *const leaves = MerkleTree.unmarshalLeaves(jsonStr)
     *```
     */ static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === 'string') {
            parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
            parsed = jsonStr;
        } else {
            throw new Error('Expected type of string or object');
        }
        if (!parsed) {
            return [];
        }
        if (!Array.isArray(parsed)) {
            throw new Error('Expected JSON string to be array');
        }
        return parsed.map(MerkleTree.bufferify);
    }
    /**
     * getLayers
     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.
     * @return {Buffer[][]}
     * @example
     *```js
     *const layers = tree.getLayers()
     *```
     */ getLayers() {
        return this.layers;
    }
    /**
     * getHexLayers
     * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.
     * @return {String[][]}
     * @example
     *```js
     *const layers = tree.getHexLayers()
     *```
     */ getHexLayers() {
        return this.layers.reduce((acc, item)=>{
            if (Array.isArray(item)) {
                acc.push(item.map((layer)=>this.bufferToHex(layer)));
            } else {
                acc.push(item);
            }
            return acc;
        }, []);
    }
    /**
     * getLayersFlat
     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.
     * @return {Buffer[]}
     * @example
     *```js
     *const layers = tree.getLayersFlat()
     *```
     */ getLayersFlat() {
        const layers = this.layers.reduce((acc, item)=>{
            if (Array.isArray(item)) {
                acc.unshift(...item);
            } else {
                acc.unshift(item);
            }
            return acc;
        }, []);
        layers.unshift(buffer_1.Buffer.from([
            0
        ]));
        return layers;
    }
    /**
     * getHexLayersFlat
     * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.
     * @return {String[]}
     * @example
     *```js
     *const layers = tree.getHexLayersFlat()
     *```
     */ getHexLayersFlat() {
        return this.getLayersFlat().map((layer)=>this.bufferToHex(layer));
    }
    /**
     * getLayerCount
     * @desc Returns the total number of layers.
     * @return {number}
     * @example
     *```js
     *const count = tree.getLayerCount()
     *```
     */ getLayerCount() {
        return this.getLayers().length;
    }
    /**
     * getRoot
     * @desc Returns the Merkle root hash as a Buffer.
     * @return {Buffer}
     * @example
     *```js
     *const root = tree.getRoot()
     *```
     */ getRoot() {
        if (this.layers.length === 0) {
            return buffer_1.Buffer.from([]);
        }
        return this.layers[this.layers.length - 1][0] || buffer_1.Buffer.from([]);
    }
    /**
     * getHexRoot
     * @desc Returns the Merkle root hash as a hex string.
     * @return {String}
     * @example
     *```js
     *const root = tree.getHexRoot()
     *```
     */ getHexRoot() {
        return this.bufferToHex(this.getRoot());
    }
    /**
     * getProof
     * @desc Returns the proof for a target leaf.
     * @param {Buffer} leaf - Target leaf
     * @param {Number} [index] - Target leaf index in leaves array.
     * Use if there are leaves containing duplicate data in order to distinguish it.
     * @return {Object[]} - Array of objects containing a position property of type string
     * with values of 'left' or 'right' and a data property of type Buffer.
     * @example
     * ```js
     *const proof = tree.getProof(leaves[2])
     *```
     *
     * @example
     *```js
     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
     *const tree = new MerkleTree(leaves, keccak)
     *const proof = tree.getProof(leaves[2], 2)
     *```
     */ getProof(leaf, index) {
        if (typeof leaf === 'undefined') {
            throw new Error('leaf is required');
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
            index = -1;
            for(let i = 0; i < this.leaves.length; i++){
                if (buffer_1.Buffer.compare(leaf, this.leaves[i]) === 0) {
                    index = i;
                }
            }
        }
        if (index <= -1) {
            return [];
        }
        for(let i = 0; i < this.layers.length; i++){
            const layer = this.layers[i];
            const isRightNode = index % 2;
            const pairIndex = isRightNode ? index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? index : index + 1;
            if (pairIndex < layer.length) {
                proof.push({
                    position: isRightNode ? 'left' : 'right',
                    data: layer[pairIndex]
                });
            }
            // set index to parent index
            index = index / 2 | 0;
        }
        return proof;
    }
    /**
     * getHexProof
     * @desc Returns the proof for a target leaf as hex strings.
     * @param {Buffer} leaf - Target leaf
     * @param {Number} [index] - Target leaf index in leaves array.
     * Use if there are leaves containing duplicate data in order to distinguish it.
     * @return {String[]} - Proof array as hex strings.
     * @example
     * ```js
     *const proof = tree.getHexProof(leaves[2])
     *```
     */ getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item)=>this.bufferToHex(item.data));
    }
    /**
     * getProofs
     * @desc Returns the proofs for all leaves.
     * @return {Object[]} - Array of objects containing a position property of type string
     * with values of 'left' or 'right' and a data property of type Buffer for all leaves.
     * @example
     * ```js
     *const proofs = tree.getProofs()
     *```
     *
     * @example
     *```js
     *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
     *const tree = new MerkleTree(leaves, keccak)
     *const proofs = tree.getProofs()
     *```
     */ getProofs() {
        const proof = [];
        const proofs = [];
        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);
        return proofs;
    }
    /**
     * getProofsDFS
     * @desc Get all proofs through single traverse
     * @param {Number} currentLayer - Current layer index in traverse.
     * @param {Number} index - Current tarvese node index in traverse.
     * @param {Object[]} proof - Proof chain for single leaf.
     * @param {Object[]} proofs - Proofs for all leaves
     * @example
     * ```js
     *const layers = tree.getLayers()
     *const index = 0;
     *let proof = [];
     *let proofs = [];
     *const proof = tree.getProofsDFS(layers, index, proof, proofs)
     *```
     */ getProofsDFS(currentLayer, index, proof, proofs) {
        const isRightNode = index % 2;
        if (currentLayer === -1) {
            if (!isRightNode) proofs.push([
                ...proof
            ].reverse());
            return;
        }
        if (index >= this.layers[currentLayer].length) return;
        const layer = this.layers[currentLayer];
        const pairIndex = isRightNode ? index - 1 : index + 1;
        let pushed = false;
        if (pairIndex < layer.length) {
            pushed = true;
            proof.push({
                position: isRightNode ? 'left' : 'right',
                data: layer[pairIndex]
            });
        }
        const leftchildIndex = index * 2;
        const rightchildIndex = index * 2 + 1;
        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);
        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);
        if (pushed) proof.splice(proof.length - 1, 1);
    }
    /**
     * getHexProofs
     * @desc Returns the proofs for all leaves as hex strings.
     * @return {String[]} - Proofs array as hex strings.
     * @example
     * ```js
     *const proofs = tree.getHexProofs()
     *```
     */ getHexProofs() {
        return this.getProofs().map((item)=>this.bufferToHex(item.data));
    }
    /**
    * getPositionalHexProof
    * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).
    * @param {Buffer} leaf - Target leaf
    * @param {Number} [index] - Target leaf index in leaves array.
    * Use if there are leaves containing duplicate data in order to distinguish it.
    * @return {(string | number)[][]} - Proof array as hex strings. position at index 0
    * @example
    * ```js
    *const proof = tree.getPositionalHexProof(leaves[2])
    *```
    */ getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item)=>{
            return [
                item.position === 'left' ? 0 : 1,
                this.bufferToHex(item.data)
            ];
        });
    }
    /**
     * marshalProof
     * @desc Returns proof array as JSON string.
     * @param {String[]|Object[]} proof - Merkle tree proof array
     * @return {String} - Proof array as JSON string.
     * @example
     * ```js
     *const jsonStr = MerkleTree.marshalProof(proof)
     *```
     */ static marshalProof(proof) {
        const json = proof.map((item)=>{
            if (typeof item === 'string') {
                return item;
            }
            if (buffer_1.Buffer.isBuffer(item)) {
                return MerkleTree.bufferToHex(item);
            }
            return {
                position: item.position,
                data: MerkleTree.bufferToHex(item.data)
            };
        });
        return JSON.stringify(json, null, 2);
    }
    /**
     * unmarshalProof
     * @desc Returns the proof for a target leaf as a list of Buffers.
     * @param {String|Object} - Merkle tree leaves
     * @return {String|Object} - Marshalled proof
     * @example
     * ```js
     *const proof = MerkleTree.unmarshalProof(jsonStr)
     *```
     */ static unmarshalProof(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === 'string') {
            parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
            parsed = jsonStr;
        } else {
            throw new Error('Expected type of string or object');
        }
        if (!parsed) {
            return [];
        }
        if (!Array.isArray(parsed)) {
            throw new Error('Expected JSON string to be array');
        }
        return parsed.map((item)=>{
            if (typeof item === 'string') {
                return MerkleTree.bufferify(item);
            } else if (item instanceof Object) {
                return {
                    position: item.position,
                    data: MerkleTree.bufferify(item.data)
                };
            } else {
                throw new Error('Expected item to be of type string or object');
            }
        });
    }
    static marshalTree(tree) {
        const root = tree.getHexRoot();
        const leaves = tree.leaves.map((leaf)=>MerkleTree.bufferToHex(leaf));
        const layers = tree.getHexLayers();
        const options = tree.getOptions();
        return JSON.stringify({
            options,
            root,
            layers,
            leaves
        }, null, 2);
    }
    static unmarshalTree(jsonStr, hashFn = sha256_1.default, options = {}) {
        let parsed = null;
        if (typeof jsonStr === 'string') {
            parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
            parsed = jsonStr;
        } else {
            throw new Error('Expected type of string or object');
        }
        if (!parsed) {
            throw new Error('could not parse json');
        }
        options = Object.assign({}, parsed.options || {}, options);
        return new MerkleTree(parsed.leaves, hashFn, options);
    }
    /**
     * getProofIndices
     * @desc Returns the proof indices for given tree indices.
     * @param {Number[]} treeIndices - Tree indices
     * @param {Number} depth - Tree depth; number of layers.
     * @return {Number[]} - Proof indices
     * @example
     * ```js
     *const proofIndices = tree.getProofIndices([2,5,6], 4)
     *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]
     *```
     */ getProofIndices(treeIndices, depth) {
        const leafCount = Math.pow(2, depth);
        let maximalIndices = new Set();
        for (const index of treeIndices){
            let x = leafCount + index;
            while(x > 1){
                maximalIndices.add(x ^ 1);
                x = x / 2 | 0;
            }
        }
        const a = treeIndices.map((index)=>leafCount + index);
        const b = Array.from(maximalIndices).sort((a, b)=>a - b).reverse();
        maximalIndices = a.concat(b);
        const redundantIndices = new Set();
        const proof = [];
        for (let index of maximalIndices){
            if (!redundantIndices.has(index)) {
                proof.push(index);
                while(index > 1){
                    redundantIndices.add(index);
                    if (!redundantIndices.has(index ^ 1)) break;
                    index = index / 2 | 0;
                }
            }
        }
        return proof.filter((index)=>{
            return !treeIndices.includes(index - leafCount);
        });
    }
    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for(let index = 0; index < depth; index++){
            const unevenLayer = leavesCount % 2 !== 0;
            if (unevenLayer) {
                unevenLayers.push({
                    index,
                    leavesCount
                });
            }
            leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for(let layerIndex = 0; layerIndex < depth; layerIndex++){
            const siblingIndices = layerNodes.map((index)=>{
                if (index % 2 === 0) {
                    return index + 1;
                }
                return index - 1;
            });
            let proofNodeIndices = siblingIndices.filter((index)=>!layerNodes.includes(index));
            const unevenLayer = unevenLayers.find(({ index })=>index === layerIndex);
            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
                proofNodeIndices = proofNodeIndices.slice(0, -1);
            }
            proofIndices.push(proofNodeIndices);
            layerNodes = [
                ...new Set(layerNodes.map((index)=>{
                    if (index % 2 === 0) {
                        return index / 2;
                    }
                    if (index % 2 === 0) {
                        return (index + 1) / 2;
                    }
                    return (index - 1) / 2;
                }))
            ];
        }
        return proofIndices;
    }
    /**
     * getMultiProof
     * @desc Returns the multiproof for given tree indices.
     * @param {Number[]} indices - Tree indices.
     * @return {Buffer[]} - Multiproofs
     * @example
     * ```js
     *const indices = [2, 5, 6]
     *const proof = tree.getMultiProof(indices)
     *```
     */ getMultiProof(tree, indices) {
        if (!this.complete) {
            console.warn('Warning: For correct multiProofs it\'s strongly recommended to set complete: true');
        }
        if (!indices) {
            indices = tree;
            tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
            if (indices.every(Number.isInteger)) {
                return this.getMultiProofForUnevenTree(indices);
            }
        }
        if (!indices.every(Number.isInteger)) {
            let els = indices;
            if (this.sortPairs) {
                els = els.sort(buffer_1.Buffer.compare);
            }
            let ids = els.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);
            if (!ids.every((idx)=>idx !== -1)) {
                throw new Error('Element does not exist in Merkle tree');
            }
            const hashes = [];
            const proof = [];
            let nextIds = [];
            for(let i = 0; i < this.layers.length; i++){
                const layer = this.layers[i];
                for(let j = 0; j < ids.length; j++){
                    const idx = ids[j];
                    const pairElement = this.getPairNode(layer, idx);
                    hashes.push(layer[idx]);
                    if (pairElement) {
                        proof.push(pairElement);
                    }
                    nextIds.push(idx / 2 | 0);
                }
                ids = nextIds.filter((value, i, self)=>self.indexOf(value) === i);
                nextIds = [];
            }
            return proof.filter((value)=>!hashes.includes(value));
        }
        return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map((index)=>tree[index]);
    }
    getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
            indices = tree;
            tree = this.getLayers();
        }
        let proofHashes = [];
        let currentLayerIndices = indices;
        for (const treeLayer of tree){
            const siblings = [];
            for (const index of currentLayerIndices){
                if (index % 2 === 0) {
                    const idx = index + 1;
                    if (!currentLayerIndices.includes(idx)) {
                        if (treeLayer[idx]) {
                            siblings.push(treeLayer[idx]);
                            continue;
                        }
                    }
                }
                const idx = index - 1;
                if (!currentLayerIndices.includes(idx)) {
                    if (treeLayer[idx]) {
                        siblings.push(treeLayer[idx]);
                        continue;
                    }
                }
            }
            proofHashes = proofHashes.concat(siblings);
            const uniqueIndices = new Set();
            for (const index of currentLayerIndices){
                if (index % 2 === 0) {
                    uniqueIndices.add(index / 2);
                    continue;
                }
                if (index % 2 === 0) {
                    uniqueIndices.add((index + 1) / 2);
                    continue;
                }
                uniqueIndices.add((index - 1) / 2);
            }
            currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
    }
    /**
     * getHexMultiProof
     * @desc Returns the multiproof for given tree indices as hex strings.
     * @param {Number[]} indices - Tree indices.
     * @return {String[]} - Multiproofs as hex strings.
     * @example
     * ```js
     *const indices = [2, 5, 6]
     *const proof = tree.getHexMultiProof(indices)
     *```
     */ getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x)=>this.bufferToHex(x));
    }
    /**
     * getProofFlags
     * @desc Returns list of booleans where proofs should be used instead of hashing.
     * Proof flags are used in the Solidity multiproof verifiers.
     * @param {Number[]|Buffer[]} leaves
     * @param {Buffer[]} proofs
     * @return {Boolean[]} - Boolean flags
     * @example
     * ```js
     *const indices = [2, 5, 6]
     *const proof = tree.getMultiProof(indices)
     *const proofFlags = tree.getProofFlags(leaves, proof)
     *```
     */ getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
            throw new Error('Invalid Inputs!');
        }
        let ids;
        if (leaves.every(Number.isInteger)) {
            ids = [
                ...leaves
            ].sort((a, b)=>a === b ? 0 : a > b ? 1 : -1); // Indices where passed
        } else {
            ids = leaves.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);
        }
        if (!ids.every((idx)=>idx !== -1)) {
            throw new Error('Element does not exist in Merkle tree');
        }
        const _proofs = proofs.map((item)=>this.bufferify(item));
        const tested = [];
        const flags = [];
        for(let index = 0; index < this.layers.length; index++){
            const layer = this.layers[index];
            ids = ids.reduce((ids, idx)=>{
                const skipped = tested.includes(layer[idx]);
                if (!skipped) {
                    const pairElement = this.getPairNode(layer, idx);
                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
                    pairElement && flags.push(!proofUsed);
                    tested.push(layer[idx]);
                    tested.push(pairElement);
                }
                ids.push(idx / 2 | 0);
                return ids;
            }, []);
        }
        return flags;
    }
    /**
     * verify
     * @desc Returns true if the proof path (array of hashes) can connect the target node
     * to the Merkle root.
     * @param {Object[]} proof - Array of proof objects that should connect
     * target node to Merkle root.
     * @param {Buffer} targetNode - Target node Buffer
     * @param {Buffer} root - Merkle root Buffer
     * @return {Boolean}
     * @example
     *```js
     *const root = tree.getRoot()
     *const proof = tree.getProof(leaves[2])
     *const verified = tree.verify(proof, leaves[2], root)
     *```
     */ verify(proof, targetNode, root) {
        let hash = this.bufferify(targetNode);
        root = this.bufferify(root);
        if (!Array.isArray(proof) || !targetNode || !root) {
            return false;
        }
        for(let i = 0; i < proof.length; i++){
            const node = proof[i];
            let data = null;
            let isLeftNode = null;
            // case for when proof is hex values only
            if (typeof node === 'string') {
                data = this.bufferify(node);
                isLeftNode = true;
            } else if (Array.isArray(node)) {
                isLeftNode = node[0] === 0;
                data = this.bufferify(node[1]);
            } else if (buffer_1.Buffer.isBuffer(node)) {
                data = node;
                isLeftNode = true;
            } else if (node instanceof Object) {
                data = this.bufferify(node.data);
                isLeftNode = node.position === 'left';
            } else {
                throw new Error('Expected node to be of type string or object');
            }
            const buffers = [];
            if (this.isBitcoinTree) {
                buffers.push(buffer_reverse_1.default(hash));
                buffers[isLeftNode ? 'unshift' : 'push'](buffer_reverse_1.default(data));
                hash = this.hashFn(this.concatenator(buffers));
                hash = buffer_reverse_1.default(this.hashFn(hash));
            } else {
                if (this.sortPairs) {
                    if (buffer_1.Buffer.compare(hash, data) === -1) {
                        buffers.push(hash, data);
                        hash = this.hashFn(this.concatenator(buffers));
                    } else {
                        buffers.push(data, hash);
                        hash = this.hashFn(this.concatenator(buffers));
                    }
                } else {
                    buffers.push(hash);
                    buffers[isLeftNode ? 'unshift' : 'push'](data);
                    hash = this.hashFn(this.concatenator(buffers));
                }
            }
        }
        return buffer_1.Buffer.compare(hash, root) === 0;
    }
    /**
     * verifyMultiProof
     * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.
     * @param {Buffer} root - Merkle tree root
     * @param {Number[]} proofIndices - Leave indices for proof
     * @param {Buffer[]} proofLeaves - Leaf values at indices for proof
     * @param {Number} leavesCount - Count of original leaves
     * @param {Buffer[]} proof - Multiproofs given indices
     * @return {Boolean}
     * @example
     *```js
     *const leaves = tree.getLeaves()
     *const root = tree.getRoot()
     *const treeFlat = tree.getLayersFlat()
     *const leavesCount = leaves.length
     *const proofIndices = [2, 5, 6]
     *const proofLeaves = proofIndices.map(i => leaves[i])
     *const proof = tree.getMultiProof(treeFlat, indices)
     *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)
     *```
     */ verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
            // TODO: combine these functions and simplify
            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root = this.bufferify(root);
        proofLeaves = proofLeaves.map((leaf)=>this.bufferify(leaf));
        proof = proof.map((leaf)=>this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)){
            tree[Math.pow(2, depth) + index] = leaf;
        }
        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)){
            tree[index] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value)=>+value).sort((a, b)=>a - b);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i = 0;
        while(i < indexqueue.length){
            const index = indexqueue[i];
            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {
                let pair = [
                    tree[index - index % 2],
                    tree[index - index % 2 + 1]
                ];
                if (this.sortPairs) {
                    pair = pair.sort(buffer_1.Buffer.compare);
                }
                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];
                tree[index / 2 | 0] = hash;
                indexqueue.push(index / 2 | 0);
            }
            i += 1;
        }
        return !proofIndices.length || ({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root);
    }
    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
        root = this.bufferify(root);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for(let i = 0; i < totalHashes; i++){
            const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            const buffers = [
                bufA,
                bufB
            ].sort(buffer_1.Buffer.compare);
            hashes[i] = this.hashFn(this.concatenator(buffers));
        }
        return buffer_1.Buffer.compare(hashes[totalHashes - 1], root) === 0;
    }
    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
        root = this.bufferify(root);
        leaves = leaves.map((leaf)=>this.bufferify(leaf));
        proof = proof.map((leaf)=>this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root.equals(computedRoot);
    }
    /**
     * getDepth
     * @desc Returns the tree depth (number of layers)
     * @return {Number}
     * @example
     *```js
     *const depth = tree.getDepth()
     *```
     */ getDepth() {
        return this.getLayers().length - 1;
    }
    /**
     * getLayersAsObject
     * @desc Returns the layers as nested objects instead of an array.
     * @example
     *```js
     *const layersObj = tree.getLayersAsObject()
     *```
     */ getLayersAsObject() {
        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(value, false)));
        const objs = [];
        for(let i = 0; i < layers.length; i++){
            const arr = [];
            for(let j = 0; j < layers[i].length; j++){
                const obj = {
                    [layers[i][j]]: null
                };
                if (objs.length) {
                    obj[layers[i][j]] = {};
                    const a = objs.shift();
                    const akey = Object.keys(a)[0];
                    obj[layers[i][j]][akey] = a[akey];
                    if (objs.length) {
                        const b = objs.shift();
                        const bkey = Object.keys(b)[0];
                        obj[layers[i][j]][bkey] = b[bkey];
                    }
                }
                arr.push(obj);
            }
            objs.push(...arr);
        }
        return objs[0];
    }
    /**
     * verify
     * @desc Returns true if the proof path (array of hashes) can connect the target node
     * to the Merkle root.
     * @param {Object[]} proof - Array of proof objects that should connect
     * target node to Merkle root.
     * @param {Buffer} targetNode - Target node Buffer
     * @param {Buffer} root - Merkle root Buffer
     * @param {Function} hashFunction - Hash function for hashing leaves and nodes
     * @param {Object} options - Additional options
     * @return {Boolean}
     * @example
     *```js
     *const verified = MerkleTree.verify(proof, leaf, root, sha256, options)
     *```
     */ static verify(proof, targetNode, root, hashFn = sha256_1.default, options = {}) {
        const tree = new MerkleTree([], hashFn, options);
        return tree.verify(proof, targetNode, root);
    }
    /**
     * getMultiProof
     * @desc Returns the multiproof for given tree indices.
     * @param {Buffer[]} tree - Tree as a flat array.
     * @param {Number[]} indices - Tree indices.
     * @return {Buffer[]} - Multiproofs
     *
     *@example
     * ```js
     *const flatTree = tree.getLayersFlat()
     *const indices = [2, 5, 6]
     *const proof = MerkleTree.getMultiProof(flatTree, indices)
     *```
     */ static getMultiProof(tree, indices) {
        const t = new MerkleTree([]);
        return t.getMultiProof(tree, indices);
    }
    /**
     * resetTree
     * @desc Resets the tree by clearing the leaves and layers.
     * @example
     *```js
     *tree.resetTree()
     *```
     */ resetTree() {
        this.leaves = [];
        this.layers = [];
    }
    /**
     * getPairNode
     * @desc Returns the node at the index for given layer.
     * @param {Buffer[]} layer - Tree layer
     * @param {Number} index - Index at layer.
     * @return {Buffer} - Node
     *
     *@example
     * ```js
     *const node = tree.getPairNode(layer, index)
     *```
     */ getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
            return layer[pairIdx];
        } else {
            return null;
        }
    }
    /**
     * toTreeString
     * @desc Returns a visual representation of the merkle tree as a string.
     * @return {String}
     * @example
     *```js
     *console.log(tree.toTreeString())
     *```
     */ toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
    }
    /**
     * toString
     * @desc Returns a visual representation of the merkle tree as a string.
     * @example
     *```js
     *console.log(tree.toString())
     *```
     */ toString() {
        return this.toTreeString();
    }
    isUnevenTree(treeLayers) {
        const depth = (treeLayers === null || treeLayers === void 0 ? void 0 : treeLayers.length) || this.getDepth();
        return !this.isPowOf2(depth);
    }
    isPowOf2(v) {
        return v && !(v & v - 1);
    }
    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this.zip(leafIndices, leafHashes).sort(([indexA], [indexB])=>indexA - indexB);
        const leafTupleIndices = leafTuples.map(([index])=>index);
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for(let i = 0; i < proofIndices.length; i++){
            const indices = proofIndices[i];
            const sliceStart = nextSliceStart;
            nextSliceStart += indices.length;
            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [
            leafTuples
        ];
        for(let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++){
            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex]).sort(([indexA], [indexB])=>indexA - indexB).map(([, hash])=>hash);
            const s = tree[layerIndex].map(([layerIndex])=>layerIndex);
            const parentIndices = [
                ...new Set(s.map((index)=>{
                    if (index % 2 === 0) {
                        return index / 2;
                    }
                    if (index % 2 === 0) {
                        return (index + 1) / 2;
                    }
                    return (index - 1) / 2;
                }))
            ];
            const parentLayer = [];
            for(let i = 0; i < parentIndices.length; i++){
                const parentNodeTreeIndex = parentIndices[i];
                const bufA = currentLayer[i * 2];
                const bufB = currentLayer[i * 2 + 1];
                const hash = bufB ? this.hashFn(this.concatenator([
                    bufA,
                    bufB
                ])) : bufA;
                parentLayer.push([
                    parentNodeTreeIndex,
                    hash
                ]);
            }
            tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
    }
}
exports.MerkleTree = MerkleTree;
if (typeof window !== 'undefined') {
    ;
    window.MerkleTree = MerkleTree;
}
exports.default = MerkleTree;
}}),
"[project]/node_modules/merkletreejs/dist/MerkleMountainRange.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleMountainRange = void 0;
const buffer_1 = __turbopack_context__.r("[externals]/buffer [external] (buffer, cjs)");
const sha256_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/crypto-js/sha256.js [app-ssr] (ecmascript)"));
const Base_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/merkletreejs/dist/Base.js [app-ssr] (ecmascript)"));
// @credit: https://github.com/wanseob/solidity-mmr
/**
 * @desc The index of this MMR implementation starts from 1 not 0.
 */ class MerkleMountainRange extends Base_1.default {
    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn){
        super();
        this.root = buffer_1.Buffer.alloc(0);
        this.size = 0;
        this.width = 0;
        this.hashes = {};
        this.data = {};
        leaves = leaves.map(this.bufferify);
        this.hashFn = this.bufferifyFn(hashFn);
        this.hashLeafFn = hashLeafFn;
        this.peakBaggingFn = peakBaggingFn;
        this.hashBranchFn = hashBranchFn;
        for (const leaf of leaves){
            this.append(leaf);
        }
    }
    /**
     * @desc This only stores the hashed value of the leaf.
     * If you need to retrieve the detail data later, use a map to store them.
     */ append(data) {
        data = this.bufferify(data);
        const dataHash = this.hashFn(data);
        const dataHashHex = this.bufferToHex(dataHash);
        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {
            this.data[dataHashHex] = data;
        }
        const leaf = this.hashLeaf(this.size + 1, dataHash);
        this.hashes[this.size + 1] = leaf;
        this.width += 1;
        // find peaks for enlarged tree
        const peakIndexes = this.getPeakIndexes(this.width);
        // the right most peak's value is the new size of the updated tree
        this.size = this.getSize(this.width);
        // starting from the left-most peak, get all peak hashes
        const peaks = [];
        for(let i = 0; i < peakIndexes.length; i++){
            peaks[i] = this._getOrCreateNode(peakIndexes[i]);
        }
        // update the tree root hash
        this.root = this.peakBagging(this.width, peaks);
    }
    /**
     * @desc It returns the hash of a leaf node with hash(M | DATA )
     *       M is the index of the node.
     */ hashLeaf(index, dataHash) {
        dataHash = this.bufferify(dataHash);
        if (this.hashLeafFn) {
            return this.bufferify(this.hashLeafFn(index, dataHash));
        }
        return this.hashFn(buffer_1.Buffer.concat([
            this.bufferify(index),
            dataHash
        ]));
    }
    /**
     * @desc It returns the hash a parent node with hash(M | Left child | Right child)
     *       M is the index of the node.
     */ hashBranch(index, left, right) {
        if (this.hashBranchFn) {
            return this.bufferify(this.hashBranchFn(index, left, right));
        }
        return this.hashFn(buffer_1.Buffer.concat([
            this.bufferify(index),
            this.bufferify(left),
            this.bufferify(right)
        ]));
    }
    getPeaks() {
        const peakIndexes = this.getPeakIndexes(this.width);
        const peaks = [];
        for(let i = 0; i < peakIndexes.length; i++){
            peaks[i] = this.hashes[peakIndexes[i]];
        }
        return peaks;
    }
    getLeafIndex(width) {
        if (width % 2 === 1) {
            return this.getSize(width);
        }
        return this.getSize(width - 1) + 1;
    }
    /**
     * @desc It returns all peaks of the smallest merkle mountain range tree which includes
     *       the given index(size).
     */ getPeakIndexes(width) {
        const numPeaks = this.numOfPeaks(width);
        const peakIndexes = [];
        let count = 0;
        let size = 0;
        for(let i = 255; i > 0; i--){
            if ((width & 1 << i - 1) !== 0) {
                // peak exists
                size = size + (1 << i) - 1;
                peakIndexes[count++] = size;
                if (peakIndexes.length >= numPeaks) {
                    break;
                }
            }
        }
        if (count !== peakIndexes.length) {
            throw new Error('invalid bit calculation');
        }
        return peakIndexes;
    }
    numOfPeaks(width) {
        let bits = width;
        let num = 0;
        while(bits > 0){
            if (bits % 2 === 1) {
                num++;
            }
            bits = bits >> 1;
        }
        return num;
    }
    peakBagging(width, peaks) {
        const size = this.getSize(width);
        if (this.numOfPeaks(width) !== peaks.length) {
            throw new Error('received invalid number of peaks');
        }
        if (width === 0 && !peaks.length) {
            return buffer_1.Buffer.alloc(0);
        }
        if (this.peakBaggingFn) {
            return this.bufferify(this.peakBaggingFn(size, peaks));
        }
        return this.hashFn(buffer_1.Buffer.concat([
            this.bufferify(size),
            ...peaks.map(this.bufferify)
        ]));
    }
    /**
     * @desc It returns the size of the tree.
     */ getSize(width) {
        return (width << 1) - this.numOfPeaks(width);
    }
    /**
     * @desc It returns the root value of the tree.
     */ getRoot() {
        return this.root;
    }
    getHexRoot() {
        return this.bufferToHex(this.getRoot());
    }
    /**
     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.
     */ getNode(index) {
        return this.hashes[index];
    }
    /**
     * @desc It returns the height of the highest peak.
     */ mountainHeight(size) {
        let height = 1;
        while(1 << height <= size + height){
            height++;
        }
        return height - 1;
    }
    /**
     * @desc It returns the height of the index.
     */ heightAt(index) {
        let reducedIndex = index;
        let peakIndex = 0;
        let height = 0;
        // if an index has a left mountain then subtract the mountain
        while(reducedIndex > peakIndex){
            reducedIndex -= (1 << height) - 1;
            height = this.mountainHeight(reducedIndex);
            peakIndex = (1 << height) - 1;
        }
        // index is on the right slope
        return height - (peakIndex - reducedIndex);
    }
    /**
     * @desc It returns whether the index is the leaf node or not
     */ isLeaf(index) {
        return this.heightAt(index) === 1;
    }
    /**
     * @desc It returns the children when it is a parent node.
     */ getChildren(index) {
        const left = index - (1 << this.heightAt(index) - 1);
        const right = index - 1;
        if (left === right) {
            throw new Error('not a parent');
        }
        return [
            left,
            right
        ];
    }
    /**
     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.
     */ getMerkleProof(index) {
        if (index > this.size) {
            throw new Error('out of range');
        }
        if (!this.isLeaf(index)) {
            throw new Error('not a leaf');
        }
        const root = this.root;
        const width = this.width;
        // find all peaks for bagging
        const peaks = this.getPeakIndexes(this.width);
        const peakBagging = [];
        let cursor = 0;
        for(let i = 0; i < peaks.length; i++){
            // collect the hash of all peaks
            peakBagging[i] = this.hashes[peaks[i]];
            // find the peak which includes the target index
            if (peaks[i] >= index && cursor === 0) {
                cursor = peaks[i];
            }
        }
        let left = 0;
        let right = 0;
        // get hashes of the siblings in the mountain which the index belgons to.
        // it moves the cursor from the summit of the mountain down to the target index
        let height = this.heightAt(cursor);
        const siblings = [];
        while(cursor !== index){
            height--;
            [left, right] = this.getChildren(cursor);
            // move the cursor down to the left size or right size
            cursor = index <= left ? left : right;
            // remaining node is the sibling
            siblings[height - 1] = this.hashes[index <= left ? right : left];
        }
        return {
            root,
            width,
            peakBagging,
            siblings
        };
    }
    /**
     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.
     */ verify(root, width, index, value, peaks, siblings) {
        value = this.bufferify(value);
        const size = this.getSize(width);
        if (size < index) {
            throw new Error('index is out of range');
        }
        // check the root equals the peak bagging hash
        if (!root.equals(this.peakBagging(width, peaks))) {
            throw new Error('invalid root hash from the peaks');
        }
        // find the mountain where the target index belongs to
        let cursor = 0;
        let targetPeak;
        const peakIndexes = this.getPeakIndexes(width);
        for(let i = 0; i < peakIndexes.length; i++){
            if (peakIndexes[i] >= index) {
                targetPeak = peaks[i];
                cursor = peakIndexes[i];
                break;
            }
        }
        if (!targetPeak) {
            throw new Error('target not found');
        }
        // find the path climbing down
        let height = siblings.length + 1;
        const path = new Array(height);
        let left = 0;
        let right = 0;
        while(height > 0){
            // record the current cursor and climb down
            path[--height] = cursor;
            if (cursor === index) {
                break;
            } else {
                // on the parent node. Go left or right
                [left, right] = this.getChildren(cursor);
                cursor = index > left ? right : left;
                continue;
            }
        }
        // calculate the summit hash climbing up again
        let node;
        while(height < path.length){
            // move cursor
            cursor = path[height];
            if (height === 0) {
                // cusor is on the leaf
                node = this.hashLeaf(cursor, this.hashFn(value));
            } else if (cursor - 1 === path[height - 1]) {
                // cursor is on a parent and a siblings is on the left
                node = this.hashBranch(cursor, siblings[height - 1], node);
            } else {
                // cursor is on a parent and a siblings is on the right
                node = this.hashBranch(cursor, node, siblings[height - 1]);
            }
            // climb up
            height++;
        }
        // computed hash value of the summit should equal to the target peak hash
        if (!node.equals(targetPeak)) {
            throw new Error('hashed peak is invalid');
        }
        return true;
    }
    peaksToPeakMap(width, peaks) {
        const peakMap = {};
        let bitIndex = 0;
        let peakRef = 0;
        let count = peaks.length;
        for(let height = 1; height <= 32; height++){
            // index starts from the right most bit
            bitIndex = 32 - height;
            peakRef = 1 << height - 1;
            if ((width & peakRef) !== 0) {
                peakMap[bitIndex] = peaks[--count];
            } else {
                peakMap[bitIndex] = 0;
            }
        }
        if (count !== 0) {
            throw new Error('invalid number of peaks');
        }
        return peakMap;
    }
    peakMapToPeaks(width, peakMap) {
        const arrLength = this.numOfPeaks(width);
        const peaks = new Array(arrLength);
        let count = 0;
        for(let i = 0; i < 32; i++){
            if (peakMap[i] !== 0) {
                peaks[count++] = peakMap[i];
            }
        }
        if (count !== arrLength) {
            throw new Error('invalid number of peaks');
        }
        return peaks;
    }
    peakUpdate(width, prevPeakMap, itemHash) {
        const nextPeakMap = {};
        const newWidth = width + 1;
        let cursorIndex = this.getLeafIndex(newWidth);
        let cursorNode = this.hashLeaf(cursorIndex, itemHash);
        let bitIndex = 0;
        let peakRef = 0;
        let prevPeakExist = false;
        let nextPeakExist = false;
        let obtained = false;
        for(let height = 1; height <= 32; height++){
            // index starts from the right most bit
            bitIndex = 32 - height;
            if (obtained) {
                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
            } else {
                peakRef = 1 << height - 1;
                prevPeakExist = (width & peakRef) !== 0;
                nextPeakExist = (newWidth & peakRef) !== 0;
                // get new cursor node with hashing the peak and the current cursor
                cursorIndex++;
                if (prevPeakExist) {
                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);
                }
                // if new peak exists for the bit index
                if (nextPeakExist) {
                    // if prev peak exists for the bit index
                    if (prevPeakExist) {
                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];
                    } else {
                        nextPeakMap[bitIndex] = cursorNode;
                    }
                    obtained = true;
                } else {
                    nextPeakMap[bitIndex] = 0;
                }
            }
        }
        return nextPeakMap;
    }
    rollUp(root, width, peaks, itemHashes) {
        // check the root equals the peak bagging hash
        if (!root.equals(this.peakBagging(width, peaks))) {
            throw new Error('invalid root hash from the peaks');
        }
        let tmpWidth = width;
        let tmpPeakMap = this.peaksToPeakMap(width, peaks);
        for(let i = 0; i < itemHashes.length; i++){
            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);
            tmpWidth++;
        }
        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));
    }
    /**
     * @desc It returns the hash value of the node for the index.
     *      If the hash already exists it simply returns the stored value. On the other hand,
     *      it computes hashes recursively downward.
     *      Only appending an item calls this function.
     */ _getOrCreateNode(index) {
        if (index > this.size) {
            throw new Error('out of range');
        }
        if (!this.hashes[index]) {
            const [leftIndex, rightIndex] = this.getChildren(index);
            const leftHash = this._getOrCreateNode(leftIndex);
            const rightHash = this._getOrCreateNode(rightIndex);
            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);
        }
        return this.hashes[index];
    }
}
exports.MerkleMountainRange = MerkleMountainRange;
if (typeof window !== 'undefined') {
    ;
    window.MerkleMountainRange = MerkleMountainRange;
}
exports.default = MerkleMountainRange;
}}),
"[project]/node_modules/merkletreejs/dist/IncrementalMerkleTree.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IncrementalMerkleTree = void 0;
const Base_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/merkletreejs/dist/Base.js [app-ssr] (ecmascript)"));
const treeify_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/treeify/treeify.js [app-ssr] (ecmascript)"));
class IncrementalMerkleTree extends Base_1.default {
    constructor(hashFn, options){
        super();
        this.hashFn = hashFn;
        if (options.depth) {
            this.depth = options.depth;
        }
        if (options.arity) {
            this.arity = options.arity;
        }
        if (this.depth < 1) {
            throw new Error('depth must be greater than 0');
        }
        if (this.arity < 1) {
            throw new Error('arity must be greater than 0');
        }
        const nodes = [];
        let zeroValue = options.zeroValue;
        this.zeroValue = zeroValue;
        this.zeroes = [];
        if (this.depth) {
            for(let i = 0; i < this.depth; i++){
                this.zeroes.push(zeroValue);
                nodes[i] = [];
                zeroValue = this.hashFn(Array(this.arity).fill(zeroValue));
            }
        }
        this.nodes = nodes;
        this.root = zeroValue;
    }
    getRoot() {
        return this.root;
    }
    getHexRoot() {
        return this.bufferToHex(this.bufferify(this.getRoot()));
    }
    insert(leaf) {
        if (this.depth && this.arity) {
            if (this.nodes[0].length >= this.getMaxLeaves()) {
                throw new Error('tree is full');
            }
        }
        let node = leaf;
        let index = this.nodes[0].length;
        for(let level = 0; level < this.depth; level += 1){
            const position = index % this.arity;
            const levelStartIndex = index - position;
            const levelEndIndex = levelStartIndex + this.arity;
            const children = [];
            this.nodes[level][index] = node;
            for(let i = levelStartIndex; i < levelEndIndex; i += 1){
                if (i < this.nodes[level].length) {
                    children.push(this.nodes[level][i]);
                } else {
                    children.push(this.zeroes[level]);
                }
            }
            node = this.hashFn(children);
            index = Math.floor(index / this.arity);
        }
        this.root = node;
    }
    delete(index) {
        this.update(index, this.zeroValue);
    }
    update(index, newLeaf) {
        if (index < 0 || index >= this.nodes[0].length) {
            throw new Error('out of bounds');
        }
        let node = newLeaf;
        for(let level = 0; level < this.depth; level += 1){
            const position = index % this.arity;
            const levelStartIndex = index - position;
            const levelEndIndex = levelStartIndex + this.arity;
            const children = [];
            this.nodes[level][index] = node;
            for(let i = levelStartIndex; i < levelEndIndex; i += 1){
                if (i < this.nodes[level].length) {
                    children.push(this.nodes[level][i]);
                } else {
                    children.push(this.zeroes[level]);
                }
            }
            node = this.hashFn(children);
            index = Math.floor(index / this.arity);
        }
        this.root = node;
    }
    getDepth() {
        return this.depth;
    }
    getArity() {
        return this.arity;
    }
    getMaxLeaves() {
        return Math.pow(this.depth, this.arity);
    }
    indexOf(leaf) {
        return this.nodes[0].indexOf(leaf);
    }
    getLeaves() {
        const leaves = this.copyList(this.nodes[0]);
        const index = this.nodes[0].length;
        for(let i = index; i < this.getMaxLeaves(); i++){
            leaves[i] = this.zeroValue;
        }
        return leaves;
    }
    copyList(list) {
        return list.map((x)=>BigInt(x));
    }
    getLayers() {
        const layers = [];
        for (const list of this.nodes){
            layers.push(this.copyList(list));
        }
        if (layers[0].length < this.getMaxLeaves()) {
            let index = layers[0].length;
            for(let i = index; i < this.getMaxLeaves(); i++){
                layers[0][i] = this.zeroValue;
            }
            for(let level = 0; level < this.depth; level++){
                const position = index % this.arity;
                const levelStartIndex = index - position;
                const levelEndIndex = levelStartIndex + this.arity;
                for(let i = levelStartIndex; i < levelEndIndex; i++){
                    if (i >= layers[level].length) {
                        layers[level][i] = this.zeroes[level];
                    }
                }
                index = Math.floor(index / this.arity);
            }
        }
        layers.push([
            this.root
        ]);
        return layers;
    }
    getHexLayers() {
        return this.getLayers().reduce((acc, item)=>{
            if (Array.isArray(item)) {
                acc.push(item.map((layer)=>this.bufferToHex(this.bufferify(layer))));
            } else {
                acc.push(item);
            }
            return acc;
        }, []);
    }
    getLayersAsObject() {
        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(this.bufferify(value), false)));
        const objs = [];
        for(let i = 0; i < layers.length; i++){
            const arr = [];
            for(let j = 0; j < layers[i].length; j++){
                const obj = {
                    [layers[i][j]]: null
                };
                if (objs.length) {
                    obj[layers[i][j]] = {};
                    const a = objs.shift();
                    const akey = Object.keys(a)[0];
                    obj[layers[i][j]][akey] = a[akey];
                    if (objs.length) {
                        const b = objs.shift();
                        const bkey = Object.keys(b)[0];
                        obj[layers[i][j]][bkey] = b[bkey];
                    }
                }
                arr.push(obj);
            }
            objs.push(...arr);
        }
        return objs[0];
    }
    computeRoot() {
        let node;
        let index = this.nodes[0].length;
        for(let level = 0; level < this.depth; level += 1){
            const position = index % this.arity;
            const levelStartIndex = index - position;
            const levelEndIndex = levelStartIndex + this.arity;
            const children = [];
            for(let i = levelStartIndex; i < levelEndIndex; i += 1){
                if (i < this.nodes[level].length) {
                    children.push(this.nodes[level][i]);
                } else {
                    children.push(this.zeroes[level]);
                }
            }
            node = this.hashFn(children);
            index = Math.floor(index / this.arity);
        }
        return node;
    }
    getProof(index) {
        if (index < 0 || index >= this.nodes[0].length) {
            throw new Error('The leaf does not exist in this tree');
        }
        const siblings = [];
        const pathIndices = [];
        const leafIndex = index;
        for(let level = 0; level < this.depth; level += 1){
            const position = index % this.arity;
            const levelStartIndex = index - position;
            const levelEndIndex = levelStartIndex + this.arity;
            pathIndices[level] = position;
            siblings[level] = [];
            for(let i = levelStartIndex; i < levelEndIndex; i += 1){
                if (i !== index) {
                    if (i < this.nodes[level].length) {
                        siblings[level].push(this.nodes[level][i]);
                    } else {
                        siblings[level].push(this.zeroes[level]);
                    }
                }
            }
            index = Math.floor(index / this.arity);
        }
        return {
            root: this.root,
            leaf: this.nodes[0][leafIndex],
            pathIndices,
            siblings
        };
    }
    verify(proof) {
        let node = proof.leaf;
        for(let i = 0; i < proof.siblings.length; i += 1){
            const children = proof.siblings[i].slice();
            children.splice(proof.pathIndices[i], 0, node);
            node = this.hashFn(children);
        }
        return proof.root === node;
    }
    toString() {
        return this.toTreeString();
    }
    toTreeString() {
        const obj = this.getLayersAsObject();
        return treeify_1.default.asTree(obj, true);
    }
}
exports.IncrementalMerkleTree = IncrementalMerkleTree;
if (typeof window !== 'undefined') {
    ;
    window.IncrementalMerkleTree = IncrementalMerkleTree;
}
exports.default = IncrementalMerkleTree;
}}),
"[project]/node_modules/merkletreejs/dist/MerkleSumTree.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleSumTree = exports.ProofStep = exports.Leaf = exports.Bucket = void 0;
const Base_1 = __turbopack_context__.r("[project]/node_modules/merkletreejs/dist/Base.js [app-ssr] (ecmascript)");
class Bucket {
    constructor(size, hashed){
        this.size = BigInt(size);
        this.hashed = hashed;
        // each node in the tree can have a parent, and a left or right sibling
        this.parent = null;
        this.left = null;
        this.right = null;
    }
}
exports.Bucket = Bucket;
class Leaf {
    constructor(hashFn, rng, data){
        this.hashFn = hashFn;
        this.rng = rng.map((x)=>BigInt(x));
        this.data = data;
    }
    getBucket() {
        let hashed;
        if (this.data) {
            hashed = this.hashFn(this.data);
        } else {
            hashed = Buffer.alloc(32);
        }
        return new Bucket(BigInt(this.rng[1]) - BigInt(this.rng[0]), hashed);
    }
}
exports.Leaf = Leaf;
class ProofStep {
    constructor(bucket, right){
        this.bucket = bucket;
        this.right = right; // whether the bucket hash should be appeded on the right side in this step (default is left
    }
}
exports.ProofStep = ProofStep;
class MerkleSumTree extends Base_1.Base {
    constructor(leaves, hashFn){
        super();
        this.leaves = leaves;
        this.hashFn = hashFn;
        MerkleSumTree.checkConsecutive(leaves);
        this.buckets = [];
        for (const l of leaves){
            this.buckets.push(l.getBucket());
        }
        let buckets = [];
        for (const bucket of this.buckets){
            buckets.push(bucket);
        }
        while(buckets.length !== 1){
            const newBuckets = [];
            while(buckets.length){
                if (buckets.length >= 2) {
                    const b1 = buckets.shift();
                    const b2 = buckets.shift();
                    const size = b1.size + b2.size;
                    const hashed = this.hashFn(Buffer.concat([
                        this.sizeToBuffer(b1.size),
                        this.bufferify(b1.hashed),
                        this.sizeToBuffer(b2.size),
                        this.bufferify(b2.hashed)
                    ]));
                    const b = new Bucket(size, hashed);
                    b2.parent = b;
                    b1.parent = b2.parent;
                    b1.right = b2;
                    b2.left = b1;
                    newBuckets.push(b);
                } else {
                    newBuckets.push(buckets.shift());
                }
            }
            buckets = newBuckets;
        }
        this.root = buckets[0];
    }
    sizeToBuffer(size) {
        const buf = Buffer.alloc(8);
        const view = new DataView(buf.buffer);
        view.setBigInt64(0, BigInt(size), false); // true when little endian
        return buf;
    }
    static checkConsecutive(leaves) {
        let curr = BigInt(0);
        for (const leaf of leaves){
            if (leaf.rng[0] !== curr) {
                throw new Error('leaf ranges are invalid');
            }
            curr = BigInt(leaf.rng[1]);
        }
    }
    // gets inclusion/exclusion proof of a bucket in the specified index
    getProof(index) {
        let curr = this.buckets[Number(index)];
        const proof = [];
        while(curr && curr.parent){
            const right = !!curr.right;
            const bucket = curr.right ? curr.right : curr.left;
            curr = curr.parent;
            proof.push(new ProofStep(bucket, right));
        }
        return proof;
    }
    sum(arr) {
        let total = BigInt(0);
        for (const value of arr){
            total += BigInt(value);
        }
        return total;
    }
    // validates the suppplied proof for a specified leaf according to the root bucket
    verifyProof(root, leaf, proof) {
        const rng = [
            this.sum(proof.filter((x)=>!x.right).map((x)=>x.bucket.size)),
            BigInt(root.size) - this.sum(proof.filter((x)=>x.right).map((x)=>x.bucket.size))
        ];
        if (!(rng[0] === leaf.rng[0] && rng[1] === leaf.rng[1])) {
            // supplied steps are not routing to the range specified
            return false;
        }
        let curr = leaf.getBucket();
        let hashed;
        for (const step of proof){
            if (step.right) {
                hashed = this.hashFn(Buffer.concat([
                    this.sizeToBuffer(curr.size),
                    this.bufferify(curr.hashed),
                    this.sizeToBuffer(step.bucket.size),
                    this.bufferify(step.bucket.hashed)
                ]));
            } else {
                hashed = this.hashFn(Buffer.concat([
                    this.sizeToBuffer(step.bucket.size),
                    this.bufferify(step.bucket.hashed),
                    this.sizeToBuffer(curr.size),
                    this.bufferify(curr.hashed)
                ]));
            }
            curr = new Bucket(BigInt(curr.size) + BigInt(step.bucket.size), hashed);
        }
        return curr.size === root.size && curr.hashed.toString('hex') === root.hashed.toString('hex');
    }
}
exports.MerkleSumTree = MerkleSumTree;
if (typeof window !== 'undefined') {
    ;
    window.MerkleSumTree = MerkleSumTree;
}
exports.default = MerkleSumTree;
}}),
"[project]/node_modules/merkletreejs/dist/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MerkleTree = void 0;
const MerkleTree_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/merkletreejs/dist/MerkleTree.js [app-ssr] (ecmascript)"));
exports.MerkleTree = MerkleTree_1.default;
var MerkleMountainRange_1 = __turbopack_context__.r("[project]/node_modules/merkletreejs/dist/MerkleMountainRange.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MerkleMountainRange", {
    enumerable: true,
    get: function() {
        return MerkleMountainRange_1.MerkleMountainRange;
    }
});
var IncrementalMerkleTree_1 = __turbopack_context__.r("[project]/node_modules/merkletreejs/dist/IncrementalMerkleTree.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "IncrementalMerkleTree", {
    enumerable: true,
    get: function() {
        return IncrementalMerkleTree_1.IncrementalMerkleTree;
    }
});
var MerkleSumTree_1 = __turbopack_context__.r("[project]/node_modules/merkletreejs/dist/MerkleSumTree.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "MerkleSumTree", {
    enumerable: true,
    get: function() {
        return MerkleSumTree_1.MerkleSumTree;
    }
});
exports.default = MerkleTree_1.default;
}}),
"[project]/node_modules/lodash/_listCacheClear.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
module.exports = listCacheClear;
}}),
"[project]/node_modules/lodash/eq.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
module.exports = eq;
}}),
"[project]/node_modules/lodash/_assocIndexOf.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var eq = __turbopack_context__.r("[project]/node_modules/lodash/eq.js [app-ssr] (ecmascript)");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
module.exports = assocIndexOf;
}}),
"[project]/node_modules/lodash/_listCacheDelete.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var assocIndexOf = __turbopack_context__.r("[project]/node_modules/lodash/_assocIndexOf.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var arrayProto = Array.prototype;
/** Built-in value references. */ var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    --this.size;
    return true;
}
module.exports = listCacheDelete;
}}),
"[project]/node_modules/lodash/_listCacheGet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var assocIndexOf = __turbopack_context__.r("[project]/node_modules/lodash/_assocIndexOf.js [app-ssr] (ecmascript)");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
module.exports = listCacheGet;
}}),
"[project]/node_modules/lodash/_listCacheHas.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var assocIndexOf = __turbopack_context__.r("[project]/node_modules/lodash/_assocIndexOf.js [app-ssr] (ecmascript)");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
module.exports = listCacheHas;
}}),
"[project]/node_modules/lodash/_listCacheSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var assocIndexOf = __turbopack_context__.r("[project]/node_modules/lodash/_assocIndexOf.js [app-ssr] (ecmascript)");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
module.exports = listCacheSet;
}}),
"[project]/node_modules/lodash/_ListCache.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var listCacheClear = __turbopack_context__.r("[project]/node_modules/lodash/_listCacheClear.js [app-ssr] (ecmascript)"), listCacheDelete = __turbopack_context__.r("[project]/node_modules/lodash/_listCacheDelete.js [app-ssr] (ecmascript)"), listCacheGet = __turbopack_context__.r("[project]/node_modules/lodash/_listCacheGet.js [app-ssr] (ecmascript)"), listCacheHas = __turbopack_context__.r("[project]/node_modules/lodash/_listCacheHas.js [app-ssr] (ecmascript)"), listCacheSet = __turbopack_context__.r("[project]/node_modules/lodash/_listCacheSet.js [app-ssr] (ecmascript)");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;
}}),
"[project]/node_modules/lodash/_stackClear.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var ListCache = __turbopack_context__.r("[project]/node_modules/lodash/_ListCache.js [app-ssr] (ecmascript)");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
}
module.exports = stackClear;
}}),
"[project]/node_modules/lodash/_stackDelete.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
module.exports = stackDelete;
}}),
"[project]/node_modules/lodash/_stackGet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
module.exports = stackGet;
}}),
"[project]/node_modules/lodash/_stackHas.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
module.exports = stackHas;
}}),
"[project]/node_modules/lodash/_freeGlobal.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
}}),
"[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var freeGlobal = __turbopack_context__.r("[project]/node_modules/lodash/_freeGlobal.js [app-ssr] (ecmascript)");
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;
}}),
"[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/** Built-in value references. */ var Symbol = root.Symbol;
module.exports = Symbol;
}}),
"[project]/node_modules/lodash/_getRawTag.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Symbol = __turbopack_context__.r("[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if ("TURBOPACK compile-time truthy", 1) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
module.exports = getRawTag;
}}),
"[project]/node_modules/lodash/_objectToString.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;
}}),
"[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Symbol = __turbopack_context__.r("[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)"), getRawTag = __turbopack_context__.r("[project]/node_modules/lodash/_getRawTag.js [app-ssr] (ecmascript)"), objectToString = __turbopack_context__.r("[project]/node_modules/lodash/_objectToString.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
/** Built-in value references. */ var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;
}}),
"[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;
}}),
"[project]/node_modules/lodash/isFunction.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseGetTag = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
module.exports = isFunction;
}}),
"[project]/node_modules/lodash/_coreJsData.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;
}}),
"[project]/node_modules/lodash/_isMasked.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var coreJsData = __turbopack_context__.r("[project]/node_modules/lodash/_coreJsData.js [app-ssr] (ecmascript)");
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
module.exports = isMasked;
}}),
"[project]/node_modules/lodash/_toSource.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used for built-in method references. */ var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
module.exports = toSource;
}}),
"[project]/node_modules/lodash/_baseIsNative.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isFunction = __turbopack_context__.r("[project]/node_modules/lodash/isFunction.js [app-ssr] (ecmascript)"), isMasked = __turbopack_context__.r("[project]/node_modules/lodash/_isMasked.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)"), toSource = __turbopack_context__.r("[project]/node_modules/lodash/_toSource.js [app-ssr] (ecmascript)");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
module.exports = baseIsNative;
}}),
"[project]/node_modules/lodash/_getValue.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
module.exports = getValue;
}}),
"[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseIsNative = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsNative.js [app-ssr] (ecmascript)"), getValue = __turbopack_context__.r("[project]/node_modules/lodash/_getValue.js [app-ssr] (ecmascript)");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
module.exports = getNative;
}}),
"[project]/node_modules/lodash/_Map.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)"), root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map');
module.exports = Map;
}}),
"[project]/node_modules/lodash/_nativeCreate.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;
}}),
"[project]/node_modules/lodash/_hashClear.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var nativeCreate = __turbopack_context__.r("[project]/node_modules/lodash/_nativeCreate.js [app-ssr] (ecmascript)");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
module.exports = hashClear;
}}),
"[project]/node_modules/lodash/_hashDelete.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = hashDelete;
}}),
"[project]/node_modules/lodash/_hashGet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var nativeCreate = __turbopack_context__.r("[project]/node_modules/lodash/_nativeCreate.js [app-ssr] (ecmascript)");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
module.exports = hashGet;
}}),
"[project]/node_modules/lodash/_hashHas.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var nativeCreate = __turbopack_context__.r("[project]/node_modules/lodash/_nativeCreate.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
module.exports = hashHas;
}}),
"[project]/node_modules/lodash/_hashSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var nativeCreate = __turbopack_context__.r("[project]/node_modules/lodash/_nativeCreate.js [app-ssr] (ecmascript)");
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
module.exports = hashSet;
}}),
"[project]/node_modules/lodash/_Hash.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var hashClear = __turbopack_context__.r("[project]/node_modules/lodash/_hashClear.js [app-ssr] (ecmascript)"), hashDelete = __turbopack_context__.r("[project]/node_modules/lodash/_hashDelete.js [app-ssr] (ecmascript)"), hashGet = __turbopack_context__.r("[project]/node_modules/lodash/_hashGet.js [app-ssr] (ecmascript)"), hashHas = __turbopack_context__.r("[project]/node_modules/lodash/_hashHas.js [app-ssr] (ecmascript)"), hashSet = __turbopack_context__.r("[project]/node_modules/lodash/_hashSet.js [app-ssr] (ecmascript)");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;
}}),
"[project]/node_modules/lodash/_mapCacheClear.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Hash = __turbopack_context__.r("[project]/node_modules/lodash/_Hash.js [app-ssr] (ecmascript)"), ListCache = __turbopack_context__.r("[project]/node_modules/lodash/_ListCache.js [app-ssr] (ecmascript)"), Map = __turbopack_context__.r("[project]/node_modules/lodash/_Map.js [app-ssr] (ecmascript)");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
module.exports = mapCacheClear;
}}),
"[project]/node_modules/lodash/_isKeyable.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
module.exports = isKeyable;
}}),
"[project]/node_modules/lodash/_getMapData.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isKeyable = __turbopack_context__.r("[project]/node_modules/lodash/_isKeyable.js [app-ssr] (ecmascript)");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
module.exports = getMapData;
}}),
"[project]/node_modules/lodash/_mapCacheDelete.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getMapData = __turbopack_context__.r("[project]/node_modules/lodash/_getMapData.js [app-ssr] (ecmascript)");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = mapCacheDelete;
}}),
"[project]/node_modules/lodash/_mapCacheGet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getMapData = __turbopack_context__.r("[project]/node_modules/lodash/_getMapData.js [app-ssr] (ecmascript)");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
module.exports = mapCacheGet;
}}),
"[project]/node_modules/lodash/_mapCacheHas.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getMapData = __turbopack_context__.r("[project]/node_modules/lodash/_getMapData.js [app-ssr] (ecmascript)");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
module.exports = mapCacheHas;
}}),
"[project]/node_modules/lodash/_mapCacheSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getMapData = __turbopack_context__.r("[project]/node_modules/lodash/_getMapData.js [app-ssr] (ecmascript)");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
module.exports = mapCacheSet;
}}),
"[project]/node_modules/lodash/_MapCache.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var mapCacheClear = __turbopack_context__.r("[project]/node_modules/lodash/_mapCacheClear.js [app-ssr] (ecmascript)"), mapCacheDelete = __turbopack_context__.r("[project]/node_modules/lodash/_mapCacheDelete.js [app-ssr] (ecmascript)"), mapCacheGet = __turbopack_context__.r("[project]/node_modules/lodash/_mapCacheGet.js [app-ssr] (ecmascript)"), mapCacheHas = __turbopack_context__.r("[project]/node_modules/lodash/_mapCacheHas.js [app-ssr] (ecmascript)"), mapCacheSet = __turbopack_context__.r("[project]/node_modules/lodash/_mapCacheSet.js [app-ssr] (ecmascript)");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;
}}),
"[project]/node_modules/lodash/_stackSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var ListCache = __turbopack_context__.r("[project]/node_modules/lodash/_ListCache.js [app-ssr] (ecmascript)"), Map = __turbopack_context__.r("[project]/node_modules/lodash/_Map.js [app-ssr] (ecmascript)"), MapCache = __turbopack_context__.r("[project]/node_modules/lodash/_MapCache.js [app-ssr] (ecmascript)");
/** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
module.exports = stackSet;
}}),
"[project]/node_modules/lodash/_Stack.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var ListCache = __turbopack_context__.r("[project]/node_modules/lodash/_ListCache.js [app-ssr] (ecmascript)"), stackClear = __turbopack_context__.r("[project]/node_modules/lodash/_stackClear.js [app-ssr] (ecmascript)"), stackDelete = __turbopack_context__.r("[project]/node_modules/lodash/_stackDelete.js [app-ssr] (ecmascript)"), stackGet = __turbopack_context__.r("[project]/node_modules/lodash/_stackGet.js [app-ssr] (ecmascript)"), stackHas = __turbopack_context__.r("[project]/node_modules/lodash/_stackHas.js [app-ssr] (ecmascript)"), stackSet = __turbopack_context__.r("[project]/node_modules/lodash/_stackSet.js [app-ssr] (ecmascript)");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;
}}),
"[project]/node_modules/lodash/_arrayEach.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
module.exports = arrayEach;
}}),
"[project]/node_modules/lodash/_defineProperty.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)");
var defineProperty = function() {
    try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
    } catch (e) {}
}();
module.exports = defineProperty;
}}),
"[project]/node_modules/lodash/_baseAssignValue.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var defineProperty = __turbopack_context__.r("[project]/node_modules/lodash/_defineProperty.js [app-ssr] (ecmascript)");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
        });
    } else {
        object[key] = value;
    }
}
module.exports = baseAssignValue;
}}),
"[project]/node_modules/lodash/_assignValue.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseAssignValue = __turbopack_context__.r("[project]/node_modules/lodash/_baseAssignValue.js [app-ssr] (ecmascript)"), eq = __turbopack_context__.r("[project]/node_modules/lodash/eq.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        baseAssignValue(object, key, value);
    }
}
module.exports = assignValue;
}}),
"[project]/node_modules/lodash/_copyObject.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var assignValue = __turbopack_context__.r("[project]/node_modules/lodash/_assignValue.js [app-ssr] (ecmascript)"), baseAssignValue = __turbopack_context__.r("[project]/node_modules/lodash/_baseAssignValue.js [app-ssr] (ecmascript)");
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        if (newValue === undefined) {
            newValue = source[key];
        }
        if (isNew) {
            baseAssignValue(object, key, newValue);
        } else {
            assignValue(object, key, newValue);
        }
    }
    return object;
}
module.exports = copyObject;
}}),
"[project]/node_modules/lodash/_baseTimes.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
module.exports = baseTimes;
}}),
"[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
module.exports = isObjectLike;
}}),
"[project]/node_modules/lodash/_baseIsArguments.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseGetTag = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
module.exports = baseIsArguments;
}}),
"[project]/node_modules/lodash/isArguments.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseIsArguments = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsArguments.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;
}}),
"[project]/node_modules/lodash/isArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
module.exports = isArray;
}}),
"[project]/node_modules/lodash/stubFalse.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = stubFalse;
}}),
"[project]/node_modules/lodash/isBuffer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)"), stubFalse = __turbopack_context__.r("[project]/node_modules/lodash/stubFalse.js [app-ssr] (ecmascript)");
/** Detect free variable `exports`. */ var freeExports = ("TURBOPACK compile-time value", "object") == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && ("TURBOPACK compile-time value", "object") == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
}}),
"[project]/node_modules/lodash/_isIndex.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
module.exports = isIndex;
}}),
"[project]/node_modules/lodash/isLength.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
module.exports = isLength;
}}),
"[project]/node_modules/lodash/_baseIsTypedArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseGetTag = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)"), isLength = __turbopack_context__.r("[project]/node_modules/lodash/isLength.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
module.exports = baseIsTypedArray;
}}),
"[project]/node_modules/lodash/_baseUnary.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
module.exports = baseUnary;
}}),
"[project]/node_modules/lodash/_nodeUtil.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var freeGlobal = __turbopack_context__.r("[project]/node_modules/lodash/_freeGlobal.js [app-ssr] (ecmascript)");
/** Detect free variable `exports`. */ var freeExports = ("TURBOPACK compile-time value", "object") == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && ("TURBOPACK compile-time value", "object") == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) {
            return types;
        }
        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
}();
module.exports = nodeUtil;
}}),
"[project]/node_modules/lodash/isTypedArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseIsTypedArray = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsTypedArray.js [app-ssr] (ecmascript)"), baseUnary = __turbopack_context__.r("[project]/node_modules/lodash/_baseUnary.js [app-ssr] (ecmascript)"), nodeUtil = __turbopack_context__.r("[project]/node_modules/lodash/_nodeUtil.js [app-ssr] (ecmascript)");
/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;
}}),
"[project]/node_modules/lodash/_arrayLikeKeys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseTimes = __turbopack_context__.r("[project]/node_modules/lodash/_baseTimes.js [app-ssr] (ecmascript)"), isArguments = __turbopack_context__.r("[project]/node_modules/lodash/isArguments.js [app-ssr] (ecmascript)"), isArray = __turbopack_context__.r("[project]/node_modules/lodash/isArray.js [app-ssr] (ecmascript)"), isBuffer = __turbopack_context__.r("[project]/node_modules/lodash/isBuffer.js [app-ssr] (ecmascript)"), isIndex = __turbopack_context__.r("[project]/node_modules/lodash/_isIndex.js [app-ssr] (ecmascript)"), isTypedArray = __turbopack_context__.r("[project]/node_modules/lodash/isTypedArray.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (// Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
module.exports = arrayLikeKeys;
}}),
"[project]/node_modules/lodash/_isPrototype.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
module.exports = isPrototype;
}}),
"[project]/node_modules/lodash/_overArg.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
module.exports = overArg;
}}),
"[project]/node_modules/lodash/_nativeKeys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var overArg = __turbopack_context__.r("[project]/node_modules/lodash/_overArg.js [app-ssr] (ecmascript)");
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;
}}),
"[project]/node_modules/lodash/_baseKeys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isPrototype = __turbopack_context__.r("[project]/node_modules/lodash/_isPrototype.js [app-ssr] (ecmascript)"), nativeKeys = __turbopack_context__.r("[project]/node_modules/lodash/_nativeKeys.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
module.exports = baseKeys;
}}),
"[project]/node_modules/lodash/isArrayLike.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isFunction = __turbopack_context__.r("[project]/node_modules/lodash/isFunction.js [app-ssr] (ecmascript)"), isLength = __turbopack_context__.r("[project]/node_modules/lodash/isLength.js [app-ssr] (ecmascript)");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
module.exports = isArrayLike;
}}),
"[project]/node_modules/lodash/keys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayLikeKeys = __turbopack_context__.r("[project]/node_modules/lodash/_arrayLikeKeys.js [app-ssr] (ecmascript)"), baseKeys = __turbopack_context__.r("[project]/node_modules/lodash/_baseKeys.js [app-ssr] (ecmascript)"), isArrayLike = __turbopack_context__.r("[project]/node_modules/lodash/isArrayLike.js [app-ssr] (ecmascript)");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
module.exports = keys;
}}),
"[project]/node_modules/lodash/_baseAssign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var copyObject = __turbopack_context__.r("[project]/node_modules/lodash/_copyObject.js [app-ssr] (ecmascript)"), keys = __turbopack_context__.r("[project]/node_modules/lodash/keys.js [app-ssr] (ecmascript)");
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
module.exports = baseAssign;
}}),
"[project]/node_modules/lodash/_nativeKeysIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for(var key in Object(object)){
            result.push(key);
        }
    }
    return result;
}
module.exports = nativeKeysIn;
}}),
"[project]/node_modules/lodash/_baseKeysIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)"), isPrototype = __turbopack_context__.r("[project]/node_modules/lodash/_isPrototype.js [app-ssr] (ecmascript)"), nativeKeysIn = __turbopack_context__.r("[project]/node_modules/lodash/_nativeKeysIn.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for(var key in object){
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
module.exports = baseKeysIn;
}}),
"[project]/node_modules/lodash/keysIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayLikeKeys = __turbopack_context__.r("[project]/node_modules/lodash/_arrayLikeKeys.js [app-ssr] (ecmascript)"), baseKeysIn = __turbopack_context__.r("[project]/node_modules/lodash/_baseKeysIn.js [app-ssr] (ecmascript)"), isArrayLike = __turbopack_context__.r("[project]/node_modules/lodash/isArrayLike.js [app-ssr] (ecmascript)");
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */ function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
module.exports = keysIn;
}}),
"[project]/node_modules/lodash/_baseAssignIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var copyObject = __turbopack_context__.r("[project]/node_modules/lodash/_copyObject.js [app-ssr] (ecmascript)"), keysIn = __turbopack_context__.r("[project]/node_modules/lodash/keysIn.js [app-ssr] (ecmascript)");
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
}
module.exports = baseAssignIn;
}}),
"[project]/node_modules/lodash/_cloneBuffer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/** Detect free variable `exports`. */ var freeExports = ("TURBOPACK compile-time value", "object") == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && ("TURBOPACK compile-time value", "object") == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
        return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
}
module.exports = cloneBuffer;
}}),
"[project]/node_modules/lodash/_copyArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length){
        array[index] = source[index];
    }
    return array;
}
module.exports = copyArray;
}}),
"[project]/node_modules/lodash/_arrayFilter.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
module.exports = arrayFilter;
}}),
"[project]/node_modules/lodash/stubArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
module.exports = stubArray;
}}),
"[project]/node_modules/lodash/_getSymbols.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayFilter = __turbopack_context__.r("[project]/node_modules/lodash/_arrayFilter.js [app-ssr] (ecmascript)"), stubArray = __turbopack_context__.r("[project]/node_modules/lodash/stubArray.js [app-ssr] (ecmascript)");
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
        return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
module.exports = getSymbols;
}}),
"[project]/node_modules/lodash/_copySymbols.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var copyObject = __turbopack_context__.r("[project]/node_modules/lodash/_copyObject.js [app-ssr] (ecmascript)"), getSymbols = __turbopack_context__.r("[project]/node_modules/lodash/_getSymbols.js [app-ssr] (ecmascript)");
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
module.exports = copySymbols;
}}),
"[project]/node_modules/lodash/_arrayPush.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
module.exports = arrayPush;
}}),
"[project]/node_modules/lodash/_getPrototype.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var overArg = __turbopack_context__.r("[project]/node_modules/lodash/_overArg.js [app-ssr] (ecmascript)");
/** Built-in value references. */ var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;
}}),
"[project]/node_modules/lodash/_getSymbolsIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayPush = __turbopack_context__.r("[project]/node_modules/lodash/_arrayPush.js [app-ssr] (ecmascript)"), getPrototype = __turbopack_context__.r("[project]/node_modules/lodash/_getPrototype.js [app-ssr] (ecmascript)"), getSymbols = __turbopack_context__.r("[project]/node_modules/lodash/_getSymbols.js [app-ssr] (ecmascript)"), stubArray = __turbopack_context__.r("[project]/node_modules/lodash/stubArray.js [app-ssr] (ecmascript)");
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while(object){
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
module.exports = getSymbolsIn;
}}),
"[project]/node_modules/lodash/_copySymbolsIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var copyObject = __turbopack_context__.r("[project]/node_modules/lodash/_copyObject.js [app-ssr] (ecmascript)"), getSymbolsIn = __turbopack_context__.r("[project]/node_modules/lodash/_getSymbolsIn.js [app-ssr] (ecmascript)");
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
}
module.exports = copySymbolsIn;
}}),
"[project]/node_modules/lodash/_baseGetAllKeys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var arrayPush = __turbopack_context__.r("[project]/node_modules/lodash/_arrayPush.js [app-ssr] (ecmascript)"), isArray = __turbopack_context__.r("[project]/node_modules/lodash/isArray.js [app-ssr] (ecmascript)");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
module.exports = baseGetAllKeys;
}}),
"[project]/node_modules/lodash/_getAllKeys.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseGetAllKeys = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetAllKeys.js [app-ssr] (ecmascript)"), getSymbols = __turbopack_context__.r("[project]/node_modules/lodash/_getSymbols.js [app-ssr] (ecmascript)"), keys = __turbopack_context__.r("[project]/node_modules/lodash/keys.js [app-ssr] (ecmascript)");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
module.exports = getAllKeys;
}}),
"[project]/node_modules/lodash/_getAllKeysIn.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseGetAllKeys = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetAllKeys.js [app-ssr] (ecmascript)"), getSymbolsIn = __turbopack_context__.r("[project]/node_modules/lodash/_getSymbolsIn.js [app-ssr] (ecmascript)"), keysIn = __turbopack_context__.r("[project]/node_modules/lodash/keysIn.js [app-ssr] (ecmascript)");
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
module.exports = getAllKeysIn;
}}),
"[project]/node_modules/lodash/_DataView.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)"), root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView');
module.exports = DataView;
}}),
"[project]/node_modules/lodash/_Promise.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)"), root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var Promise = getNative(root, 'Promise');
module.exports = Promise;
}}),
"[project]/node_modules/lodash/_Set.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)"), root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var Set = getNative(root, 'Set');
module.exports = Set;
}}),
"[project]/node_modules/lodash/_WeakMap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getNative = __turbopack_context__.r("[project]/node_modules/lodash/_getNative.js [app-ssr] (ecmascript)"), root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/* Built-in method references that are verified to be native. */ var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;
}}),
"[project]/node_modules/lodash/_getTag.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var DataView = __turbopack_context__.r("[project]/node_modules/lodash/_DataView.js [app-ssr] (ecmascript)"), Map = __turbopack_context__.r("[project]/node_modules/lodash/_Map.js [app-ssr] (ecmascript)"), Promise = __turbopack_context__.r("[project]/node_modules/lodash/_Promise.js [app-ssr] (ecmascript)"), Set = __turbopack_context__.r("[project]/node_modules/lodash/_Set.js [app-ssr] (ecmascript)"), WeakMap = __turbopack_context__.r("[project]/node_modules/lodash/_WeakMap.js [app-ssr] (ecmascript)"), baseGetTag = __turbopack_context__.r("[project]/node_modules/lodash/_baseGetTag.js [app-ssr] (ecmascript)"), toSource = __turbopack_context__.r("[project]/node_modules/lodash/_toSource.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
    getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}
module.exports = getTag;
}}),
"[project]/node_modules/lodash/_initCloneArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = new array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
module.exports = initCloneArray;
}}),
"[project]/node_modules/lodash/_Uint8Array.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var root = __turbopack_context__.r("[project]/node_modules/lodash/_root.js [app-ssr] (ecmascript)");
/** Built-in value references. */ var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;
}}),
"[project]/node_modules/lodash/_cloneArrayBuffer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Uint8Array = __turbopack_context__.r("[project]/node_modules/lodash/_Uint8Array.js [app-ssr] (ecmascript)");
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
module.exports = cloneArrayBuffer;
}}),
"[project]/node_modules/lodash/_cloneDataView.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var cloneArrayBuffer = __turbopack_context__.r("[project]/node_modules/lodash/_cloneArrayBuffer.js [app-ssr] (ecmascript)");
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
module.exports = cloneDataView;
}}),
"[project]/node_modules/lodash/_cloneRegExp.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
module.exports = cloneRegExp;
}}),
"[project]/node_modules/lodash/_cloneSymbol.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Symbol = __turbopack_context__.r("[project]/node_modules/lodash/_Symbol.js [app-ssr] (ecmascript)");
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
module.exports = cloneSymbol;
}}),
"[project]/node_modules/lodash/_cloneTypedArray.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var cloneArrayBuffer = __turbopack_context__.r("[project]/node_modules/lodash/_cloneArrayBuffer.js [app-ssr] (ecmascript)");
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
module.exports = cloneTypedArray;
}}),
"[project]/node_modules/lodash/_initCloneByTag.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var cloneArrayBuffer = __turbopack_context__.r("[project]/node_modules/lodash/_cloneArrayBuffer.js [app-ssr] (ecmascript)"), cloneDataView = __turbopack_context__.r("[project]/node_modules/lodash/_cloneDataView.js [app-ssr] (ecmascript)"), cloneRegExp = __turbopack_context__.r("[project]/node_modules/lodash/_cloneRegExp.js [app-ssr] (ecmascript)"), cloneSymbol = __turbopack_context__.r("[project]/node_modules/lodash/_cloneSymbol.js [app-ssr] (ecmascript)"), cloneTypedArray = __turbopack_context__.r("[project]/node_modules/lodash/_cloneTypedArray.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return new Ctor;
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return new Ctor;
        case symbolTag:
            return cloneSymbol(object);
    }
}
module.exports = initCloneByTag;
}}),
"[project]/node_modules/lodash/_baseCreate.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)");
/** Built-in value references. */ var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */ var baseCreate = function() {
    function object() {}
    return function(proto) {
        if (!isObject(proto)) {
            return {};
        }
        if (objectCreate) {
            return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
    };
}();
module.exports = baseCreate;
}}),
"[project]/node_modules/lodash/_initCloneObject.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseCreate = __turbopack_context__.r("[project]/node_modules/lodash/_baseCreate.js [app-ssr] (ecmascript)"), getPrototype = __turbopack_context__.r("[project]/node_modules/lodash/_getPrototype.js [app-ssr] (ecmascript)"), isPrototype = __turbopack_context__.r("[project]/node_modules/lodash/_isPrototype.js [app-ssr] (ecmascript)");
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
module.exports = initCloneObject;
}}),
"[project]/node_modules/lodash/_baseIsMap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getTag = __turbopack_context__.r("[project]/node_modules/lodash/_getTag.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */ function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
}
module.exports = baseIsMap;
}}),
"[project]/node_modules/lodash/isMap.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseIsMap = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsMap.js [app-ssr] (ecmascript)"), baseUnary = __turbopack_context__.r("[project]/node_modules/lodash/_baseUnary.js [app-ssr] (ecmascript)"), nodeUtil = __turbopack_context__.r("[project]/node_modules/lodash/_nodeUtil.js [app-ssr] (ecmascript)");
/* Node.js helper references. */ var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */ var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;
}}),
"[project]/node_modules/lodash/_baseIsSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var getTag = __turbopack_context__.r("[project]/node_modules/lodash/_getTag.js [app-ssr] (ecmascript)"), isObjectLike = __turbopack_context__.r("[project]/node_modules/lodash/isObjectLike.js [app-ssr] (ecmascript)");
/** `Object#toString` result references. */ var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */ function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
}
module.exports = baseIsSet;
}}),
"[project]/node_modules/lodash/isSet.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseIsSet = __turbopack_context__.r("[project]/node_modules/lodash/_baseIsSet.js [app-ssr] (ecmascript)"), baseUnary = __turbopack_context__.r("[project]/node_modules/lodash/_baseUnary.js [app-ssr] (ecmascript)"), nodeUtil = __turbopack_context__.r("[project]/node_modules/lodash/_nodeUtil.js [app-ssr] (ecmascript)");
/* Node.js helper references. */ var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */ var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;
}}),
"[project]/node_modules/lodash/_baseClone.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Stack = __turbopack_context__.r("[project]/node_modules/lodash/_Stack.js [app-ssr] (ecmascript)"), arrayEach = __turbopack_context__.r("[project]/node_modules/lodash/_arrayEach.js [app-ssr] (ecmascript)"), assignValue = __turbopack_context__.r("[project]/node_modules/lodash/_assignValue.js [app-ssr] (ecmascript)"), baseAssign = __turbopack_context__.r("[project]/node_modules/lodash/_baseAssign.js [app-ssr] (ecmascript)"), baseAssignIn = __turbopack_context__.r("[project]/node_modules/lodash/_baseAssignIn.js [app-ssr] (ecmascript)"), cloneBuffer = __turbopack_context__.r("[project]/node_modules/lodash/_cloneBuffer.js [app-ssr] (ecmascript)"), copyArray = __turbopack_context__.r("[project]/node_modules/lodash/_copyArray.js [app-ssr] (ecmascript)"), copySymbols = __turbopack_context__.r("[project]/node_modules/lodash/_copySymbols.js [app-ssr] (ecmascript)"), copySymbolsIn = __turbopack_context__.r("[project]/node_modules/lodash/_copySymbolsIn.js [app-ssr] (ecmascript)"), getAllKeys = __turbopack_context__.r("[project]/node_modules/lodash/_getAllKeys.js [app-ssr] (ecmascript)"), getAllKeysIn = __turbopack_context__.r("[project]/node_modules/lodash/_getAllKeysIn.js [app-ssr] (ecmascript)"), getTag = __turbopack_context__.r("[project]/node_modules/lodash/_getTag.js [app-ssr] (ecmascript)"), initCloneArray = __turbopack_context__.r("[project]/node_modules/lodash/_initCloneArray.js [app-ssr] (ecmascript)"), initCloneByTag = __turbopack_context__.r("[project]/node_modules/lodash/_initCloneByTag.js [app-ssr] (ecmascript)"), initCloneObject = __turbopack_context__.r("[project]/node_modules/lodash/_initCloneObject.js [app-ssr] (ecmascript)"), isArray = __turbopack_context__.r("[project]/node_modules/lodash/isArray.js [app-ssr] (ecmascript)"), isBuffer = __turbopack_context__.r("[project]/node_modules/lodash/isBuffer.js [app-ssr] (ecmascript)"), isMap = __turbopack_context__.r("[project]/node_modules/lodash/isMap.js [app-ssr] (ecmascript)"), isObject = __turbopack_context__.r("[project]/node_modules/lodash/isObject.js [app-ssr] (ecmascript)"), isSet = __turbopack_context__.r("[project]/node_modules/lodash/isSet.js [app-ssr] (ecmascript)"), keys = __turbopack_context__.r("[project]/node_modules/lodash/keys.js [app-ssr] (ecmascript)"), keysIn = __turbopack_context__.r("[project]/node_modules/lodash/keysIn.js [app-ssr] (ecmascript)");
/** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
        return result;
    }
    if (!isObject(value)) {
        return value;
    }
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
            return copyArray(value, result);
        }
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
        } else {
            if (!cloneableTags[tag]) {
                return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
        return stacked;
    }
    stack.set(value, result);
    if (isSet(value)) {
        value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
    } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
            result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
}
module.exports = baseClone;
}}),
"[project]/node_modules/lodash/cloneDeep.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var baseClone = __turbopack_context__.r("[project]/node_modules/lodash/_baseClone.js [app-ssr] (ecmascript)");
/** Used to compose bitmasks for cloning. */ var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */ function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
module.exports = cloneDeep;
}}),

};

//# sourceMappingURL=node_modules_f8791177._.js.map