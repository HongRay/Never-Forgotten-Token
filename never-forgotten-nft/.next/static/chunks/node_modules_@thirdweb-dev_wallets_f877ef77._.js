(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@thirdweb-dev/wallets/dist/errors-9edc08c8.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "A": (()=>AddChainError),
    "C": (()=>ChainNotConfiguredError),
    "P": (()=>ProviderRpcError),
    "R": (()=>ResourceUnavailableError),
    "S": (()=>SwitchChainError),
    "U": (()=>UserRejectedRequestError),
    "a": (()=>ConnectorNotFoundError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js [app-client] (ecmascript)");
;
/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 * @see https://eips.ethereum.org/EIPS/eip-1474
 */ class RpcError extends Error {
    constructor(/** Human-readable string */ message, options){
        const { cause, code, data } = options;
        if (!Number.isInteger(code)) {
            throw new Error('"code" must be an integer.');
        }
        if (!message || typeof message !== "string") {
            throw new Error('"message" must be a nonempty string.');
        }
        super(`${message}. Cause: ${JSON.stringify(cause)}`);
        this.cause = cause;
        this.code = code;
        this.data = data;
    }
}
/**
 * @internal
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * @see https://eips.ethereum.org/EIPS/eip-1193
 */ class ProviderRpcError extends RpcError {
    /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the `1000 <= 4999` range.
   */ constructor(/** Human-readable string */ message, options){
        const { cause, code, data } = options;
        if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) {
            throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
        }
        super(message, {
            cause,
            code,
            data
        });
    }
}
/**
 * @internal
 */ class AddChainError extends Error {
    constructor(){
        super(...arguments);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "AddChainError");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "message", "Error adding chain");
    }
}
/**
 * @internal
 */ class ChainNotConfiguredError extends Error {
    constructor(_ref){
        let { chainId, connectorId } = _ref;
        super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "ChainNotConfigured");
    }
}
class ConnectorNotFoundError extends Error {
    constructor(){
        super(...arguments);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "ConnectorNotFoundError");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "message", "Connector not found");
    }
}
class ResourceUnavailableError extends RpcError {
    constructor(cause){
        super("Resource unavailable", {
            cause,
            code: -32002
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "ResourceUnavailable");
    }
}
/**
 * @internal
 */ class SwitchChainError extends ProviderRpcError {
    constructor(cause){
        super("Error switching chain", {
            cause,
            code: 4902
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "SwitchChainError");
    }
}
/**
 * @internal
 */ class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause){
        super("User rejected request", {
            cause,
            code: 4001
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "UserRejectedRequestError");
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "W": (()=>WagmiConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$chains$2f$dist$2f$thirdweb$2d$dev$2d$chains$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <locals>");
;
;
class WagmiConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"] {
    /** Unique connector id */ /** Connector name */ /** Chains connector supports */ /** Options to use with connector */ /** Whether connector is usable */ constructor(_ref){
        let { chains = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$chains$2f$dist$2f$thirdweb$2d$dev$2d$chains$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defaultChains"], options } = _ref;
        super();
        this.chains = chains;
        this.options = options;
    }
    getBlockExplorerUrls(chain) {
        const explorers = chain.explorers?.map((x)=>x.url) ?? [];
        return explorers.length > 0 ? explorers : undefined;
    }
    isChainUnsupported(chainId) {
        return !this.chains.some((x)=>x.chainId === chainId);
    }
    updateChains(chains) {
        this.chains = chains;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/wallets/evm/connectors/wallet-connect/dist/thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "WalletConnectConnector": (()=>WalletConnectConnector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/defineProperty-350fc508.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$9edc08c8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/errors-9edc08c8.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__providers$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/providers/lib.esm/index.js [app-client] (ecmascript) <export * as providers>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$walletIds$2d$dff6dced$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/walletIds-dff6dced.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$url$2d$a45219bd$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/url-a45219bd.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$WagmiConnector$2d$2f14002d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <module evaluation>");
;
;
;
;
;
;
;
;
const chainsToRequest = new Set([
    1,
    137,
    10,
    42161,
    56
]);
const NAMESPACE = "eip155";
const REQUESTED_CHAINS_KEY = "wagmi.requestedChains";
const ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
const LAST_USED_CHAIN_ID = "last-used-chain-id";
class WalletConnectConnector extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$WagmiConnector$2d$2f14002d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["W"] {
    constructor(config){
        super({
            ...config,
            options: {
                isNewChainsStale: true,
                ...config.options
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "id", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$walletIds$2d$dff6dced$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["w"].walletConnect);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "name", "WalletConnect");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "ready", true);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onAccountsChanged", (accounts)=>{
            if (accounts.length === 0) {
                this.emit("disconnect");
            } else {
                if (accounts[0]) {
                    this.emit("change", {
                        account: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0])
                    });
                }
            }
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onChainChanged", async (chainId)=>{
            const id = Number(chainId);
            const unsupported = this.isChainUnsupported(id);
            await this._storage.setItem(LAST_USED_CHAIN_ID, String(chainId));
            this.emit("change", {
                chain: {
                    id,
                    unsupported
                }
            });
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onDisconnect", async ()=>{
            await this._setRequestedChainsIds([]);
            await this._storage.removeItem(LAST_USED_CHAIN_ID);
            this.emit("disconnect");
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onDisplayUri", (uri)=>{
            this.emit("message", {
                type: "display_uri",
                data: uri
            });
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$defineProperty$2d$350fc508$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, "onConnect", ()=>{
            this.emit("connect", {
                provider: this._provider
            });
        });
        this._storage = config.options.storage;
        this._createProvider();
        this.filteredChains = this.chains.length > 50 ? this.chains.filter((c)=>{
            return chainsToRequest.has(c.chainId);
        }) : this.chains;
        this.showWalletConnectModal = this.options.qrcode !== false;
    }
    async connect() {
        let { chainId: chainIdP, pairingTopic } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        try {
            let targetChainId = chainIdP;
            if (!targetChainId) {
                const lastUsedChainIdStr = await this._storage.getItem(LAST_USED_CHAIN_ID);
                const lastUsedChainId = lastUsedChainIdStr ? parseInt(lastUsedChainIdStr) : undefined;
                if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId)) {
                    targetChainId = lastUsedChainId;
                } else {
                    targetChainId = this.filteredChains[0]?.chainId;
                }
            }
            if (!targetChainId) {
                throw new Error("No chains found on connector.");
            }
            const provider = await this.getProvider();
            this.setupListeners();
            if (provider.session) {
                await provider.disconnect();
                const optionalChains = this.filteredChains.filter((chain)=>chain.chainId !== targetChainId).map((optionalChain)=>optionalChain.chainId);
                this.emit("message", {
                    type: "connecting"
                });
                await provider.connect({
                    pairingTopic,
                    chains: [
                        targetChainId
                    ],
                    optionalChains: optionalChains.length > 0 ? optionalChains : [
                        targetChainId
                    ]
                });
                await this._setRequestedChainsIds(this.filteredChains.map((_ref)=>{
                    let { chainId } = _ref;
                    return chainId;
                }));
            }
            // If session exists and chains are authorized, enable provider for required chain
            const accounts = await provider.enable();
            if (!accounts[0]) {
                throw new Error("No accounts found on provider.");
            }
            const account = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0]);
            const id = await this.getChainId();
            const unsupported = this.isChainUnsupported(id);
            return {
                account,
                chain: {
                    id,
                    unsupported
                },
                provider: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__providers$3e$__["providers"].Web3Provider(provider)
            };
        } catch (error) {
            if (/user rejected/i.test(error?.message)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$9edc08c8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["U"](error);
            }
            throw error;
        }
    }
    async disconnect() {
        const cleanup = ()=>{
            if (typeof localStorage === "undefined") {
                return;
            }
            for(const key in localStorage){
                if (key.startsWith("wc@2")) {
                    localStorage.removeItem(key);
                }
            }
        };
        cleanup();
        const provider = await this.getProvider();
        const disconnectProvider = async ()=>{
            try {
                await provider.disconnect();
            } catch (error) {
                if (!/No matching key/i.test(error.message)) {
                    throw error;
                }
            } finally{
                this._removeListeners();
                await this._setRequestedChainsIds([]);
                cleanup();
            }
        };
        disconnectProvider();
    }
    async getAccount() {
        const { accounts } = await this.getProvider();
        if (!accounts[0]) {
            throw new Error("No accounts found on provider.");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(accounts[0]);
    }
    async getChainId() {
        const { chainId } = await this.getProvider();
        return chainId;
    }
    async getProvider() {
        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (!this._provider) {
            await this._createProvider();
        }
        if (chainId) {
            await this.switchChain(chainId);
        }
        if (!this._provider) {
            throw new Error("No provider found.");
        }
        return this._provider;
    }
    async getSigner() {
        let { chainId } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const [provider, account] = await Promise.all([
            this.getProvider({
                chainId
            }),
            this.getAccount()
        ]);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$providers$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__providers$3e$__["providers"].Web3Provider(provider, chainId).getSigner(account);
    }
    async isAuthorized() {
        try {
            const [account, provider] = await Promise.all([
                this.getAccount(),
                this.getProvider()
            ]);
            const isChainsStale = await this._isChainsStale();
            // If an account does not exist on the session, then the connector is unauthorized.
            if (!account) {
                return false;
            }
            // If the chains are stale on the session, then the connector is unauthorized.
            if (isChainsStale && provider.session) {
                try {
                    await provider.disconnect();
                } catch  {} // eslint-disable-line no-empty
                return false;
            }
            return true;
        } catch  {
            return false;
        }
    }
    async switchChain(chainId) {
        const chain = this.chains.find((chain_)=>chain_.chainId === chainId);
        if (!chain) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$9edc08c8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"](`Chain with ID: ${chainId}, not found on connector.`);
        }
        try {
            const provider = await this.getProvider();
            const namespaceChains = this._getNamespaceChainsIds();
            const namespaceMethods = this._getNamespaceMethods();
            const isChainApproved = namespaceChains.includes(chainId);
            if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
                const firstExplorer = chain.explorers && chain.explorers[0];
                const blockExplorerUrls = firstExplorer ? {
                    blockExplorerUrls: [
                        firstExplorer.url
                    ]
                } : {};
                await provider.request({
                    method: ADD_ETH_CHAIN_METHOD,
                    params: [
                        {
                            chainId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexValue(chain.chainId),
                            chainName: chain.name,
                            nativeCurrency: chain.nativeCurrency,
                            rpcUrls: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$url$2d$a45219bd$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(chain),
                            // no clientId on purpose
                            ...blockExplorerUrls
                        }
                    ]
                });
                const requestedChains = await this._getRequestedChainsIds();
                requestedChains.push(chainId);
                await this._setRequestedChainsIds(requestedChains);
            }
            await provider.request({
                method: "wallet_switchEthereumChain",
                params: [
                    {
                        chainId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexValue(chainId)
                    }
                ]
            });
            return chain;
        } catch (error) {
            const message = typeof error === "string" ? error : error?.message;
            if (/user rejected request/i.test(message)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$9edc08c8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["U"](error);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$errors$2d$9edc08c8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"](error);
        }
    }
    async _createProvider() {
        if (!this._initProviderPromise && "object" !== "undefined") {
            this._initProviderPromise = this.initProvider();
        }
        return this._initProviderPromise;
    }
    async initProvider() {
        const { default: EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await __turbopack_context__.r("[project]/node_modules/@walletconnect/ethereum-provider/dist/index.es.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i);
        const [defaultChain, ...optionalChains] = this.filteredChains.map((_ref2)=>{
            let { chainId } = _ref2;
            return chainId;
        });
        if (defaultChain) {
            // EthereumProvider populates & deduplicates required methods and events internally
            this._provider = await EthereumProvider.init({
                showQrModal: this.showWalletConnectModal,
                projectId: this.options.projectId,
                methods: [
                    "eth_sendTransaction",
                    "personal_sign",
                    "eth_signTypedData_v4"
                ],
                optionalMethods: OPTIONAL_METHODS,
                optionalEvents: OPTIONAL_EVENTS,
                chains: [
                    defaultChain
                ],
                optionalChains: optionalChains,
                metadata: {
                    name: this.options.dappMetadata.name,
                    description: this.options.dappMetadata.description || "",
                    url: this.options.dappMetadata.url,
                    icons: [
                        this.options.dappMetadata.logoUrl || ""
                    ]
                },
                rpcMap: Object.fromEntries(this.filteredChains.map((chain)=>[
                        chain.chainId,
                        chain.rpc[0] || "" // TODO: handle chain.rpc being empty array
                    ])),
                qrModalOptions: this.options.qrModalOptions
            });
        }
    }
    /**
   * Checks if the target chains match the chains that were
   * initially requested by the connector for the WalletConnect session.
   * If there is a mismatch, this means that the chains on the connector
   * are considered stale, and need to be revalidated at a later point (via
   * connection).
   *
   * There may be a scenario where a dapp adds a chain to the
   * connector later on, however, this chain will not have been approved or rejected
   * by the wallet. In this case, the chain is considered stale.
   *
   * There are exceptions however:
   * -  If the wallet supports dynamic chain addition via `eth_addEthereumChain`,
   *    then the chain is not considered stale.
   * -  If the `isNewChainsStale` flag is falsy on the connector, then the chain is
   *    not considered stale.
   *
   * For the above cases, chain validation occurs dynamically when the user
   * attempts to switch chain.
   *
   * Also check that dapp supports at least 1 chain from previously approved session.
   */ async _isChainsStale() {
        const namespaceMethods = this._getNamespaceMethods();
        if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
            return false;
        }
        if (!this.options.isNewChainsStale) {
            return false;
        }
        const requestedChains = await this._getRequestedChainsIds();
        const connectorChains = this.filteredChains.map((_ref3)=>{
            let { chainId } = _ref3;
            return chainId;
        });
        const namespaceChains = this._getNamespaceChainsIds();
        if (namespaceChains.length && !namespaceChains.some((id)=>connectorChains.includes(id))) {
            return false;
        }
        return !connectorChains.every((id)=>requestedChains.includes(id));
    }
    async setupListeners() {
        if (!this._provider) {
            return;
        }
        this._removeListeners();
        this._provider.on("accountsChanged", this.onAccountsChanged);
        this._provider.on("chainChanged", this.onChainChanged);
        this._provider.on("disconnect", this.onDisconnect);
        this._provider.on("session_delete", this.onDisconnect);
        this._provider.on("display_uri", this.onDisplayUri);
        this._provider.on("connect", this.onConnect);
    }
    _removeListeners() {
        if (!this._provider) {
            return;
        }
        this._provider.removeListener("accountsChanged", this.onAccountsChanged);
        this._provider.removeListener("chainChanged", this.onChainChanged);
        this._provider.removeListener("disconnect", this.onDisconnect);
        this._provider.removeListener("session_delete", this.onDisconnect);
        this._provider.removeListener("display_uri", this.onDisplayUri);
        this._provider.removeListener("connect", this.onConnect);
    }
    async _setRequestedChainsIds(chains) {
        await this._storage.setItem(REQUESTED_CHAINS_KEY, JSON.stringify(chains));
    }
    async _getRequestedChainsIds() {
        const data = await this._storage.getItem(REQUESTED_CHAINS_KEY);
        return data ? JSON.parse(data) : [];
    }
    _getNamespaceChainsIds() {
        if (!this._provider) {
            return [];
        }
        const chainIds = this._provider.session?.namespaces[NAMESPACE]?.chains?.map((chain)=>parseInt(chain.split(":")[1] || ""));
        return chainIds ?? [];
    }
    _getNamespaceMethods() {
        if (!this._provider) {
            return [];
        }
        const methods = this._provider.session?.namespaces[NAMESPACE]?.methods;
        return methods ?? [];
    }
}
;
}}),
}]);

//# sourceMappingURL=node_modules_%40thirdweb-dev_wallets_f877ef77._.js.map