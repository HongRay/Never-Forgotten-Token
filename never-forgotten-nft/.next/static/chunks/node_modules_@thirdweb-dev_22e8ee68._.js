(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryClientProvider": (()=>QueryClientProvider),
    "defaultContext": (()=>defaultContext),
    "useQueryClient": (()=>useQueryClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const defaultContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(undefined);
const QueryClientSharingContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false); // If we are given a context, we will use it.
// Otherwise, if contextSharing is on, we share the first and at least one
// instance of the context across the window
// to ensure that if React Query is used across
// different bundles or microfrontends they will
// all use the same **instance** of context, regardless
// of module scoping.
function getQueryClientContext(context, contextSharing) {
    if (context) {
        return context;
    }
    if (contextSharing && typeof window !== 'undefined') {
        if (!window.ReactQueryClientContext) {
            window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
    }
    return defaultContext;
}
const useQueryClient = ({ context } = {})=>{
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(getQueryClientContext(context, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(QueryClientSharingContext)));
    if (!queryClient) {
        throw new Error('No QueryClient set, use QueryClientProvider to set one');
    }
    return queryClient;
};
const QueryClientProvider = ({ client, children, context, contextSharing = false })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "QueryClientProvider.useEffect": ()=>{
            client.mount();
            return ({
                "QueryClientProvider.useEffect": ()=>{
                    client.unmount();
                }
            })["QueryClientProvider.useEffect"];
        }
    }["QueryClientProvider.useEffect"], [
        client
    ]);
    if (("TURBOPACK compile-time value", "development") !== 'production' && contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
    }
    const Context = getQueryClientContext(context, contextSharing);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
    }, /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(Context.Provider, {
        value: client
    }, children));
};
;
 //# sourceMappingURL=QueryClientProvider.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useSyncExternalStore": (()=>useSyncExternalStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)");
'use client';
;
const useSyncExternalStore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"];
;
 //# sourceMappingURL=useSyncExternalStore.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "shouldThrowError": (()=>shouldThrowError)
});
function shouldThrowError(_useErrorBoundary, params) {
    // Allow useErrorBoundary function to override throwing behavior on a per-error basis
    if (typeof _useErrorBoundary === 'function') {
        return _useErrorBoundary(...params);
    }
    return !!_useErrorBoundary;
}
;
 //# sourceMappingURL=utils.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useMutation.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useMutation": (()=>useMutation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/notifyManager.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)");
'use client';
;
;
;
;
;
function useMutation(arg1, arg2, arg3) {
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMutationArgs"])(arg1, arg2, arg3);
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])({
        context: options.context
    });
    const [observer] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useMutation.useState": ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutationObserver"](queryClient, options)
    }["useMutation.useState"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useMutation.useEffect": ()=>{
            observer.setOptions(options);
        }
    }["useMutation.useEffect"], [
        observer,
        options
    ]);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMutation.useSyncExternalStore[result]": (onStoreChange)=>observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange))
    }["useMutation.useSyncExternalStore[result]"], [
        observer
    ]), {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"], {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"]);
    const mutate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMutation.useCallback[mutate]": (variables, mutateOptions)=>{
            observer.mutate(variables, mutateOptions).catch(noop);
        }
    }["useMutation.useCallback[mutate]"], [
        observer
    ]);
    if (result.error && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(observer.options.useErrorBoundary, [
        result.error
    ])) {
        throw result.error;
    }
    return {
        ...result,
        mutate,
        mutateAsync: result.mutate
    };
} // eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
;
 //# sourceMappingURL=useMutation.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryErrorResetBoundary": (()=>QueryErrorResetBoundary),
    "useQueryErrorResetBoundary": (()=>useQueryErrorResetBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
function createValue() {
    let isReset = false;
    return {
        clearReset: ()=>{
            isReset = false;
        },
        reset: ()=>{
            isReset = true;
        },
        isReset: ()=>{
            return isReset;
        }
    };
}
const QueryErrorResetBoundaryContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(createValue()); // HOOK
const useQueryErrorResetBoundary = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(QueryErrorResetBoundaryContext); // COMPONENT
const QueryErrorResetBoundary = ({ children })=>{
    const [value] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "QueryErrorResetBoundary.useState": ()=>createValue()
    }["QueryErrorResetBoundary.useState"]);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(QueryErrorResetBoundaryContext.Provider, {
        value: value
    }, typeof children === 'function' ? children(value) : children);
};
;
 //# sourceMappingURL=QueryErrorResetBoundary.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/isRestoring.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IsRestoringProvider": (()=>IsRestoringProvider),
    "useIsRestoring": (()=>useIsRestoring)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const IsRestoringContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
const useIsRestoring = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(IsRestoringContext);
const IsRestoringProvider = IsRestoringContext.Provider;
;
 //# sourceMappingURL=isRestoring.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ensurePreventErrorBoundaryRetry": (()=>ensurePreventErrorBoundaryRetry),
    "getHasError": (()=>getHasError),
    "useClearResetErrorBoundary": (()=>useClearResetErrorBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)");
'use client';
;
;
const ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{
    if (options.suspense || options.useErrorBoundary) {
        // Prevent retrying failed query if the error boundary has not been reset yet
        if (!errorResetBoundary.isReset()) {
            options.retryOnMount = false;
        }
    }
};
const useClearResetErrorBoundary = (errorResetBoundary)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useClearResetErrorBoundary.useEffect": ()=>{
            errorResetBoundary.clearReset();
        }
    }["useClearResetErrorBoundary.useEffect"], [
        errorResetBoundary
    ]);
};
const getHasError = ({ result, errorResetBoundary, useErrorBoundary, query })=>{
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(useErrorBoundary, [
        result.error,
        query
    ]);
};
;
 //# sourceMappingURL=errorBoundaryUtils.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/suspense.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ensureStaleTime": (()=>ensureStaleTime),
    "fetchOptimistic": (()=>fetchOptimistic),
    "shouldSuspend": (()=>shouldSuspend),
    "willFetch": (()=>willFetch)
});
const ensureStaleTime = (defaultedOptions)=>{
    if (defaultedOptions.suspense) {
        // Always set stale time when using suspense to prevent
        // fetching again when directly mounting after suspending
        if (typeof defaultedOptions.staleTime !== 'number') {
            defaultedOptions.staleTime = 1000;
        }
    }
};
const willFetch = (result, isRestoring)=>result.isLoading && result.isFetching && !isRestoring;
const shouldSuspend = (defaultedOptions, result, isRestoring)=>(defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary)=>observer.fetchOptimistic(defaultedOptions).then(({ data })=>{
        defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error)=>{
        errorResetBoundary.clearReset();
        defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);
    });
;
 //# sourceMappingURL=suspense.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useBaseQuery": (()=>useBaseQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/notifyManager.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryErrorResetBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$isRestoring$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/isRestoring.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/suspense.mjs [app-client] (ecmascript)");
'use client';
;
;
;
;
;
;
;
;
function useBaseQuery(options, Observer) {
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])({
        context: options.context
    });
    const isRestoring = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$isRestoring$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIsRestoring"])();
    const errorResetBoundary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryErrorResetBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryErrorResetBoundary"])();
    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options
    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
    if (defaultedOptions.onError) {
        defaultedOptions.onError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onError);
    }
    if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSuccess);
    }
    if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSettled);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensureStaleTime"])(defaultedOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensurePreventErrorBoundaryRetry"])(defaultedOptions, errorResetBoundary);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useClearResetErrorBoundary"])(errorResetBoundary);
    const [observer] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useBaseQuery.useState": ()=>new Observer(queryClient, defaultedOptions)
    }["useBaseQuery.useState"]);
    const result = observer.getOptimisticResult(defaultedOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useBaseQuery.useSyncExternalStore.useCallback": (onStoreChange)=>{
            const unsubscribe = isRestoring ? ({
                "useBaseQuery.useSyncExternalStore.useCallback": ()=>undefined
            })["useBaseQuery.useSyncExternalStore.useCallback"] : observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange)); // Update result to make sure we did not miss any query updates
            // between creating the observer and subscribing to it.
            observer.updateResult();
            return unsubscribe;
        }
    }["useBaseQuery.useSyncExternalStore.useCallback"], [
        observer,
        isRestoring
    ]), {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"], {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useBaseQuery.useEffect": ()=>{
            // Do not notify on updates because of changes in the options because
            // these changes should already be reflected in the optimistic result.
            observer.setOptions(defaultedOptions, {
                listeners: false
            });
        }
    }["useBaseQuery.useEffect"], [
        defaultedOptions,
        observer
    ]); // Handle suspense
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldSuspend"])(defaultedOptions, result, isRestoring)) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchOptimistic"])(defaultedOptions, observer, errorResetBoundary);
    } // Handle error boundary
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHasError"])({
        result,
        errorResetBoundary,
        useErrorBoundary: defaultedOptions.useErrorBoundary,
        query: observer.getCurrentQuery()
    })) {
        throw result.error;
    } // Handle result property usage tracking
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
;
 //# sourceMappingURL=useBaseQuery.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useQuery.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useQuery": (()=>useQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$queryObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/queryObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useBaseQuery$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs [app-client] (ecmascript)");
'use client';
;
;
function useQuery(arg1, arg2, arg3) {
    const parsedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseQueryArgs"])(arg1, arg2, arg3);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useBaseQuery$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useBaseQuery"])(parsedOptions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$queryObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QueryObserver"]);
}
;
 //# sourceMappingURL=useQuery.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useSyncExternalStore": (()=>useSyncExternalStore)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/use-sync-external-store/shim/index.js [app-client] (ecmascript)");
'use client';
;
const useSyncExternalStore = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$use$2d$sync$2d$external$2d$store$2f$shim$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"];
;
 //# sourceMappingURL=useSyncExternalStore.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryErrorResetBoundary": (()=>QueryErrorResetBoundary),
    "useQueryErrorResetBoundary": (()=>useQueryErrorResetBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
function createValue() {
    let isReset = false;
    return {
        clearReset: ()=>{
            isReset = false;
        },
        reset: ()=>{
            isReset = true;
        },
        isReset: ()=>{
            return isReset;
        }
    };
}
const QueryErrorResetBoundaryContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(createValue()); // HOOK
const useQueryErrorResetBoundary = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(QueryErrorResetBoundaryContext); // COMPONENT
const QueryErrorResetBoundary = ({ children })=>{
    const [value] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "QueryErrorResetBoundary.useState": ()=>createValue()
    }["QueryErrorResetBoundary.useState"]);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(QueryErrorResetBoundaryContext.Provider, {
        value: value
    }, typeof children === 'function' ? children(value) : children);
};
;
 //# sourceMappingURL=QueryErrorResetBoundary.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryClientProvider": (()=>QueryClientProvider),
    "defaultContext": (()=>defaultContext),
    "useQueryClient": (()=>useQueryClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const defaultContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(undefined);
const QueryClientSharingContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false); // If we are given a context, we will use it.
// Otherwise, if contextSharing is on, we share the first and at least one
// instance of the context across the window
// to ensure that if React Query is used across
// different bundles or microfrontends they will
// all use the same **instance** of context, regardless
// of module scoping.
function getQueryClientContext(context, contextSharing) {
    if (context) {
        return context;
    }
    if (contextSharing && typeof window !== 'undefined') {
        if (!window.ReactQueryClientContext) {
            window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
    }
    return defaultContext;
}
const useQueryClient = ({ context } = {})=>{
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(getQueryClientContext(context, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(QueryClientSharingContext)));
    if (!queryClient) {
        throw new Error('No QueryClient set, use QueryClientProvider to set one');
    }
    return queryClient;
};
const QueryClientProvider = ({ client, children, context, contextSharing = false })=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "QueryClientProvider.useEffect": ()=>{
            client.mount();
            return ({
                "QueryClientProvider.useEffect": ()=>{
                    client.unmount();
                }
            })["QueryClientProvider.useEffect"];
        }
    }["QueryClientProvider.useEffect"], [
        client
    ]);
    if (("TURBOPACK compile-time value", "development") !== 'production' && contextSharing) {
        client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
    }
    const Context = getQueryClientContext(context, contextSharing);
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(QueryClientSharingContext.Provider, {
        value: !context && contextSharing
    }, /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElement"])(Context.Provider, {
        value: client
    }, children));
};
;
 //# sourceMappingURL=QueryClientProvider.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/isRestoring.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "IsRestoringProvider": (()=>IsRestoringProvider),
    "useIsRestoring": (()=>useIsRestoring)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
'use client';
;
const IsRestoringContext = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(false);
const useIsRestoring = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(IsRestoringContext);
const IsRestoringProvider = IsRestoringContext.Provider;
;
 //# sourceMappingURL=isRestoring.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "shouldThrowError": (()=>shouldThrowError)
});
function shouldThrowError(_useErrorBoundary, params) {
    // Allow useErrorBoundary function to override throwing behavior on a per-error basis
    if (typeof _useErrorBoundary === 'function') {
        return _useErrorBoundary(...params);
    }
    return !!_useErrorBoundary;
}
;
 //# sourceMappingURL=utils.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ensurePreventErrorBoundaryRetry": (()=>ensurePreventErrorBoundaryRetry),
    "getHasError": (()=>getHasError),
    "useClearResetErrorBoundary": (()=>useClearResetErrorBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)");
'use client';
;
;
const ensurePreventErrorBoundaryRetry = (options, errorResetBoundary)=>{
    if (options.suspense || options.useErrorBoundary) {
        // Prevent retrying failed query if the error boundary has not been reset yet
        if (!errorResetBoundary.isReset()) {
            options.retryOnMount = false;
        }
    }
};
const useClearResetErrorBoundary = (errorResetBoundary)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useClearResetErrorBoundary.useEffect": ()=>{
            errorResetBoundary.clearReset();
        }
    }["useClearResetErrorBoundary.useEffect"], [
        errorResetBoundary
    ]);
};
const getHasError = ({ result, errorResetBoundary, useErrorBoundary, query })=>{
    return result.isError && !errorResetBoundary.isReset() && !result.isFetching && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(useErrorBoundary, [
        result.error,
        query
    ]);
};
;
 //# sourceMappingURL=errorBoundaryUtils.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/suspense.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ensureStaleTime": (()=>ensureStaleTime),
    "fetchOptimistic": (()=>fetchOptimistic),
    "shouldSuspend": (()=>shouldSuspend),
    "willFetch": (()=>willFetch)
});
const ensureStaleTime = (defaultedOptions)=>{
    if (defaultedOptions.suspense) {
        // Always set stale time when using suspense to prevent
        // fetching again when directly mounting after suspending
        if (typeof defaultedOptions.staleTime !== 'number') {
            defaultedOptions.staleTime = 1000;
        }
    }
};
const willFetch = (result, isRestoring)=>result.isLoading && result.isFetching && !isRestoring;
const shouldSuspend = (defaultedOptions, result, isRestoring)=>(defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary)=>observer.fetchOptimistic(defaultedOptions).then(({ data })=>{
        defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
    }).catch((error)=>{
        errorResetBoundary.clearReset();
        defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
        defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);
    });
;
 //# sourceMappingURL=suspense.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useBaseQuery": (()=>useBaseQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/notifyManager.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryErrorResetBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/QueryErrorResetBoundary.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$isRestoring$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/isRestoring.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/errorBoundaryUtils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/suspense.mjs [app-client] (ecmascript)");
'use client';
;
;
;
;
;
;
;
;
function useBaseQuery(options, Observer) {
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])({
        context: options.context
    });
    const isRestoring = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$isRestoring$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useIsRestoring"])();
    const errorResetBoundary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryErrorResetBoundary$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryErrorResetBoundary"])();
    const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options
    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
    if (defaultedOptions.onError) {
        defaultedOptions.onError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onError);
    }
    if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSuccess);
    }
    if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSettled);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensureStaleTime"])(defaultedOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ensurePreventErrorBoundaryRetry"])(defaultedOptions, errorResetBoundary);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useClearResetErrorBoundary"])(errorResetBoundary);
    const [observer] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useBaseQuery.useState": ()=>new Observer(queryClient, defaultedOptions)
    }["useBaseQuery.useState"]);
    const result = observer.getOptimisticResult(defaultedOptions);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useBaseQuery.useSyncExternalStore.useCallback": (onStoreChange)=>{
            const unsubscribe = isRestoring ? ({
                "useBaseQuery.useSyncExternalStore.useCallback": ()=>undefined
            })["useBaseQuery.useSyncExternalStore.useCallback"] : observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange)); // Update result to make sure we did not miss any query updates
            // between creating the observer and subscribing to it.
            observer.updateResult();
            return unsubscribe;
        }
    }["useBaseQuery.useSyncExternalStore.useCallback"], [
        observer,
        isRestoring
    ]), {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"], {
        "useBaseQuery.useSyncExternalStore": ()=>observer.getCurrentResult()
    }["useBaseQuery.useSyncExternalStore"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useBaseQuery.useEffect": ()=>{
            // Do not notify on updates because of changes in the options because
            // these changes should already be reflected in the optimistic result.
            observer.setOptions(defaultedOptions, {
                listeners: false
            });
        }
    }["useBaseQuery.useEffect"], [
        defaultedOptions,
        observer
    ]); // Handle suspense
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldSuspend"])(defaultedOptions, result, isRestoring)) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$suspense$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchOptimistic"])(defaultedOptions, observer, errorResetBoundary);
    } // Handle error boundary
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$errorBoundaryUtils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHasError"])({
        result,
        errorResetBoundary,
        useErrorBoundary: defaultedOptions.useErrorBoundary,
        query: observer.getCurrentQuery()
    })) {
        throw result.error;
    } // Handle result property usage tracking
    return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
;
 //# sourceMappingURL=useBaseQuery.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useQuery.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useQuery": (()=>useQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$queryObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/queryObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useBaseQuery$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useBaseQuery.mjs [app-client] (ecmascript)");
'use client';
;
;
function useQuery(arg1, arg2, arg3) {
    const parsedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseQueryArgs"])(arg1, arg2, arg3);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useBaseQuery$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useBaseQuery"])(parsedOptions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$queryObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QueryObserver"]);
}
;
 //# sourceMappingURL=useQuery.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useMutation.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useMutation": (()=>useMutation)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@tanstack/query-core/build/lib/notifyManager.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react/node_modules/@tanstack/react-query/build/lib/utils.mjs [app-client] (ecmascript)");
'use client';
;
;
;
;
;
function useMutation(arg1, arg2, arg3) {
    const options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseMutationArgs"])(arg1, arg2, arg3);
    const queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$QueryClientProvider$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])({
        context: options.context
    });
    const [observer] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        "useMutation.useState": ()=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$mutationObserver$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MutationObserver"](queryClient, options)
    }["useMutation.useState"]);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])({
        "useMutation.useEffect": ()=>{
            observer.setOptions(options);
        }
    }["useMutation.useEffect"], [
        observer,
        options
    ]);
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$useSyncExternalStore$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useSyncExternalStore"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMutation.useSyncExternalStore[result]": (onStoreChange)=>observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$tanstack$2f$query$2d$core$2f$build$2f$lib$2f$notifyManager$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(onStoreChange))
    }["useMutation.useSyncExternalStore[result]"], [
        observer
    ]), {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"], {
        "useMutation.useSyncExternalStore[result]": ()=>observer.getCurrentResult()
    }["useMutation.useSyncExternalStore[result]"]);
    const mutate = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])({
        "useMutation.useCallback[mutate]": (variables, mutateOptions)=>{
            observer.mutate(variables, mutateOptions).catch(noop);
        }
    }["useMutation.useCallback[mutate]"], [
        observer
    ]);
    if (result.error && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2f$node_modules$2f40$tanstack$2f$react$2d$query$2f$build$2f$lib$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(observer.options.useErrorBoundary, [
        result.error
    ])) {
        throw result.error;
    }
    return {
        ...result,
        mutate,
        mutateAsync: result.mutate
    };
} // eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() {}
;
 //# sourceMappingURL=useMutation.mjs.map
}}),
"[project]/node_modules/@thirdweb-dev/crypto/node_modules/js-sha3/src/sha3.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.9.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2023
 * @license MIT
 */ /*jslint bitwise: true */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(function() {
    'use strict';
    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node;
    if (NODE_JS) {
        root = global;
    } else if (WEB_WORKER) {
        root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && ("TURBOPACK compile-time value", "object") === 'object' && module.exports;
    var AMD = typeof define === 'function' && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [
        31,
        7936,
        2031616,
        520093696
    ];
    var CSHAKE_PADDING = [
        4,
        1024,
        262144,
        67108864
    ];
    var KECCAK_PADDING = [
        1,
        256,
        65536,
        16777216
    ];
    var PADDING = [
        6,
        1536,
        393216,
        100663296
    ];
    var SHIFT = [
        0,
        8,
        16,
        24
    ];
    var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
    ];
    var BITS = [
        224,
        256,
        384,
        512
    ];
    var SHAKE_BITS = [
        128,
        256
    ];
    var OUTPUT_TYPES = [
        'hex',
        'buffer',
        'arrayBuffer',
        'array',
        'digest'
    ];
    var CSHAKE_BYTEPAD = {
        '128': 168,
        '256': 136
    };
    var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    } : Array.isArray;
    var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
        return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    } : ArrayBuffer.isView;
    // [message: string, isString: bool]
    var formatMessage = function(message) {
        var type = typeof message;
        if (type === 'string') {
            return [
                message,
                true
            ];
        }
        if (type !== 'object' || message === null) {
            throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            return [
                new Uint8Array(message),
                false
            ];
        }
        if (!isArray(message) && !isView(message)) {
            throw new Error(INPUT_ERROR);
        }
        return [
            message,
            false
        ];
    };
    var empty = function(message) {
        return formatMessage(message)[0].length === 0;
    };
    var cloneArray = function(array) {
        var newArray = [];
        for(var i = 0; i < array.length; ++i){
            newArray[i] = array[i];
        }
        return newArray;
    };
    var createOutputMethod = function(bits, padding, outputType) {
        return function(message) {
            return new Keccak(bits, padding, bits).update(message)[outputType]();
        };
    };
    var createShakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits) {
            return new Keccak(bits, padding, outputBits).update(message)[outputType]();
        };
    };
    var createCshakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits, n, s) {
            return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
        };
    };
    var createKmacOutputMethod = function(bits, padding, outputType) {
        return function(key, message, outputBits, s) {
            return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
        };
    };
    var createOutputMethods = function(method, createMethod, bits, padding) {
        for(var i = 0; i < OUTPUT_TYPES.length; ++i){
            var type = OUTPUT_TYPES[i];
            method[type] = createMethod(bits, padding, type);
        }
        return method;
    };
    var createMethod = function(bits, padding) {
        var method = createOutputMethod(bits, padding, 'hex');
        method.create = function() {
            return new Keccak(bits, padding, bits);
        };
        method.update = function(message) {
            return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function(bits, padding) {
        var method = createShakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits) {
            return new Keccak(bits, padding, outputBits);
        };
        method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createCshakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits, n, s) {
            if (empty(n) && empty(s)) {
                return methods['shake' + bits].create(outputBits);
            } else {
                return new Keccak(bits, padding, outputBits).bytepad([
                    n,
                    s
                ], w);
            }
        };
        method.update = function(message, outputBits, n, s) {
            return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createKmacOutputMethod(bits, padding, 'hex');
        method.create = function(key, outputBits, s) {
            return new Kmac(bits, padding, outputBits).bytepad([
                'KMAC',
                s
            ], w).bytepad([
                key
            ], w);
        };
        method.update = function(key, message, outputBits, s) {
            return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [
        {
            name: 'keccak',
            padding: KECCAK_PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'sha3',
            padding: PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'shake',
            padding: SHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createShakeMethod
        },
        {
            name: 'cshake',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createCshakeMethod
        },
        {
            name: 'kmac',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createKmacMethod
        }
    ];
    var methods = {}, methodNames = [];
    for(var i = 0; i < algorithms.length; ++i){
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for(var j = 0; j < bits.length; ++j){
            var methodName = algorithm.name + '_' + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
            if (algorithm.name !== 'sha3') {
                var newMethodName = algorithm.name + bits[j];
                methodNames.push(newMethodName);
                methods[newMethodName] = methods[methodName];
            }
        }
    }
    function Keccak(bits, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for(var i = 0; i < 50; ++i){
            this.s[i] = 0;
        }
    }
    Keccak.prototype.update = function(message) {
        if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i, code;
        while(index < length){
            if (this.reset) {
                this.reset = false;
                blocks[0] = this.block;
                for(i = 1; i < blockCount + 1; ++i){
                    blocks[i] = 0;
                }
            }
            if (isString) {
                for(i = this.start; index < length && i < byteCount; ++index){
                    code = message.charCodeAt(index);
                    if (code < 0x80) {
                        blocks[i >> 2] |= code << SHIFT[i++ & 3];
                    } else if (code < 0x800) {
                        blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else if (code < 0xd800 || code >= 0xe000) {
                        blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else {
                        code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                        blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    }
                }
            } else {
                for(i = this.start; index < length && i < byteCount; ++index){
                    blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
                }
            }
            this.lastByteIndex = i;
            if (i >= byteCount) {
                this.start = i - byteCount;
                this.block = blocks[blockCount];
                for(i = 0; i < blockCount; ++i){
                    s[i] ^= blocks[i];
                }
                f(s);
                this.reset = true;
            } else {
                this.start = i;
            }
        }
        return this;
    };
    Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [
            o
        ];
        x = x >> 8;
        o = x & 255;
        while(o > 0){
            bytes.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
        }
        if (right) {
            bytes.push(n);
        } else {
            bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
        var result = formatMessage(str);
        str = result[0];
        var isString = result[1];
        var bytes = 0, length = str.length;
        if (isString) {
            for(var i = 0; i < str.length; ++i){
                var code = str.charCodeAt(i);
                if (code < 0x80) {
                    bytes += 1;
                } else if (code < 0x800) {
                    bytes += 2;
                } else if (code < 0xd800 || code >= 0xe000) {
                    bytes += 3;
                } else {
                    code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
                    bytes += 4;
                }
            }
        } else {
            bytes = length;
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for(var i = 0; i < strs.length; ++i){
            bytes += this.encodeString(strs[i]);
        }
        var paddingBytes = (w - bytes % w) % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
    };
    Keccak.prototype.finalize = function() {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i >> 2] |= this.padding[i & 3];
        if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for(i = 1; i < blockCount + 1; ++i){
                blocks[i] = 0;
            }
        }
        blocks[blockCount - 1] |= 0x80000000;
        for(i = 0; i < blockCount; ++i){
            s[i] ^= blocks[i];
        }
        f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var hex = '', block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                block = s[i];
                hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
            }
            if (j % blockCount === 0) {
                s = cloneArray(s);
                f(s);
                i = 0;
            }
        }
        if (extraBytes) {
            block = s[i];
            hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
            if (extraBytes > 1) {
                hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
            }
            if (extraBytes > 2) {
                hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
            }
        }
        return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
            buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                array[j] = s[i];
            }
            if (j % blockCount === 0) {
                s = cloneArray(s);
                f(s);
            }
        }
        if (extraBytes) {
            array[j] = s[i];
            buffer = buffer.slice(0, bytes);
        }
        return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var array = [], offset, block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                offset = j << 2;
                block = s[i];
                array[offset] = block & 0xFF;
                array[offset + 1] = block >> 8 & 0xFF;
                array[offset + 2] = block >> 16 & 0xFF;
                array[offset + 3] = block >> 24 & 0xFF;
            }
            if (j % blockCount === 0) {
                s = cloneArray(s);
                f(s);
            }
        }
        if (extraBytes) {
            offset = j << 2;
            block = s[i];
            array[offset] = block & 0xFF;
            if (extraBytes > 1) {
                array[offset + 1] = block >> 8 & 0xFF;
            }
            if (extraBytes > 2) {
                array[offset + 2] = block >> 16 & 0xFF;
            }
        }
        return array;
    };
    function Kmac(bits, padding, outputBits) {
        Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for(n = 0; n < 48; n += 2){
            c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
            c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
            c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
            c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
            c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
            c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
            c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
            c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
            c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
            c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s[0] ^= h;
            s[1] ^= l;
            s[10] ^= h;
            s[11] ^= l;
            s[20] ^= h;
            s[21] ^= l;
            s[30] ^= h;
            s[31] ^= l;
            s[40] ^= h;
            s[41] ^= l;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s[2] ^= h;
            s[3] ^= l;
            s[12] ^= h;
            s[13] ^= l;
            s[22] ^= h;
            s[23] ^= l;
            s[32] ^= h;
            s[33] ^= l;
            s[42] ^= h;
            s[43] ^= l;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s[4] ^= h;
            s[5] ^= l;
            s[14] ^= h;
            s[15] ^= l;
            s[24] ^= h;
            s[25] ^= l;
            s[34] ^= h;
            s[35] ^= l;
            s[44] ^= h;
            s[45] ^= l;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s[6] ^= h;
            s[7] ^= l;
            s[16] ^= h;
            s[17] ^= l;
            s[26] ^= h;
            s[27] ^= l;
            s[36] ^= h;
            s[37] ^= l;
            s[46] ^= h;
            s[47] ^= l;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s[8] ^= h;
            s[9] ^= l;
            s[18] ^= h;
            s[19] ^= l;
            s[28] ^= h;
            s[29] ^= l;
            s[38] ^= h;
            s[39] ^= l;
            s[48] ^= h;
            s[49] ^= l;
            b0 = s[0];
            b1 = s[1];
            b32 = s[11] << 4 | s[10] >>> 28;
            b33 = s[10] << 4 | s[11] >>> 28;
            b14 = s[20] << 3 | s[21] >>> 29;
            b15 = s[21] << 3 | s[20] >>> 29;
            b46 = s[31] << 9 | s[30] >>> 23;
            b47 = s[30] << 9 | s[31] >>> 23;
            b28 = s[40] << 18 | s[41] >>> 14;
            b29 = s[41] << 18 | s[40] >>> 14;
            b20 = s[2] << 1 | s[3] >>> 31;
            b21 = s[3] << 1 | s[2] >>> 31;
            b2 = s[13] << 12 | s[12] >>> 20;
            b3 = s[12] << 12 | s[13] >>> 20;
            b34 = s[22] << 10 | s[23] >>> 22;
            b35 = s[23] << 10 | s[22] >>> 22;
            b16 = s[33] << 13 | s[32] >>> 19;
            b17 = s[32] << 13 | s[33] >>> 19;
            b48 = s[42] << 2 | s[43] >>> 30;
            b49 = s[43] << 2 | s[42] >>> 30;
            b40 = s[5] << 30 | s[4] >>> 2;
            b41 = s[4] << 30 | s[5] >>> 2;
            b22 = s[14] << 6 | s[15] >>> 26;
            b23 = s[15] << 6 | s[14] >>> 26;
            b4 = s[25] << 11 | s[24] >>> 21;
            b5 = s[24] << 11 | s[25] >>> 21;
            b36 = s[34] << 15 | s[35] >>> 17;
            b37 = s[35] << 15 | s[34] >>> 17;
            b18 = s[45] << 29 | s[44] >>> 3;
            b19 = s[44] << 29 | s[45] >>> 3;
            b10 = s[6] << 28 | s[7] >>> 4;
            b11 = s[7] << 28 | s[6] >>> 4;
            b42 = s[17] << 23 | s[16] >>> 9;
            b43 = s[16] << 23 | s[17] >>> 9;
            b24 = s[26] << 25 | s[27] >>> 7;
            b25 = s[27] << 25 | s[26] >>> 7;
            b6 = s[36] << 21 | s[37] >>> 11;
            b7 = s[37] << 21 | s[36] >>> 11;
            b38 = s[47] << 24 | s[46] >>> 8;
            b39 = s[46] << 24 | s[47] >>> 8;
            b30 = s[8] << 27 | s[9] >>> 5;
            b31 = s[9] << 27 | s[8] >>> 5;
            b12 = s[18] << 20 | s[19] >>> 12;
            b13 = s[19] << 20 | s[18] >>> 12;
            b44 = s[29] << 7 | s[28] >>> 25;
            b45 = s[28] << 7 | s[29] >>> 25;
            b26 = s[38] << 8 | s[39] >>> 24;
            b27 = s[39] << 8 | s[38] >>> 24;
            b8 = s[48] << 14 | s[49] >>> 18;
            b9 = s[49] << 14 | s[48] >>> 18;
            s[0] = b0 ^ ~b2 & b4;
            s[1] = b1 ^ ~b3 & b5;
            s[10] = b10 ^ ~b12 & b14;
            s[11] = b11 ^ ~b13 & b15;
            s[20] = b20 ^ ~b22 & b24;
            s[21] = b21 ^ ~b23 & b25;
            s[30] = b30 ^ ~b32 & b34;
            s[31] = b31 ^ ~b33 & b35;
            s[40] = b40 ^ ~b42 & b44;
            s[41] = b41 ^ ~b43 & b45;
            s[2] = b2 ^ ~b4 & b6;
            s[3] = b3 ^ ~b5 & b7;
            s[12] = b12 ^ ~b14 & b16;
            s[13] = b13 ^ ~b15 & b17;
            s[22] = b22 ^ ~b24 & b26;
            s[23] = b23 ^ ~b25 & b27;
            s[32] = b32 ^ ~b34 & b36;
            s[33] = b33 ^ ~b35 & b37;
            s[42] = b42 ^ ~b44 & b46;
            s[43] = b43 ^ ~b45 & b47;
            s[4] = b4 ^ ~b6 & b8;
            s[5] = b5 ^ ~b7 & b9;
            s[14] = b14 ^ ~b16 & b18;
            s[15] = b15 ^ ~b17 & b19;
            s[24] = b24 ^ ~b26 & b28;
            s[25] = b25 ^ ~b27 & b29;
            s[34] = b34 ^ ~b36 & b38;
            s[35] = b35 ^ ~b37 & b39;
            s[44] = b44 ^ ~b46 & b48;
            s[45] = b45 ^ ~b47 & b49;
            s[6] = b6 ^ ~b8 & b0;
            s[7] = b7 ^ ~b9 & b1;
            s[16] = b16 ^ ~b18 & b10;
            s[17] = b17 ^ ~b19 & b11;
            s[26] = b26 ^ ~b28 & b20;
            s[27] = b27 ^ ~b29 & b21;
            s[36] = b36 ^ ~b38 & b30;
            s[37] = b37 ^ ~b39 & b31;
            s[46] = b46 ^ ~b48 & b40;
            s[47] = b47 ^ ~b49 & b41;
            s[8] = b8 ^ ~b0 & b2;
            s[9] = b9 ^ ~b1 & b3;
            s[18] = b18 ^ ~b10 & b12;
            s[19] = b19 ^ ~b11 & b13;
            s[28] = b28 ^ ~b20 & b22;
            s[29] = b29 ^ ~b21 & b23;
            s[38] = b38 ^ ~b30 & b32;
            s[39] = b39 ^ ~b31 & b33;
            s[48] = b48 ^ ~b40 & b42;
            s[49] = b49 ^ ~b41 & b43;
            s[0] ^= RC[n];
            s[1] ^= RC[n + 1];
        }
    };
    if (COMMON_JS) {
        module.exports = methods;
    } else {
        for(i = 0; i < methodNames.length; ++i){
            root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
            ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
                return methods;
            }(__turbopack_context__.r, exports, module));
        }
    }
})();
}}),
"[project]/node_modules/@thirdweb-dev/crypto/dist/thirdweb-dev-crypto.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "aesDecrypt": (()=>aesDecrypt),
    "aesDecryptCompat": (()=>aesDecryptCompat),
    "aesEncrypt": (()=>aesEncrypt),
    "keccak256Sync": (()=>keccak256Sync),
    "keccak256SyncHex": (()=>keccak256SyncHex),
    "keccak256SyncHexPrefixed": (()=>keccak256SyncHexPrefixed),
    "sha256": (()=>sha256),
    "sha256Hex": (()=>sha256Hex),
    "sha256HexSync": (()=>sha256HexSync),
    "sha256Sync": (()=>sha256Sync)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$crypto$2f$node_modules$2f$js$2d$sha3$2f$src$2f$sha3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/crypto/node_modules/js-sha3/src/sha3.js [app-client] (ecmascript)");
;
;
class TextProcessorCache {
    get encoder() {
        if (!this._encoder) {
            this._encoder = new TextEncoder();
        }
        return this._encoder;
    }
    get decoder() {
        if (!this._decoder) {
            this._decoder = new TextDecoder();
        }
        return this._decoder;
    }
}
// create a singleton instance of the TextProcessorCache
const textProcessorSingleton = new TextProcessorCache();
function getCachedTextEncoder() {
    return textProcessorSingleton.encoder;
}
function getCachedTextDecoder() {
    return textProcessorSingleton.decoder;
}
// stripped down version of `js-md5`
// changes:
// - we know we always have ArrayBuffer available
// - we only care about `arrayBuffer` output
// - we want to behave the same regardless of NODE or non NODE env
// - transformed into class
// - typescript
/**
 * [js-md5]{@link https://github.com/emn178/js-md5}
 *
 * @namespace md5
 * @version 0.8.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2023
 * @license MIT
 */ const INPUT_ERROR = "input is invalid type";
const FINALIZE_ERROR = "finalize already called";
const EXTRA = [
    128,
    32768,
    8388608,
    -2147483648
];
// [message: string, isString: bool]
function formatMessage(message) {
    const type = typeof message;
    if (typeof message === "string") {
        return [
            message,
            true
        ];
    }
    if (type !== "object" || message === null) {
        throw new Error(INPUT_ERROR);
    }
    if (message instanceof ArrayBuffer) {
        return [
            new Uint8Array(message),
            false
        ];
    }
    if (!Array.isArray(message) && !ArrayBuffer.isView(message)) {
        throw new Error(INPUT_ERROR);
    }
    return [
        message,
        false
    ];
}
/**
 * Md5 class
 * @class Md5
 * @description This is internal class.
 * @see {@link md5.create}
 */ class Md5 {
    lastByteIndex = 0;
    constructor(){
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const buffer = new ArrayBuffer(68);
        this.buffer8 = new Uint8Array(buffer);
        this.blocks = new Uint32Array(buffer);
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
    }
    /**
   * @method update
   * @memberof Md5
   * @instance
   * @description Update hash
   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
   * @returns {Md5} Md5 object.
   * @see {@link md5.update}
   */ update(inputMessage) {
        if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
        }
        const [message, isString] = formatMessage(inputMessage);
        const blocks = this.blocks;
        let length = 0;
        if (ArrayBuffer.isView(message)) {
            length = message.byteLength;
        } else {
            length = message.length;
        }
        let code, index = 0, i;
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const buffer8 = this.buffer8;
        while(index < length){
            if (this.hashed) {
                this.hashed = false;
                blocks[0] = blocks[16];
                blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            }
            if (isString) {
                for(i = this.start; index < length && i < 64; ++index){
                    code = message.charCodeAt(index);
                    if (code < 0x80) {
                        buffer8[i++] = code;
                    } else if (code < 0x800) {
                        buffer8[i++] = 0xc0 | code >>> 6;
                        buffer8[i++] = 0x80 | code & 0x3f;
                    } else if (code < 0xd800 || code >= 0xe000) {
                        buffer8[i++] = 0xe0 | code >>> 12;
                        buffer8[i++] = 0x80 | code >>> 6 & 0x3f;
                        buffer8[i++] = 0x80 | code & 0x3f;
                    } else {
                        code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                        buffer8[i++] = 0xf0 | code >>> 18;
                        buffer8[i++] = 0x80 | code >>> 12 & 0x3f;
                        buffer8[i++] = 0x80 | code >>> 6 & 0x3f;
                        buffer8[i++] = 0x80 | code & 0x3f;
                    }
                }
            } else {
                for(i = this.start; index < length && i < 64; ++index){
                    // at this point we know it's not a string
                    buffer8[i++] = message[index];
                }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
                this.start = i - 64;
                this.hash();
                this.hashed = true;
            } else {
                this.start = i;
            }
        }
        if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
        }
        return this;
    }
    finalize() {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const blocks = this.blocks, i = this.lastByteIndex;
        blocks[i >>> 2] |= EXTRA[i & 3];
        if (i >= 56) {
            if (!this.hashed) {
                this.hash();
            }
            blocks[0] = blocks[16];
            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        }
        blocks[14] = this.bytes << 3;
        blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
        this.hash();
    }
    hash() {
        const blocks = this.blocks;
        let a, b, c, d, bc, da;
        if (this.first) {
            a = blocks[0] - 680876937;
            a = (a << 7 | a >>> 25) - 271733879 << 0;
            d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
            d = (d << 12 | d >>> 20) + a << 0;
            c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
            c = (c << 17 | c >>> 15) + d << 0;
            b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
            b = (b << 22 | b >>> 10) + c << 0;
        } else {
            a = this.h0;
            b = this.h1;
            c = this.h2;
            d = this.h3;
            a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
            b = (b << 22 | b >>> 10) + c << 0;
        }
        a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
        a = (a << 7 | a >>> 25) + b << 0;
        d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
        d = (d << 12 | d >>> 20) + a << 0;
        c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
        c = (c << 17 | c >>> 15) + d << 0;
        b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
        b = (b << 22 | b >>> 10) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
        b = (b << 20 | b >>> 12) + c << 0;
        a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
        a = (a << 5 | a >>> 27) + b << 0;
        d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
        d = (d << 9 | d >>> 23) + a << 0;
        c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
        c = (c << 14 | c >>> 18) + d << 0;
        b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
        b = (b << 20 | b >>> 12) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks[5] - 378558;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks[8] - 2022574463;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks[11] + 1839030562;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks[14] - 35309556;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks[1] - 1530992060;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks[4] + 1272893353;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks[7] - 155497632;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks[10] - 1094730640;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks[13] + 681279174;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks[0] - 358537222;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks[3] - 722521979;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks[6] + 76029189;
        b = (b << 23 | b >>> 9) + c << 0;
        bc = b ^ c;
        a += (bc ^ d) + blocks[9] - 640364487;
        a = (a << 4 | a >>> 28) + b << 0;
        d += (bc ^ a) + blocks[12] - 421815835;
        d = (d << 11 | d >>> 21) + a << 0;
        da = d ^ a;
        c += (da ^ b) + blocks[15] + 530742520;
        c = (c << 16 | c >>> 16) + d << 0;
        b += (da ^ c) + blocks[2] - 995338651;
        b = (b << 23 | b >>> 9) + c << 0;
        a += (c ^ (b | ~d)) + blocks[0] - 198630844;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks[5] - 57434055;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks[10] - 1051523;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks[15] - 30611744;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
        b = (b << 21 | b >>> 11) + c << 0;
        a += (c ^ (b | ~d)) + blocks[4] - 145523070;
        a = (a << 6 | a >>> 26) + b << 0;
        d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
        d = (d << 10 | d >>> 22) + a << 0;
        c += (a ^ (d | ~b)) + blocks[2] + 718787259;
        c = (c << 15 | c >>> 17) + d << 0;
        b += (d ^ (c | ~a)) + blocks[9] - 343485551;
        b = (b << 21 | b >>> 11) + c << 0;
        if (this.first) {
            this.h0 = a + 1732584193 << 0;
            this.h1 = b - 271733879 << 0;
            this.h2 = c - 1732584194 << 0;
            this.h3 = d + 271733878 << 0;
            this.first = false;
        } else {
            this.h0 = this.h0 + a << 0;
            this.h1 = this.h1 + b << 0;
            this.h2 = this.h2 + c << 0;
            this.h3 = this.h3 + d << 0;
        }
    }
    /**
   * @method arrayBuffer
   * @memberof Md5
   * @instance
   * @description Output hash as ArrayBuffer
   * @returns {ArrayBuffer} ArrayBuffer
   * @see {@link md5.arrayBuffer}
   * @example
   * hash.arrayBuffer();
   */ arrayBuffer() {
        this.finalize();
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const buffer = new ArrayBuffer(16);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const blocks = new Uint32Array(buffer);
        blocks[0] = this.h0;
        blocks[1] = this.h1;
        blocks[2] = this.h2;
        blocks[3] = this.h3;
        return buffer;
    }
}
function arrayBuffer(uint8Arr) {
    const md5 = new Md5();
    md5.update(uint8Arr);
    return md5.arrayBuffer();
}
// taken from: https://github.com/sindresorhus/uint8array-extras
const objectToString = Object.prototype.toString;
const uint8ArrayStringified = "[object Uint8Array]";
function isUint8Array(value) {
    if (!value) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    return objectToString.call(value) === uint8ArrayStringified;
}
function assertUint8Array(value) {
    if (!isUint8Array(value)) {
        throw new TypeError(`Expected \`Uint8Array\`, got \`${typeof value}\``);
    }
}
function concatUint8Arrays(arrays, totalLength) {
    if (arrays.length === 0) {
        return new Uint8Array(0);
    }
    if (totalLength === null || totalLength === undefined) {
        totalLength = arrays.reduce((accumulator, currentValue)=>accumulator + currentValue.length, 0);
    }
    const returnValue = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays){
        assertUint8Array(array);
        returnValue.set(array, offset);
        offset += array.length;
    }
    return returnValue;
}
function assertString(value) {
    if (typeof value !== "string") {
        throw new TypeError(`Expected \`string\`, got \`${typeof value}\``);
    }
}
function base64ToBase64Url(base64) {
    return base64.replaceAll("+", "-").replaceAll("/", "_").replace(/=+$/, "");
}
function base64UrlToBase64(base64url) {
    return base64url.replaceAll("-", "+").replaceAll("_", "/");
}
// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/
const MAX_BLOCK_SIZE = 65_535;
function uint8ArrayToBase64(array) {
    let { urlSafe = false } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    assertUint8Array(array);
    let base64;
    if (array.length < MAX_BLOCK_SIZE) {
        // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem
        base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));
    } else {
        base64 = "";
        for (const value of array){
            base64 += String.fromCodePoint(value);
        }
        base64 = globalThis.btoa(base64);
    }
    return urlSafe ? base64ToBase64Url(base64) : base64;
}
function base64ToUint8Array(base64String) {
    assertString(base64String);
    return Uint8Array.from(globalThis.atob(base64UrlToBase64(base64String)), (x)=>x.codePointAt(0));
}
const byteToHexLookupTable = Array.from({
    length: 256
}, (_, index)=>index.toString(16).padStart(2, "0"));
function uint8ArrayToHex(array) {
    assertUint8Array(array);
    // Concatenating a string is faster than using an array.
    let hexString = "";
    for(let index = 0; index < array.length; index++){
        hexString += byteToHexLookupTable[array[index]];
    }
    return hexString;
}
async function universalCrypto() {
    if ("crypto" in globalThis) {
        return globalThis.crypto;
    }
    // otherwise we are in node 18 so we can use `webcrypto` off of the "node:crypto" package and treat it as native
    // trick bundlers so that they leave this alone :)
    const pto = "pto";
    // this becomes `node:crypto` at runtime
    return (await __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript, async loader)")(__turbopack_context__.i)).webcrypto;
}
/**
 * This is an implementation of the CryptoJS AES decryption scheme, without actually relying on crypto-js.
 */ const HEAD_SIZE_DWORD = 2;
const SALT_SIZE_DWORD = 2;
async function decryptCryptoJSCipherBase64(salt, ciphertext, password) {
    let { keySizeDWORD = 256 / 32, ivSizeDWORD = 128 / 32, iterations = 1 } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const crypto = await universalCrypto();
    const { key, iv } = await dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations);
    try {
        // decrypt ciphertext using key
        const plainBuffer = await crypto.subtle.decrypt({
            name: "AES-CBC",
            iv
        }, key, ciphertext);
        // return the plaintext from ArrayBuffer
        return getCachedTextDecoder().decode(plainBuffer);
    } catch (e) {
        throw new Error("Decrypt failed");
    }
}
function parseCryptoJSCipherBase64(cryptoJSCipherBase64) {
    let salt = null;
    let ciphertext = base64ToUint8Array(cryptoJSCipherBase64);
    const [head, body] = splitUint8Array(ciphertext, HEAD_SIZE_DWORD * 4);
    // This effectively checks if the ciphertext starts with 'Salted__', which is the crypto-js convention.
    const headDataView = new DataView(head.buffer);
    if (headDataView.getInt32(0) === 0x53616c74 && headDataView.getInt32(4) === 0x65645f5f) {
        [salt, ciphertext] = splitUint8Array(body, SALT_SIZE_DWORD * 4);
    }
    return {
        ciphertext,
        salt
    };
}
async function dangerouslyDeriveParameters(password, salt, keySizeDWORD, ivSizeDWORD, iterations) {
    const crypto = await universalCrypto();
    const passwordUint8Array = getCachedTextEncoder().encode(password);
    const keyPlusIV = dangerousEVPKDF(passwordUint8Array, salt, keySizeDWORD + ivSizeDWORD, iterations);
    const [rawKey, iv] = splitUint8Array(keyPlusIV, keySizeDWORD * 4);
    const key = await crypto.subtle.importKey("raw", rawKey, "AES-CBC", false, [
        "decrypt"
    ]);
    return {
        key,
        iv
    };
}
function dangerousEVPKDF(passwordUint8Array, saltUint8Array, keySizeDWORD, iterations) {
    let derivedKey = new Uint8Array();
    let block = new Uint8Array();
    while(derivedKey.byteLength < keySizeDWORD * 4){
        block = new Uint8Array(arrayBuffer(concatUint8Arrays([
            block,
            passwordUint8Array,
            saltUint8Array
        ])));
        for(let i = 1; i < iterations; i++){
            block = new Uint8Array(arrayBuffer(block));
        }
        derivedKey = concatUint8Arrays([
            derivedKey,
            block
        ]);
    }
    return derivedKey;
}
function splitUint8Array(a, i) {
    return [
        a.subarray(0, i),
        a.subarray(i, a.length)
    ];
}
/**
 * Decrypts ciphertext encrypted with aesEncrypt() using supplied password.
 *
 * @param    ciphertext - Ciphertext to be decrypted.
 * @param    password - Password to use to decrypt ciphertext.
 * @returns  Decrypted plaintext.
 *
 * @example
 *   const plaintext = await aesDecrypt(ciphertext, 'pw');
 */ async function aesDecrypt(ciphertext, password) {
    const crypto = await universalCrypto();
    // encode password as UTF-8
    const pwUtf8 = getCachedTextEncoder().encode(password);
    // hash the password
    const pwHash = await crypto.subtle.digest("SHA-256", pwUtf8);
    const cipherUint8Array = base64ToUint8Array(ciphertext);
    // iv
    const iv = cipherUint8Array.slice(0, 12);
    // specify algorithm to use
    const alg = {
        name: "AES-GCM",
        iv
    };
    // generate key from pw
    const key = await crypto.subtle.importKey("raw", pwHash, alg, false, [
        "decrypt"
    ]);
    // ciphertext
    const ctUint8 = cipherUint8Array.slice(12);
    try {
        // decrypt ciphertext using key
        const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);
        // return the plaintext from ArrayBuffer
        return getCachedTextDecoder().decode(plainBuffer);
    } catch (e) {
        throw new Error("Decrypt failed");
    }
}
/**
 * Decrypts ciphertext encrypted with aesEncrypt() OR "crypto-js".AES using supplied password.
 *
 * @param    ciphertext - Ciphertext to be decrypted.
 * @param    password - Password to use to decrypt ciphertext.
 * @returns  Decrypted plaintext.
 *
 * @example
 *   const plaintext = await aesDecryptCompat(ciphertext, 'pw');
 */ async function aesDecryptCompat(ciphertext, password) {
    // determine if we're dealing with a legacy (cryptojs) ciphertext
    const cryptoJs = parseCryptoJSCipherBase64(ciphertext);
    if (cryptoJs.salt && cryptoJs.ciphertext) {
        return decryptCryptoJSCipherBase64(cryptoJs.salt, cryptoJs.ciphertext, password);
    }
    // otherwise assume it's a ciphertext generated by aesEncrypt()
    return aesDecrypt(ciphertext, password);
}
/**
 * Encrypts plaintext using AES-GCM with supplied password, for decryption with aesDecrypt().
 *
 * @param plaintext - Plaintext to be encrypted.
 * @param password - Password to use to encrypt plaintext.
 * @returns Encrypted ciphertext.
 *
 * @example
 *   const ciphertext = await aesEncrypt('my secret text', 'pw');
 */ async function aesEncrypt(plaintext, password) {
    const crypto = await universalCrypto();
    const textEncoder = getCachedTextEncoder();
    // encode password as UTF-8
    const pwUtf8 = textEncoder.encode(password);
    // hash the password
    const pwHash = await crypto.subtle.digest("SHA-256", pwUtf8);
    // get 96-bit random iv
    const iv = crypto.getRandomValues(new Uint8Array(12));
    // specify algorithm to use
    const alg = {
        name: "AES-GCM",
        iv
    };
    // generate key from pw
    const key = await crypto.subtle.importKey("raw", pwHash, alg, false, [
        "encrypt"
    ]);
    // encode plaintext as UTF-8
    const ptUint8 = textEncoder.encode(plaintext);
    // encrypt plaintext using key
    const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8);
    // iv+ciphertext base64-encoded
    return uint8ArrayToBase64(concatUint8Arrays([
        iv,
        new Uint8Array(ctBuffer)
    ]));
}
/**
 * Hash a string or Uint8Array using sha256.
 * @param value - Value to be hashed.
 * @returns A promise that resolves to the hash of the value as Uint8Array.
 */ async function sha256(value) {
    let encodedValue;
    if (typeof value === "string") {
        // if we do not have a cahced TextEncoder instance, create one
        encodedValue = getCachedTextEncoder().encode(value);
    } else {
        encodedValue = value;
    }
    return new Uint8Array(await (await universalCrypto()).subtle.digest("SHA-256", encodedValue));
}
/**
 * Hash a string or Uint8Array using sha256 and returns the result as a hex string.
 * @param value - Value to be hashed.
 * @returns A promise that resolves to the hash of the value as a hex string.
 */ async function sha256Hex(value) {
    return uint8ArrayToHex(await sha256(value));
}
/**
 * Hash a string or Uint8Array using sha256.
 * @param value - Value to be hashed.
 * @returns The hash of the value as Uint8Array.
 */ function sha256Sync(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(value);
}
/**
 * Hash a string or Uint8Array using sha256.
 * @param value - Value to be hashed.
 * @returns The hash of the value as a hex string.
 */ function sha256HexSync(value) {
    return uint8ArrayToHex(sha256Sync(value));
}
/**
 * Hashes a string or Uint8Array using keccak256.
 * @param value - Value to be hashed.
 * @returns Hash of the value as Uint8Array.
 */ function keccak256Sync(value) {
    return new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$crypto$2f$node_modules$2f$js$2d$sha3$2f$src$2f$sha3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak_256"].arrayBuffer(value));
}
/**
 * Hashes a string or Uint8Array using keccak256 and returns the result as a hex string.
 * @param value - Value to be hashed.
 * @returns Hash of the value as a hex string.
 */ function keccak256SyncHex(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$crypto$2f$node_modules$2f$js$2d$sha3$2f$src$2f$sha3$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak_256"])(value);
}
/**
 * Hashes a string or Uint8Array using keccak256 and returns the result as a hex string prefixed with "0x".
 * @param value - Value to be hashed.
 * @returns Hash of the value as a hex string prefixed with "0x".
 */ function keccak256SyncHexPrefixed(value) {
    // prefix with 0x (this is what ethers.utils.keccak256 does)
    return `0x${keccak256SyncHex(value)}`;
}
;
}}),
"[project]/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_GATEWAY_URLS": (()=>DEFAULT_GATEWAY_URLS),
    "IpfsUploader": (()=>IpfsUploader),
    "MockDownloader": (()=>MockDownloader),
    "MockUploader": (()=>MockUploader),
    "PINATA_IPFS_URL": (()=>PINATA_IPFS_URL),
    "StorageDownloader": (()=>StorageDownloader),
    "TW_UPLOAD_SERVER_URL": (()=>TW_UPLOAD_SERVER_URL),
    "ThirdwebStorage": (()=>ThirdwebStorage),
    "convertCidToV1": (()=>convertCidToV1),
    "extractObjectFiles": (()=>extractObjectFiles),
    "getGatewayUrlForCid": (()=>getGatewayUrlForCid),
    "isBrowser": (()=>isBrowser),
    "isBufferInstance": (()=>isBufferInstance),
    "isBufferOrStringWithName": (()=>isBufferOrStringWithName),
    "isFileBufferOrStringEqual": (()=>isFileBufferOrStringEqual),
    "isFileInstance": (()=>isFileInstance),
    "isFileOrBuffer": (()=>isFileOrBuffer),
    "isTwGatewayUrl": (()=>isTwGatewayUrl),
    "parseGatewayUrls": (()=>parseGatewayUrls),
    "prepareGatewayUrls": (()=>prepareGatewayUrls),
    "replaceGatewayUrlWithScheme": (()=>replaceGatewayUrlWithScheme),
    "replaceObjectFilesWithUris": (()=>replaceObjectFilesWithUris),
    "replaceObjectGatewayUrlsWithSchemes": (()=>replaceObjectGatewayUrlsWithSchemes),
    "replaceObjectSchemesWithGatewayUrls": (()=>replaceObjectSchemesWithGatewayUrls),
    "replaceSchemeWithGatewayUrl": (()=>replaceSchemeWithGatewayUrl)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cid$2d$tool$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cid-tool/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$crypto$2f$dist$2f$thirdweb$2d$dev$2d$crypto$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/crypto/dist/thirdweb-dev-crypto.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2f$lib$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/form-data/lib/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
;
;
;
;
function getProcessEnv(key) {
    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined") {
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env[key]) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env[key];
        }
    }
    return defaultValue;
}
const TW_HOSTNAME_SUFFIX = ".ipfscdn.io";
const TW_STAGINGHOSTNAME_SUFFIX = ".thirdwebstorage-staging.com";
const TW_GATEWAY_URLS = [
    `https://{clientId}${TW_HOSTNAME_SUFFIX}/ipfs/{cid}/{path}`
];
/**
 * @internal
 * @param url - the url to check
 * @returns
 */ function isTwGatewayUrl(url) {
    const hostname = new URL(url).hostname;
    const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);
    if (isProd) {
        return true;
    }
    // fall back to also handle staging urls
    return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);
}
const PUBLIC_GATEWAY_URLS = [
    "https://{cid}.ipfs.cf-ipfs.com/{path}",
    "https://{cid}.ipfs.dweb.link/{path}",
    "https://ipfs.io/ipfs/{cid}/{path}",
    "https://cloudflare-ipfs.com/ipfs/{cid}/{path}",
    "https://{cid}.ipfs.w3s.link/{path}",
    "https://w3s.link/ipfs/{cid}/{path}",
    "https://nftstorage.link/ipfs/{cid}/{path}",
    "https://gateway.pinata.cloud/ipfs/{cid}/{path}"
];
/**
 * @internal
 */ const DEFAULT_GATEWAY_URLS = {
    // Note: Gateway URLs should have trailing slashes (we clean this on user input)
    "ipfs://": [
        ...TW_GATEWAY_URLS,
        ...PUBLIC_GATEWAY_URLS
    ]
};
/**
 * @internal
 */ const TW_UPLOAD_SERVER_URL = getProcessEnv("CUSTOM_UPLOAD_SERVER_URL", "https://storage.thirdweb.com");
/**
 * @internal
 */ const PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
/**
 * @internal
 */ function parseGatewayUrls(gatewayUrls) {
    if (Array.isArray(gatewayUrls)) {
        return {
            "ipfs://": gatewayUrls
        };
    }
    return gatewayUrls || {};
}
/**
 * @internal
 */ function getGatewayUrlForCid(gatewayUrl, cid, clientId) {
    const parts = cid.split("/");
    const hash = convertCidToV1(parts[0]);
    const filePath = parts.slice(1).join("/");
    let url = gatewayUrl;
    // If the URL contains {cid} or {path} tokens, replace them with the CID and path
    // Both tokens must be present for the URL to be valid
    if (gatewayUrl.includes("{cid}") && gatewayUrl.includes("{path}")) {
        url = url.replace("{cid}", hash).replace("{path}", filePath);
    } else if (gatewayUrl.includes("{cid}")) {
        url = url.replace("{cid}", hash);
    } else {
        url += `${hash}/${filePath}`;
    }
    // if the URL contains the {clientId} token, replace it with the client ID
    if (gatewayUrl.includes("{clientId}")) {
        if (!clientId) {
            throw new Error("Cannot use {clientId} in gateway URL without providing a client ID");
        }
        url = url.replace("{clientId}", clientId);
    }
    return url;
}
/**
 * @internal
 */ function prepareGatewayUrls(gatewayUrls, clientId, secretKey) {
    const allGatewayUrls = {
        ...DEFAULT_GATEWAY_URLS,
        ...gatewayUrls
    };
    for (const key of Object.keys(allGatewayUrls)){
        const cleanedGatewayUrls = allGatewayUrls[key].map((url)=>{
            // inject clientId when present
            if (clientId && url.includes("{clientId}")) {
                return url.replace("{clientId}", clientId);
            } else if (secretKey && url.includes("{clientId}")) {
                // should only be used on Node.js in a backend/script context
                if (typeof window !== "undefined") {
                    throw new Error("Cannot use secretKey in browser context");
                }
                const hashedSecretKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$crypto$2f$dist$2f$thirdweb$2d$dev$2d$crypto$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256HexSync"])(secretKey);
                const derivedClientId = hashedSecretKey.slice(0, 32);
                return url.replace("{clientId}", derivedClientId);
            } else if (url.includes("{clientId}")) {
                // if no client id passed, filter out the url
                return undefined;
            } else {
                return url;
            }
        }).filter((url)=>url !== undefined);
        allGatewayUrls[key] = cleanedGatewayUrls;
    }
    return allGatewayUrls;
}
/**
 * @internal
 */ function convertCidToV1(cid) {
    let normalized = '';
    try {
        const hash = cid.split("/")[0];
        normalized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cid$2d$tool$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].base32(hash);
    } catch (e) {
        throw new Error(`The CID ${cid} is not valid.`);
    }
    return normalized;
}
/**
 * @internal
 */ function isBrowser() {
    return typeof window !== "undefined";
}
/**
 * @internal
 */ function isFileInstance(data) {
    return global.File && data instanceof File;
}
/**
 * @internal
 */ function isBufferInstance(data) {
    return global.Buffer && data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"];
}
/**
 * @internal
 */ function isBufferOrStringWithName(data) {
    return !!(data && data.name && data.data && typeof data.name === "string" && (typeof data.data === "string" || isBufferInstance(data.data)));
}
function isFileOrBuffer(data) {
    return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);
}
/**
 * @internal
 */ function isFileBufferOrStringEqual(input1, input2) {
    if (isFileInstance(input1) && isFileInstance(input2)) {
        // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)
        if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {
            return true;
        }
    } else if (isBufferInstance(input1) && isBufferInstance(input2)) {
        // buffer gives us an easy way to compare the contents!
        return input1.equals(input2);
    } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {
        // first check the names
        if (input1.name === input2.name) {
            // if the data for both is a string, compare the strings
            if (typeof input1.data === "string" && typeof input2.data === "string") {
                return input1.data === input2.data;
            } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {
                // otherwise we know it's buffers, so compare the buffers
                return input1.data.equals(input2.data);
            }
        }
    }
    // otherwise if we have not found a match, return false
    return false;
}
/**
 * @internal
 */ function parseCidAndPath(gatewayUrl, uri) {
    const regexString = gatewayUrl.replace("{cid}", "(?<hash>[^/]+)").replace("{path}", "(?<path>[^?#]+)");
    const regex = new RegExp(regexString);
    const match = uri.match(regex);
    if (match) {
        const hash = match.groups?.hash;
        const path = match.groups?.path;
        const queryString = uri.includes("?") ? uri.substring(uri.indexOf("?") + 1) : "";
        return {
            hash,
            path,
            query: queryString
        };
    }
}
/**
 * @internal
 */ function replaceGatewayUrlWithScheme(uri, gatewayUrls) {
    for (const scheme of Object.keys(gatewayUrls)){
        for (const gatewayUrl of gatewayUrls[scheme]){
            // If the url is a tokenized url, we need to convert it to a canonical url
            // Otherwise, we just need to check if the url is a prefix of the uri
            if (gatewayUrl.includes("{cid}")) {
                // Given the url is a tokenized url, we need to lift the cid and the path from the uri
                const parsed = parseCidAndPath(gatewayUrl, uri);
                if (parsed?.hash && parsed?.path) {
                    const queryString = parsed?.query ? `?${parsed?.query}` : "";
                    return `${scheme}${parsed?.hash}/${parsed?.path}${queryString}`;
                } else {
                    // If we can't lift the cid and path from the uri, we can't replace the gateway url, return the orig string
                    return uri;
                }
            } else if (uri.startsWith(gatewayUrl)) {
                return uri.replace(gatewayUrl, scheme);
            }
        }
    }
    return uri;
}
/**
 * @internal
 */ function replaceSchemeWithGatewayUrl(uri, gatewayUrls) {
    let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let clientId = arguments.length > 3 ? arguments[3] : undefined;
    const scheme = Object.keys(gatewayUrls).find((s)=>uri.startsWith(s));
    const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];
    if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {
        return undefined;
    }
    if (!scheme) {
        return uri;
    }
    const path = uri.replace(scheme, "");
    try {
        const gatewayUrl = getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);
        return gatewayUrl;
    } catch (err) {
        console.warn(`The IPFS uri: ${path} is not valid.`);
        return undefined;
    }
}
/**
 * @internal
 */ function replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {
    if (typeof data === "string") {
        return replaceGatewayUrlWithScheme(data, gatewayUrls);
    }
    if (typeof data === "object") {
        if (!data) {
            return data;
        }
        if (isFileOrBuffer(data)) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map((entry)=>replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));
        }
        return Object.fromEntries(Object.entries(data).map((_ref)=>{
            let [key, value] = _ref;
            return [
                key,
                replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)
            ];
        }));
    }
    return data;
}
/**
 * @internal
 */ function replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {
    if (typeof data === "string") {
        return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);
    }
    if (typeof data === "object") {
        if (!data) {
            return data;
        }
        if (isFileOrBuffer(data)) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map((entry)=>replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));
        }
        return Object.fromEntries(Object.entries(data).map((_ref2)=>{
            let [key, value] = _ref2;
            return [
                key,
                replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)
            ];
        }));
    }
    return data;
}
/**
 * @internal
 */ function extractObjectFiles(data) {
    let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    // If item is a FileOrBuffer add it to our list of files
    if (isFileOrBuffer(data)) {
        files.push(data);
        return files;
    }
    if (typeof data === "object") {
        if (!data) {
            return files;
        }
        if (Array.isArray(data)) {
            data.forEach((entry)=>extractObjectFiles(entry, files));
        } else {
            Object.keys(data).map((key)=>extractObjectFiles(data[key], files));
        }
    }
    return files;
}
/**
 * @internal
 */ function replaceObjectFilesWithUris(data, uris) {
    if (isFileOrBuffer(data)) {
        if (uris.length) {
            data = uris.shift();
            return data;
        } else {
            console.warn("Not enough URIs to replace all files in object.");
        }
    }
    if (typeof data === "object") {
        if (!data) {
            return data;
        }
        if (Array.isArray(data)) {
            return data.map((entry)=>replaceObjectFilesWithUris(entry, uris));
        } else {
            return Object.fromEntries(Object.entries(data).map((_ref3)=>{
                let [key, value] = _ref3;
                return [
                    key,
                    replaceObjectFilesWithUris(value, uris)
                ];
            }));
        }
    }
    return data;
}
var pkg = {
    name: "@thirdweb-dev/storage",
    version: "2.0.15",
    main: "dist/thirdweb-dev-storage.cjs.js",
    module: "dist/thirdweb-dev-storage.esm.js",
    exports: {
        ".": {
            module: "./dist/thirdweb-dev-storage.esm.js",
            "default": "./dist/thirdweb-dev-storage.cjs.js"
        },
        "./package.json": "./package.json"
    },
    repository: "https://github.com/thirdweb-dev/js/tree/main/legacy_packages/storage",
    author: "thirdweb eng <eng@thirdweb.com>",
    license: "Apache-2.0",
    sideEffects: false,
    scripts: {
        format: "prettier --write 'src/**/*'",
        lint: "eslint src/",
        fix: "eslint src/ --fix",
        clean: "rm -rf dist/",
        build: "tsc && preconstruct build",
        test: "vitest run",
        push: "yalc push",
        typedoc: "node scripts/typedoc.mjs"
    },
    files: [
        "dist/"
    ],
    preconstruct: {
        exports: true
    },
    devDependencies: {
        "@microsoft/api-documenter": "^7.24.1",
        "@microsoft/api-extractor": "^7.43.0",
        "@microsoft/tsdoc": "^0.14.2",
        "@preconstruct/cli": "2.7.0",
        "@swc-node/register": "^1.9.0",
        "@thirdweb-dev/tsconfig": "^0.1.7",
        "@types/uuid": "^9.0.8",
        eslint: "8.57.0",
        "eslint-config-thirdweb": "^0.1.9",
        "eslint-plugin-tsdoc": "^0.2.17",
        esm: "^3.2.25",
        rimraf: "5.0.5",
        "typedoc-gen": "^1.0.2",
        typescript: "5.4.4"
    },
    dependencies: {
        "@thirdweb-dev/crypto": "0.2.6",
        "cid-tool": "^3.0.0",
        "form-data": "^4.0.0",
        uuid: "^9.0.1"
    },
    engines: {
        node: ">=18"
    }
};
/**
 * @internal
 *
 * The code below comes from the package https://github.com/DamonOehlman/detect-browser
 */ const operatingSystemRules = [
    [
        "iOS",
        /iP(hone|od|ad)/
    ],
    [
        "Android OS",
        /Android/
    ],
    [
        "BlackBerry OS",
        /BlackBerry|BB10/
    ],
    [
        "Windows Mobile",
        /IEMobile/
    ],
    [
        "Amazon OS",
        /Kindle/
    ],
    [
        "Windows 3.11",
        /Win16/
    ],
    [
        "Windows 95",
        /(Windows 95)|(Win95)|(Windows_95)/
    ],
    [
        "Windows 98",
        /(Windows 98)|(Win98)/
    ],
    [
        "Windows 2000",
        /(Windows NT 5.0)|(Windows 2000)/
    ],
    [
        "Windows XP",
        /(Windows NT 5.1)|(Windows XP)/
    ],
    [
        "Windows Server 2003",
        /(Windows NT 5.2)/
    ],
    [
        "Windows Vista",
        /(Windows NT 6.0)/
    ],
    [
        "Windows 7",
        /(Windows NT 6.1)/
    ],
    [
        "Windows 8",
        /(Windows NT 6.2)/
    ],
    [
        "Windows 8.1",
        /(Windows NT 6.3)/
    ],
    [
        "Windows 10",
        /(Windows NT 10.0)/
    ],
    [
        "Windows ME",
        /Windows ME/
    ],
    [
        "Windows CE",
        /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
    ],
    [
        "Open BSD",
        /OpenBSD/
    ],
    [
        "Sun OS",
        /SunOS/
    ],
    [
        "Chrome OS",
        /CrOS/
    ],
    [
        "Linux",
        /(Linux)|(X11)/
    ],
    [
        "Mac OS",
        /(Mac_PowerPC)|(Macintosh)/
    ],
    [
        "QNX",
        /QNX/
    ],
    [
        "BeOS",
        /BeOS/
    ],
    [
        "OS/2",
        /OS\/2/
    ]
];
function detectOS(ua) {
    for(let ii = 0, count = operatingSystemRules.length; ii < count; ii++){
        const result = operatingSystemRules[ii];
        if (!result) {
            continue;
        }
        const [os, regex] = result;
        const match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getOperatingSystem() {
    if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
        return "";
    } else if (typeof window !== "undefined") {
        const userAgent = navigator.userAgent;
        return detectOS(userAgent) || "";
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform;
    }
}
function setAnalyticsHeaders(headers) {
    const globals = getAnalyticsGlobals();
    headers["x-sdk-version"] = globals.x_sdk_version;
    headers["x-sdk-name"] = globals.x_sdk_name;
    headers["x-sdk-platform"] = globals.x_sdk_platform;
    headers["x-sdk-os"] = globals.x_sdk_os;
    if (globals.app_bundle_id) {
        headers["x-bundle-id"] = globals.app_bundle_id;
    }
}
function setAnalyticsHeadersForXhr(xhr) {
    const globals = getAnalyticsGlobals();
    xhr.setRequestHeader("x-sdk-version", globals.x_sdk_version);
    xhr.setRequestHeader("x-sdk-os", globals.x_sdk_os);
    xhr.setRequestHeader("x-sdk-name", globals.x_sdk_name);
    xhr.setRequestHeader("x-sdk-platform", globals.x_sdk_platform);
    if (globals.app_bundle_id) {
        xhr.setRequestHeader("x-bundle-id", globals.app_bundle_id);
    }
}
function getAnalyticsGlobals() {
    if (typeof globalThis === "undefined") {
        return {
            x_sdk_name: pkg.name,
            x_sdk_platform: getPlatform(),
            x_sdk_version: pkg.version,
            x_sdk_os: getOperatingSystem(),
            app_bundle_id: undefined
        };
    }
    if (globalThis.X_SDK_NAME === undefined) {
        globalThis.X_SDK_NAME = pkg.name;
        globalThis.X_SDK_PLATFORM = getPlatform();
        globalThis.X_SDK_VERSION = pkg.version;
        globalThis.X_SDK_OS = getOperatingSystem();
        globalThis.APP_BUNDLE_ID = undefined;
    }
    return {
        x_sdk_name: globalThis.X_SDK_NAME,
        x_sdk_platform: globalThis.X_SDK_PLATFORM,
        x_sdk_version: globalThis.X_SDK_VERSION,
        x_sdk_os: globalThis.X_SDK_OS,
        app_bundle_id: globalThis.APP_BUNDLE_ID || "" // if react, this will be empty
    };
}
function getPlatform() {
    return typeof navigator !== "undefined" && navigator.product === "ReactNative" ? "mobile" : typeof window !== "undefined" ? "browser" : "node";
}
/**
 * Default downloader used - handles downloading from all schemes specified in the gateway URLs configuration.
 *
 * @example
 * ```jsx
 * // Can instantiate the downloader with the default gateway URLs
 * const downloader = new StorageDownloader();
 *
 * // client id if used in client-side applications
 * const clientId = "your-client-id";
 * const storage = new ThirdwebStorage({ clientId, downloader });
 *
 * // secret key if used in server-side applications
 * const secretKey = "your-secret-key";
 * const storage = new ThirdwebStorage({ secretKey, downloader });
 * ```
 *
 * @public
 */ class StorageDownloader {
    DEFAULT_TIMEOUT_IN_SECONDS = 60;
    DEFAULT_MAX_RETRIES = 3;
    constructor(options){
        this.secretKey = options.secretKey;
        this.clientId = options.clientId;
        this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;
    }
    async download(uri, gatewayUrls, options) {
        let attempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        const maxRetries = options?.maxRetries || this.DEFAULT_MAX_RETRIES;
        if (attempts > maxRetries) {
            console.error("[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.");
            // return a 404 response to avoid retrying
            return new Response(JSON.stringify({
                error: "Not Found"
            }), {
                status: 404,
                headers: {
                    "Content-Type": "application/json"
                }
            });
        }
        // Replace recognized scheme with the highest priority gateway URL that hasn't already been attempted
        let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);
        // If every gateway URL we know about for the designated scheme has been tried (via recursion) and failed, throw an error
        if (!resolvedUri) {
            console.error("[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.");
            return new Response(JSON.stringify({
                error: "Not Found"
            }), {
                status: 404,
                headers: {
                    "Content-Type": "application/json"
                }
            });
        } else if (attempts > 0) {
            console.warn(`Retrying download with backup gateway URL: ${resolvedUri}`);
        }
        let headers = {};
        if (isTwGatewayUrl(resolvedUri)) {
            const bundleId = getAnalyticsGlobals().app_bundle_id;
            if (this.secretKey) {
                headers = {
                    "x-secret-key": this.secretKey
                };
            } else if (this.clientId) {
                if (!resolvedUri.includes("bundleId") && bundleId) {
                    resolvedUri = resolvedUri + (bundleId ? `?bundleId=${bundleId}` : "");
                }
                headers["x-client-Id"] = this.clientId;
            }
            // if we have a authorization token on global context then add that to the headers
            if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
                headers = {
                    ...headers,
                    authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`
                };
            }
            if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
                headers = {
                    ...headers,
                    authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`
                };
                headers["x-authorize-wallet"] = "true";
            }
            setAnalyticsHeaders(headers);
        }
        if (isTooManyRequests(resolvedUri)) {
            // skip the request if we're getting too many request error from the gateway
            return this.download(uri, gatewayUrls, options, attempts + 1);
        }
        const controller = new AbortController();
        const timeoutInSeconds = options?.timeoutInSeconds || this.defaultTimeout;
        const timeout = setTimeout(()=>controller.abort(), timeoutInSeconds * 1000);
        const resOrErr = await fetch(resolvedUri, {
            headers,
            signal: controller.signal
        }).catch((err)=>err);
        // if we get here clear the timeout
        if (timeout) {
            clearTimeout(timeout);
        }
        if (!("status" in resOrErr)) {
            // early exit if we don't have a status code
            throw new Error(`Request timed out after ${timeoutInSeconds} seconds. ${isTwGatewayUrl(resolvedUri) ? "You can update the timeoutInSeconds option to increase the timeout." : "You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway."}`);
        }
        // if the request is good we can skip everything else
        if (resOrErr.ok) {
            return resOrErr;
        }
        if (resOrErr.status === 429) {
            // track that we got a too many requests error
            tooManyRequestsBackOff(resolvedUri, resOrErr);
            // Since the current gateway failed, recursively try the next one we know about
            return this.download(uri, gatewayUrls, options, attempts + 1);
        }
        if (resOrErr.status === 410) {
            // Don't retry if the content is blocklisted
            console.error(`Request to ${resolvedUri} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${resolvedUri} `);
            return resOrErr;
        }
        console.warn(`Request to ${resolvedUri} failed with status ${resOrErr.status} - ${resOrErr.statusText}`);
        // if the status is 404 and we're using a thirdweb gateway url, return the response as is
        if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {
            return resOrErr;
        }
        // these are the only errors that we want to retry, everything else we should just return the error as is
        // 408 - Request Timeout
        // 429 - Too Many Requests
        // 5xx - Server Errors
        if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {
            return resOrErr;
        }
        // Since the current gateway failed, recursively try the next one we know about
        return this.download(uri, gatewayUrls, options, attempts + 1);
    }
}
const TOO_MANY_REQUESTS_TRACKER = new Map();
function isTooManyRequests(gatewayUrl) {
    return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);
}
const TIMEOUT_MAP = new Map();
function tooManyRequestsBackOff(gatewayUrl, response) {
    // if we already have a timeout for this gateway url, clear it
    if (TIMEOUT_MAP.has(gatewayUrl)) {
        clearTimeout(TIMEOUT_MAP.get(gatewayUrl));
    }
    const retryAfter = response.headers.get("Retry-After");
    let backOff = 5000;
    if (retryAfter) {
        const retryAfterSeconds = parseInt(retryAfter);
        if (!isNaN(retryAfterSeconds)) {
            backOff = retryAfterSeconds * 1000;
        }
    }
    // track that we got a too many requests error
    TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);
    TIMEOUT_MAP.set(gatewayUrl, setTimeout(()=>TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));
}
/**
 * Default uploader used - handles uploading arbitrary data to IPFS
 *
 * @example
 * ```jsx
 * // Can instantiate the uploader with default configuration and your client ID when used in client-side applications
 * const uploader = new StorageUploader();
 * const clientId = "your-client-id";
 * const storage = new ThirdwebStorage({ clientId, uploader });
 *
 * // Can instantiate the uploader with default configuration and your secret key when used in server-side applications
 * const uploader = new StorageUploader();
 * const secretKey = "your-secret-key";
 * const storage = new ThirdwebStorage({ secretKey, uploader });
 *
 * // Or optionally, can pass configuration
 * const options = {
 *   // Upload objects with resolvable URLs
 *   uploadWithGatewayUrl: true,
 * }
 * const uploader = new StorageUploader(options);
 * const clientId = "your-client-id";
 * const storage = new ThirdwebStorage({ clientId, uploader });
 * ```
 *
 * @public
 */ class IpfsUploader {
    constructor(options){
        this.uploadWithGatewayUrl = options?.uploadWithGatewayUrl || false;
        this.uploadServerUrl = options?.uploadServerUrl || TW_UPLOAD_SERVER_URL;
        this.clientId = options?.clientId;
        this.secretKey = options?.secretKey;
    }
    async uploadBatch(data, options) {
        if (options?.uploadWithoutDirectory && data.length > 1) {
            throw new Error("[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!");
        }
        const formData = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$form$2d$data$2f$lib$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
        const { form, fileNames } = this.buildFormData(formData, data, options);
        if (isBrowser()) {
            return this.uploadBatchBrowser(form, fileNames, options);
        } else {
            return this.uploadBatchNode(form, fileNames, options);
        }
    }
    buildFormData(form, files, options) {
        const fileNameToFileMap = new Map();
        const fileNames = [];
        for(let i = 0; i < files.length; i++){
            const file = files[i];
            let fileName = "";
            let fileData = file;
            if (isFileInstance(file)) {
                if (options?.rewriteFileNames) {
                    let extensions = "";
                    if (file.name) {
                        const extensionStartIndex = file.name.lastIndexOf(".");
                        if (extensionStartIndex > -1) {
                            extensions = file.name.substring(extensionStartIndex);
                        }
                    }
                    fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;
                } else {
                    fileName = `${file.name}`;
                }
            } else if (isBufferOrStringWithName(file)) {
                fileData = file.data;
                if (options?.rewriteFileNames) {
                    fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
                } else {
                    fileName = `${file.name}`;
                }
            } else {
                if (options?.rewriteFileNames) {
                    fileName = `${i + options.rewriteFileNames.fileStartNumber}`;
                } else {
                    fileName = `${i}`;
                }
            }
            // If we don't want to wrap with directory, adjust the filepath
            const filepath = options?.uploadWithoutDirectory ? `files` : `files/${fileName}`;
            if (fileNameToFileMap.has(fileName)) {
                // if the file in the map is the same as the file we are already looking at then just skip and continue
                if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {
                    // we add it to the filenames array so that we can return the correct number of urls,
                    fileNames.push(fileName);
                    continue;
                }
                // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)
                throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);
            }
            // add it to the map so that we can check for duplicates
            fileNameToFileMap.set(fileName, file);
            // add it to the filenames array so that we can return the correct number of urls
            fileNames.push(fileName);
            if (!isBrowser()) {
                form.append("file", fileData, {
                    filepath
                });
            } else {
                // browser does blob things, filepath is parsed differently on browser vs node.
                // pls pinata?
                form.append("file", new Blob([
                    fileData
                ]), filepath);
            }
        }
        const metadata = {
            name: `Storage SDK`,
            keyvalues: {
                ...options?.metadata
            }
        };
        form.append("pinataMetadata", JSON.stringify(metadata));
        if (options?.uploadWithoutDirectory) {
            form.append("pinataOptions", JSON.stringify({
                wrapWithDirectory: false
            }));
        }
        return {
            form,
            // encode the file names on the way out (which is what the upload backend expects)
            fileNames: fileNames.map((fName)=>encodeURIComponent(fName))
        };
    }
    async uploadBatchBrowser(form, fileNames, options) {
        return new Promise((resolve, reject)=>{
            const xhr = new XMLHttpRequest();
            let timer = setTimeout(()=>{
                xhr.abort();
                reject(new Error("Request to upload timed out! No upload progress received in 30s"));
            }, 30000);
            xhr.upload.addEventListener("loadstart", ()=>{
                console.log(`[${Date.now()}] [IPFS] Started`);
            });
            xhr.upload.addEventListener("progress", (event)=>{
                console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);
                clearTimeout(timer);
                if (event.loaded < event.total) {
                    timer = setTimeout(()=>{
                        xhr.abort();
                        reject(new Error("Request to upload timed out! No upload progress received in 30s"));
                    }, 30000);
                } else {
                    console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);
                }
                if (event.lengthComputable && options?.onProgress) {
                    options?.onProgress({
                        progress: event.loaded,
                        total: event.total
                    });
                }
            });
            xhr.addEventListener("load", ()=>{
                console.log(`[${Date.now()}] [IPFS] Load`);
                clearTimeout(timer);
                if (xhr.status >= 200 && xhr.status < 300) {
                    let body;
                    try {
                        body = JSON.parse(xhr.responseText);
                    } catch (err) {
                        return reject(new Error("Failed to parse JSON from upload response"));
                    }
                    const cid = body.IpfsHash;
                    if (!cid) {
                        throw new Error("Failed to get IPFS hash from upload response");
                    }
                    if (options?.uploadWithoutDirectory) {
                        return resolve([
                            `ipfs://${cid}`
                        ]);
                    } else {
                        return resolve(fileNames.map((n)=>`ipfs://${cid}/${n}`));
                    }
                }
                return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));
            });
            xhr.addEventListener("error", ()=>{
                console.log("[IPFS] Load");
                clearTimeout(timer);
                if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {
                    return reject(new Error("Upload failed due to a network error."));
                }
                return reject(new Error("Unknown upload error occured"));
            });
            xhr.open("POST", `${this.uploadServerUrl}/ipfs/upload`);
            if (this.secretKey) {
                xhr.setRequestHeader("x-secret-key", this.secretKey);
            } else if (this.clientId) {
                xhr.setRequestHeader("x-client-id", this.clientId);
            }
            setAnalyticsHeadersForXhr(xhr);
            // if we have a authorization token on global context then add that to the headers, this is for the dashboard.
            if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
                xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_AUTH_TOKEN}`);
            }
            // CLI auth token
            if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
                xhr.setRequestHeader("authorization", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`);
                xhr.setRequestHeader("x-authorize-wallet", `true`);
            }
            xhr.send(form);
        });
    }
    async uploadBatchNode(form, fileNames, options) {
        if (options?.onProgress) {
            console.warn("The onProgress option is only supported in the browser");
        }
        const headers = {};
        if (this.secretKey) {
            headers["x-secret-key"] = this.secretKey;
        } else if (this.clientId) {
            headers["x-client-id"] = this.clientId;
        }
        // if we have a authorization token on global context then add that to the headers, this is for the dashboard.
        if (typeof globalThis !== "undefined" && "TW_AUTH_TOKEN" in globalThis && typeof globalThis.TW_AUTH_TOKEN === "string") {
            headers["authorization"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;
        }
        // CLI auth token
        if (typeof globalThis !== "undefined" && "TW_CLI_AUTH_TOKEN" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === "string") {
            headers["authorization"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;
            headers["x-authorize-wallet"] = "true";
        }
        setAnalyticsHeaders(headers);
        const res = await fetch(`${this.uploadServerUrl}/ipfs/upload`, {
            method: "POST",
            headers: {
                ...headers,
                ...form.getHeaders()
            },
            body: form.getBuffer()
        });
        if (!res.ok) {
            if (res.status === 401) {
                throw new Error("Unauthorized - You don't have permission to use this service.");
            }
            throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText} - ${await res.text()}`);
        }
        const body = await res.json();
        const cid = body.IpfsHash;
        if (!cid) {
            throw new Error("Failed to upload files to IPFS - Bad CID");
        }
        if (options?.uploadWithoutDirectory) {
            return [
                `ipfs://${cid}`
            ];
        } else {
            return fileNames.map((name)=>`ipfs://${cid}/${name}`);
        }
    }
}
/**
 * Upload and download files from decentralized storage systems.
 *
 * @example
 * ```jsx
 * // Create a default storage class with a client ID when used in client-side applications
 * const storage = new ThirdwebStorage({ clientId: "your-client-id" });
 *
 * // Create a default storage class with a secret key when used in server-side applications
 * const storage = new ThirdwebStorage({ secretKey: "your-secret-key" });
 *
 * You can get a clientId and secretKey from https://thirdweb.com/create-api-key
 *
 * // Upload any file or JSON object
 * const uri = await storage.upload(data);
 * const result = await storage.download(uri);
 *
 * // Or configure a custom uploader, downloader, and gateway URLs
 * const gatewayUrls = {
 *   // We define a mapping of schemes to gateway URLs
 *   "ipfs://": [
 *     "https://ipfs.thirdwebcdn.com/ipfs/",
 *     "https://cloudflare-ipfs.com/ipfs/",
 *     "https://ipfs.io/ipfs/",
 *   ],
 * };
 * const downloader = new StorageDownloader();
 * const uploader = new IpfsUploader();
 * const clientId = "your-client-id";
 * const storage = new ThirdwebStorage({ clientId, uploader, downloader, gatewayUrls });
 * ```
 *
 * @public
 */ class ThirdwebStorage {
    constructor(options){
        this.uploader = options?.uploader || new IpfsUploader({
            clientId: options?.clientId,
            secretKey: options?.secretKey,
            uploadServerUrl: options?.uploadServerUrl
        });
        this.downloader = options?.downloader || new StorageDownloader({
            secretKey: options?.secretKey,
            clientId: options?.clientId
        });
        this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options?.gatewayUrls), options?.clientId, options?.secretKey);
        this.clientId = options?.clientId;
    }
    /**
   * Resolve any scheme on a URL to get a retrievable URL for the data
   *
   * @param url - The URL to resolve the scheme of
   * @returns The URL with its scheme resolved
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const url = storage.resolveScheme(uri);
   * console.log(url);
   * ```
   */ resolveScheme(url) {
        return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);
    }
    /**
   * Downloads arbitrary data from any URL scheme.
   *
   * @param url - The URL of the data to download
   * @returns The response object fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const data = await storage.download(uri);
   * ```
   */ async download(url, options) {
        return this.downloader.download(url, this.gatewayUrls, options);
    }
    /**
   * Downloads JSON data from any URL scheme.
   * Resolves any URLs with schemes to retrievable gateway URLs.
   *
   * @param url - The URL of the JSON data to download
   * @returns The JSON data fetched from the resolved URL
   *
   * @example
   * ```jsx
   * const uri = "ipfs://example";
   * const json = await storage.downloadJSON(uri);
   * ```
   */ async downloadJSON(url, options) {
        const res = await this.download(url, options);
        // If we get a JSON object, recursively replace any schemes with gatewayUrls
        const json = await res.json();
        return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);
    }
    /**
   * Upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns  The URI of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload file data
   * const file = readFileSync("../file.jpg");
   * const fileUri = await storage.upload(file);
   *
   * // Or upload a JSON object
   * const json = { name: "JSON", image: file };
   * const jsonUri = await storage.upload(json);
   * ```
   */ async upload(data, options) {
        const [uri] = await this.uploadBatch([
            data
        ], options);
        return uri;
    }
    /**
   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.
   * Automatically uploads any file data within JSON objects and replaces them with hashes.
   *
   * @param data - Array of arbitrary file or JSON data to upload
   * @param options - Options to pass through to the storage uploader class
   * @returns  The URIs of the uploaded data
   *
   * @example
   * ```jsx
   * // Upload an array of file data
   * const files = [
   *  readFileSync("../file1.jpg"),
   *  readFileSync("../file2.jpg"),
   * ];
   * const fileUris = await storage.uploadBatch(files);
   *
   * // Upload an array of JSON objects
   * const objects = [
   *  { name: "JSON 1", image: files[0] },
   *  { name: "JSON 2", image: files[1] },
   * ];
   * const jsonUris = await storage.uploadBatch(objects);
   * ```
   */ async uploadBatch(data, options) {
        data = data.filter((item)=>item !== undefined);
        if (!data.length) {
            return [];
        }
        const isFileArray = data.map((item)=>isFileOrBuffer(item) || typeof item === "string").every((item)=>!!item);
        let uris = [];
        // If data is an array of files, pass it through to upload directly
        if (isFileArray) {
            uris = await this.uploader.uploadBatch(data, options);
        } else {
            // Otherwise it is an array of JSON objects, so we have to prepare it first
            const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map((item)=>{
                if (typeof item === "string") {
                    return item;
                }
                return JSON.stringify(item);
            });
            uris = await this.uploader.uploadBatch(metadata, options);
        }
        if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
            return uris.map((uri)=>this.resolveScheme(uri));
        } else {
            return uris;
        }
    }
    getGatewayUrls() {
        return this.gatewayUrls;
    }
    async uploadAndReplaceFilesWithHashes(data, options) {
        let cleaned = data;
        // Replace any gateway URLs with their hashes
        cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);
        // Recurse through data and extract files to upload
        const files = extractObjectFiles(cleaned);
        if (files.length) {
            // Upload all files that came from the object
            const uris = await this.uploader.uploadBatch(files, options);
            // Recurse through data and replace files with hashes
            cleaned = replaceObjectFilesWithUris(cleaned, uris);
        }
        if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {
            // If flag is set, replace all schemes with their preferred gateway URL
            // Ex: used for Solana, where services don't resolve schemes for you, so URLs must be usable by default
            cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);
        }
        return cleaned;
    }
}
/**
 * @internal
 */ class MockDownloader {
    gatewayUrls = DEFAULT_GATEWAY_URLS;
    constructor(storage){
        this.storage = storage;
    }
    async download(url) {
        const [cid, name] = url.includes("mock://") ? url.replace("mock://", "").split("/") : url.replace("ipfs://", "").split("/");
        const data = name ? this.storage[cid][name] : this.storage[cid];
        return {
            async json () {
                return Promise.resolve(JSON.parse(data));
            },
            async text () {
                return Promise.resolve(data);
            }
        };
    }
}
/**
 * @internal
 */ class MockUploader {
    constructor(storage){
        this.storage = storage;
    }
    async uploadBatch(data, options) {
        const cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])();
        const uris = [];
        this.storage[cid] = {};
        let index = options?.rewriteFileNames?.fileStartNumber || 0;
        for (const file of data){
            let contents;
            if (isFileInstance(file)) {
                contents = await file.text();
            } else if (isBufferInstance(file)) {
                contents = file.toString();
            } else if (typeof file === "string") {
                contents = file;
            } else {
                contents = isBufferInstance(file.data) ? file.data.toString() : file.data;
                const name = file.name ? file.name : `file_${index}`;
                this.storage[cid][name] = contents;
                uris.push(`mock://${cid}/${name}`);
                continue;
            }
            this.storage[cid][index.toString()] = contents;
            uris.push(`mock://${cid}/${index}`);
            index += 1;
        }
        return uris;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/generated-abis/dist/thirdweb-dev-generated-abis.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GENERATED_ABI": (()=>GENERATED_ABI)
});
const GENERATED_ABI = {};
;
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/auth/dist/auth-9bd95804.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "A": (()=>AuthenticationPayloadDataSchema),
    "G": (()=>GenerateOptionsSchema),
    "J": (()=>JsonSchema),
    "L": (()=>LoginOptionsSchema),
    "R": (()=>RawDateSchema),
    "T": (()=>ThirdwebAuth),
    "V": (()=>VerifyOptionsSchema),
    "a": (()=>authenticateJWT),
    "b": (()=>buildJWT),
    "c": (()=>buildLoginPayload),
    "d": (()=>buildAndSignLoginPayload),
    "e": (()=>AuthenticationPayloadSchema),
    "f": (()=>AuthenticateOptionsSchema),
    "g": (()=>generateJWT),
    "h": (()=>AddressSchema),
    "i": (()=>AccountTypeSchema),
    "j": (()=>LoginPayloadDataSchema),
    "k": (()=>LoginPayloadSchema),
    "l": (()=>LoginPayloadOutputSchema),
    "m": (()=>RefreshOptionsSchema),
    "n": (()=>THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE),
    "o": (()=>THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX),
    "p": (()=>parseJWT),
    "q": (()=>THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS),
    "r": (()=>refreshJWT),
    "s": (()=>signLoginPayload),
    "t": (()=>THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS),
    "v": (()=>verifyLoginPayload)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$utils$2d$f58e7acc$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__checkContractWalletSignature$3e$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/wallets/dist/utils-f58e7acc.browser.esm.js [app-client] (ecmascript) <export c as checkContractWalletSignature>");
;
;
;
;
const literalSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null()
]);
const JsonSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        literalSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(JsonSchema),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(JsonSchema)
    ]), {
    invalid_type_error: "Provided value was not valid JSON"
});
const AddressSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().refine((arg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].isAddress(arg), (out)=>{
    return {
        message: `${out} is not a valid address`
    };
});
const RawDateSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().transform((i)=>{
    return Math.floor(i.getTime() / 1000);
});
const AccountTypeSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("evm");
const AuthenticationPayloadDataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    iss: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    sub: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    aud: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    exp: RawDateSchema,
    nbf: RawDateSchema,
    iat: RawDateSchema,
    jti: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()),
    ctx: JsonSchema.optional()
});
const AuthenticationPayloadSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    payload: AuthenticationPayloadDataSchema,
    signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
const AuthenticateOptionsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    issuerAddress: AddressSchema.optional(),
    validateTokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].function().args(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional()
});
const VerifyOptionsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    statement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    chainId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    validateNonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].function().args(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional(),
    resources: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional()
});
const THIRDWEB_AUTH_COOKIE_PREFIX = `thirdweb_auth`;
const THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX = `${THIRDWEB_AUTH_COOKIE_PREFIX}_token`;
const THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE = `${THIRDWEB_AUTH_COOKIE_PREFIX}_active_account`;
const THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS = 60 * 10;
const THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS = 60 * 60 * 24;
const THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS = 5;
const GenerateOptionsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    expirationTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(()=>new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS)),
    invalidBefore: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().optional(),
    session: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        JsonSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].function().args(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
    ]).optional(),
    verifyOptions: VerifyOptionsSchema.omit({
        domain: true
    }).optional()
});
const RefreshOptionsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    expirationTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(()=>new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS))
});
const LoginOptionsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    statement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    chainId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    nonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    expirationTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(()=>new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),
    invalidBefore: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(()=>new Date(Date.now() - 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),
    resources: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional()
});
const LoginPayloadDataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: AccountTypeSchema,
    domain: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    statement: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default("Please ensure that the domain above matches the URL of the current website."),
    uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default("1"),
    chain_id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    nonce: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])()),
    issued_at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(new Date()).transform((d)=>d.toISOString()),
    expiration_time: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().transform((d)=>d.toISOString()),
    invalid_before: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().default(new Date()).transform((d)=>d.toISOString()),
    resources: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).optional()
});
const LoginPayloadSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    payload: LoginPayloadDataSchema,
    signature: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
const LoginPayloadOutputSchema = LoginPayloadSchema.extend({
    payload: LoginPayloadDataSchema.extend({
        issued_at: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        expiration_time: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        invalid_before: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    })
});
async function verifySignature(message, signature, address, chainId, clientId, secretKey) {
    try {
        const messageHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hashMessage(message);
        const messageHashBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].arrayify(messageHash);
        const recoveredAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].recoverAddress(messageHashBytes, signature);
        if (recoveredAddress === address) {
            return true;
        }
    } catch  {
    // no-op
    }
    if (!chainId) {
        return false;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$wallets$2f$dist$2f$utils$2d$f58e7acc$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__c__as__checkContractWalletSignature$3e$__["checkContractWalletSignature"])(message, signature, address, chainId, clientId, secretKey);
}
/**
 * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload
 */ function createLoginMessage(payload) {
    const typeField = "Ethereum";
    const header = `${payload.domain} wants you to sign in with your ${typeField} account:`;
    let prefix = [
        header,
        payload.address
    ].join("\n");
    prefix = [
        prefix,
        payload.statement
    ].join("\n\n");
    if (payload.statement) {
        prefix += "\n";
    }
    const suffixArray = [];
    if (payload.uri) {
        const uriField = `URI: ${payload.uri}`;
        suffixArray.push(uriField);
    }
    const versionField = `Version: ${payload.version}`;
    suffixArray.push(versionField);
    if (payload.chain_id) {
        const chainField = `Chain ID: ` + payload.chain_id || "1";
        suffixArray.push(chainField);
    }
    const nonceField = `Nonce: ${payload.nonce}`;
    suffixArray.push(nonceField);
    const issuedAtField = `Issued At: ${payload.issued_at}`;
    suffixArray.push(issuedAtField);
    const expiryField = `Expiration Time: ${payload.expiration_time}`;
    suffixArray.push(expiryField);
    if (payload.invalid_before) {
        const invalidBeforeField = `Not Before: ${payload.invalid_before}`;
        suffixArray.push(invalidBeforeField);
    }
    if (payload.resources) {
        suffixArray.push([
            `Resources:`,
            ...payload.resources.map((x)=>`- ${x}`)
        ].join("\n"));
    }
    const suffix = suffixArray.join("\n");
    return [
        prefix,
        suffix
    ].join("\n");
}
async function buildLoginPayload(_ref) {
    let { wallet, options } = _ref;
    const parsedOptions = LoginOptionsSchema.parse(options);
    let chainId = parsedOptions?.chainId;
    if (!chainId && wallet.getChainId) {
        try {
            chainId = (await wallet.getChainId()).toString();
        } catch  {
        // ignore error
        }
    }
    return LoginPayloadDataSchema.parse({
        type: wallet.type,
        domain: parsedOptions.domain,
        address: parsedOptions?.address || await wallet.getAddress(),
        statement: parsedOptions?.statement,
        version: parsedOptions?.version,
        uri: parsedOptions?.uri,
        chain_id: chainId,
        nonce: parsedOptions?.nonce,
        expiration_time: parsedOptions.expirationTime,
        invalid_before: parsedOptions.invalidBefore,
        resources: parsedOptions?.resources
    });
}
async function signLoginPayload(_ref2) {
    let { wallet, payload } = _ref2;
    const message = createLoginMessage(payload);
    const signature = await wallet.signMessage(message);
    return {
        payload,
        signature
    };
}
async function buildAndSignLoginPayload(_ref3) {
    let { wallet, options } = _ref3;
    const payload = await buildLoginPayload({
        wallet,
        options
    });
    return signLoginPayload({
        wallet,
        payload
    });
}
async function verifyLoginPayload(_ref4) {
    let { payload, options, clientOptions } = _ref4;
    const parsedOptions = VerifyOptionsSchema.parse(options);
    // Check that the intended domain matches the domain of the payload
    if (payload.payload.domain !== parsedOptions.domain) {
        throw new Error(`Expected domain '${parsedOptions.domain}' does not match domain on payload '${payload.payload.domain}'`);
    }
    // Check that the payload statement matches the expected statement
    if (parsedOptions?.statement) {
        if (payload.payload.statement !== parsedOptions.statement) {
            throw new Error(`Expected statement '${parsedOptions.statement}' does not match statement on payload '${payload.payload.statement}'`);
        }
    }
    // Check that the intended URI matches the URI of the payload
    if (parsedOptions?.uri) {
        if (payload.payload.uri !== parsedOptions.uri) {
            throw new Error(`Expected URI '${parsedOptions.uri}' does not match URI on payload '${payload.payload.uri}'`);
        }
    }
    // Check that the intended version matches the version of the payload
    if (parsedOptions?.version) {
        if (payload.payload.version !== parsedOptions.version) {
            throw new Error(`Expected version '${parsedOptions.version}' does not match version on payload '${payload.payload.version}'`);
        }
    }
    // Check that the intended chain ID matches the chain ID of the payload
    if (parsedOptions?.chainId) {
        if (payload.payload.chain_id !== parsedOptions.chainId) {
            throw new Error(`Expected chain ID '${parsedOptions.chainId}' does not match chain ID on payload '${payload.payload.chain_id}'`);
        }
    }
    // Check that the payload nonce is valid
    if (parsedOptions?.validateNonce !== undefined) {
        try {
            await parsedOptions.validateNonce(payload.payload.nonce);
        } catch (err) {
            throw new Error(`Login request nonce is invalid`);
        }
    }
    // Check that it isn't before the invalid before time
    const currentTime = new Date();
    if (currentTime < new Date(payload.payload.invalid_before)) {
        throw new Error(`Login request is not yet valid`);
    }
    // Check that the payload hasn't expired
    if (currentTime > new Date(payload.payload.expiration_time)) {
        throw new Error(`Login request has expired`);
    }
    // Check that the specified resources are present on the payload
    if (parsedOptions?.resources) {
        const missingResources = parsedOptions.resources.filter((resource)=>!payload.payload.resources?.includes(resource));
        if (missingResources.length > 0) {
            throw new Error(`Login request is missing required resources: ${missingResources.join(", ")}`);
        }
    }
    // Check that the signing address is the claimed wallet address
    const message = createLoginMessage(payload.payload);
    const chainId = payload.payload.chain_id ? parseInt(payload.payload.chain_id) : undefined;
    const verified = await verifySignature(message, payload.signature, payload.payload.address, chainId, clientOptions?.clientId, clientOptions?.secretKey);
    if (!verified) {
        throw new Error(`Signer address does not match payload address '${payload.payload.address.toLowerCase()}'`);
    }
    return payload.payload.address;
}
function base64encode(data) {
    {
        return window.btoa(data);
    }
}
function base64decode(data) {
    {
        return window.atob(data);
    }
}
/**
 * Build JWT token based on the authentication payload
 */ async function buildJWT(_ref) {
    let { wallet, payload } = _ref;
    const payloadData = AuthenticationPayloadDataSchema.parse(payload);
    const message = JSON.stringify(payloadData);
    const signature = await wallet.signMessage(message);
    // Header used for JWT token specifying hash algorithm
    const header = {
        // Specify ECDSA with SHA-256 for hashing algorithm
        alg: "ES256",
        typ: "JWT"
    };
    const encodedHeader = base64encode(JSON.stringify(header));
    const encodedData = base64encode(JSON.stringify(payloadData));
    const encodedSignature = base64encode(signature);
    // Generate a JWT with base64 encoded header, payload, and signature
    const jwt = `${encodedHeader}.${encodedData}.${encodedSignature}`;
    return jwt;
}
/**
 * Generate a new JWT using a login payload
 */ async function generateJWT(_ref2) {
    let { wallet, payload, options, clientOptions } = _ref2;
    const parsedOptions = GenerateOptionsSchema.parse(options);
    const userAddress = await verifyLoginPayload({
        payload,
        options: {
            domain: parsedOptions.domain,
            ...parsedOptions.verifyOptions
        },
        clientOptions
    });
    let session = undefined;
    if (typeof parsedOptions?.session === "function") {
        const sessionTrigger = await parsedOptions.session(userAddress);
        if (sessionTrigger) {
            session = sessionTrigger;
        }
    } else {
        session = parsedOptions?.session;
    }
    const adminAddress = await wallet.getAddress();
    return buildJWT({
        wallet,
        payload: {
            iss: adminAddress,
            sub: userAddress,
            aud: parsedOptions.domain,
            nbf: parsedOptions?.invalidBefore || new Date(),
            exp: parsedOptions.expirationTime,
            iat: new Date(),
            jti: parsedOptions?.tokenId,
            ctx: session
        }
    });
}
/**
 * Parse data from an encoded auth JWT
 */ function parseJWT(jwt) {
    const encodedPayload = jwt.split(".")[1];
    const encodedSignature = jwt.split(".")[2];
    const payload = JSON.parse(base64decode(encodedPayload));
    const signature = base64decode(encodedSignature);
    return {
        payload,
        signature
    };
}
/**
 * Refresh an existing JWT
 */ async function refreshJWT(_ref3) {
    let { wallet, jwt, options } = _ref3;
    const { payload } = parseJWT(jwt);
    const parsedOptions = RefreshOptionsSchema.parse(options);
    return buildJWT({
        wallet,
        payload: {
            iss: payload.iss,
            sub: payload.sub,
            aud: payload.aud,
            nbf: new Date(),
            exp: parsedOptions.expirationTime,
            iat: new Date(),
            ctx: payload.ctx
        }
    });
}
/**
 * Validate a JWT and extract the user's info
 */ async function authenticateJWT(_ref4) {
    let { wallet, jwt, options, clientOptions } = _ref4;
    const parsedOptions = AuthenticateOptionsSchema.parse(options);
    const { payload, signature } = parseJWT(jwt);
    // Check that the payload unique ID is valid
    if (parsedOptions?.validateTokenId !== undefined) {
        try {
            await parsedOptions.validateTokenId(payload.jti);
        } catch (err) {
            throw new Error(`Token ID is invalid`);
        }
    }
    // Check that the token audience matches the domain
    if (payload.aud !== parsedOptions.domain) {
        throw new Error(`Expected token to be for the domain '${parsedOptions.domain}', but found token with domain '${payload.aud}'`);
    }
    // Check that the token is past the invalid before time
    const currentTime = Math.floor(new Date().getTime() / 1000);
    if (currentTime < payload.nbf) {
        throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);
    }
    // Check that the token hasn't expired
    if (currentTime > payload.exp) {
        throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);
    }
    // Check that the connected wallet matches the token issuer
    const issuerAddress = parsedOptions.issuerAddress ? parsedOptions.issuerAddress : await wallet.getAddress();
    if (issuerAddress.toLowerCase() !== payload.iss.toLowerCase()) {
        throw new Error(`The expected issuer address '${issuerAddress}' did not match the token issuer address '${payload.iss}'`);
    }
    let chainId = undefined;
    if (wallet.getChainId) {
        try {
            chainId = await wallet.getChainId();
        } catch  {
        // ignore error
        }
    }
    const verified = await verifySignature(JSON.stringify(payload), signature, issuerAddress, chainId, clientOptions.clientId, clientOptions.secretKey);
    if (!verified) {
        throw new Error(`The expected signer address '${issuerAddress}' did not sign the token`);
    }
    return {
        address: payload.sub,
        session: payload.ctx
    };
}
class ThirdwebAuth {
    constructor(wallet, domain){
        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        this.wallet = wallet;
        this.domain = domain;
        this.options = options;
    }
    updateWallet(wallet) {
        this.wallet = wallet;
    }
    async payload(options) {
        return buildLoginPayload({
            wallet: this.wallet,
            options: this.formatOptions(options)
        });
    }
    async loginWithPayload(payload) {
        return signLoginPayload({
            wallet: this.wallet,
            payload
        });
    }
    async login(options) {
        return buildAndSignLoginPayload({
            wallet: this.wallet,
            options: this.formatOptions(options)
        });
    }
    async verify(payload, options) {
        return verifyLoginPayload({
            payload,
            options: this.formatOptions(options),
            clientOptions: this.options
        });
    }
    async generate(payload, options) {
        return generateJWT({
            wallet: this.wallet,
            payload,
            options: this.formatOptions(options),
            clientOptions: this.options
        });
    }
    async refresh(jwt, expirationTime) {
        return refreshJWT({
            wallet: this.wallet,
            jwt,
            options: {
                expirationTime
            }
        });
    }
    async authenticate(jwt, options) {
        return authenticateJWT({
            wallet: this.wallet,
            jwt,
            options: this.formatOptions(options),
            clientOptions: this.options
        });
    }
    parseToken(jwt) {
        return parseJWT(jwt);
    }
    formatOptions(options) {
        return options ? {
            ...options,
            domain: options?.domain || this.domain
        } : {
            domain: this.domain
        };
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/auth/dist/auth-9bd95804.browser.esm.js [app-client] (ecmascript) <export T as ThirdwebAuth>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ThirdwebAuth": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$thirdweb$2d$dev$2f$auth$2f$dist$2f$auth$2d$9bd95804$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$thirdweb$2d$dev$2f$auth$2f$dist$2f$auth$2d$9bd95804$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/auth/dist/auth-9bd95804.browser.esm.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/auth/dist/auth-9bd95804.browser.esm.js [app-client] (ecmascript) <export s as signLoginPayload>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "signLoginPayload": (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$thirdweb$2d$dev$2f$auth$2f$dist$2f$auth$2d$9bd95804$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$react$2d$core$2f$node_modules$2f40$thirdweb$2d$dev$2f$auth$2f$dist$2f$auth$2d$9bd95804$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/auth/dist/auth-9bd95804.browser.esm.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/@thirdweb-dev/payments/dist/thirdweb-dev-payments.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// UNCHANGED: MERGE BETWEEN sdk-common-utilities/settings and js-client-sdk/settings
__turbopack_context__.s({
    "CHECKOUT_WITH_CARD_IFRAME_URL": (()=>CHECKOUT_WITH_CARD_IFRAME_URL),
    "CHECKOUT_WITH_ETH_IFRAME_URL": (()=>CHECKOUT_WITH_ETH_IFRAME_URL),
    "CREATE_WALLET_IFRAME_URL": (()=>CREATE_WALLET_IFRAME_URL),
    "ChainIdToChain": (()=>ChainIdToChain),
    "ChainToPublicRpc": (()=>ChainToPublicRpc),
    "DEFAULT_BRAND_OPTIONS": (()=>DEFAULT_BRAND_OPTIONS),
    "PAPER_APP_URL": (()=>PAPER_APP_URL),
    "PAY_WITH_ETH_ERROR": (()=>PAY_WITH_ETH_ERROR),
    "PayWithCryptoErrorCode": (()=>PayWithCryptoErrorCode),
    "PaymentsSDKErrorCode": (()=>PaymentsSDKErrorCode),
    "checkAndSendEth": (()=>checkAndSendEth),
    "createCheckoutWithCardElement": (()=>createCheckoutWithCardElement),
    "createCheckoutWithCardLink": (()=>createCheckoutWithCardLink),
    "createCheckoutWithCardMessageHandler": (()=>createCheckoutWithCardMessageHandler),
    "createCheckoutWithEthElement": (()=>createCheckoutWithEthElement),
    "createCheckoutWithEthLink": (()=>createCheckoutWithEthLink),
    "createCheckoutWithEthMessageHandler": (()=>createCheckoutWithEthMessageHandler),
    "getPaperOriginUrl": (()=>getPaperOriginUrl),
    "renderPaperCheckoutLink": (()=>renderPaperCheckoutLink)
});
const isDev = ()=>{
    return !!(window.localStorage.getItem("IS_PAPER_DEV") === "true");
};
const isOldPaperDomain = ()=>window.location.hostname === "paper.xyz" || window.location.hostname.endsWith(".paper.xyz");
const isThirdwebDomain = ()=>window.location.hostname === "thirdweb.com" || window.location.hostname.endsWith(".thirdweb.com");
const getPaperOriginUrl = ()=>{
    if (isDev()) {
        return window.localStorage.getItem("PAPER_DEV_URL") ?? "http://localhost:3000";
    }
    if (isOldPaperDomain()) {
        return window.location.origin;
    }
    if (isThirdwebDomain()) {
        return window.location.origin;
    }
    return "https://payments.thirdweb.com";
};
// eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
const PAPER_APP_URL = getPaperOriginUrl();
const CHECKOUT_WITH_ETH_IFRAME_URL = "/sdk/2022-08-12/checkout-with-eth";
const CHECKOUT_WITH_CARD_IFRAME_URL = "/sdk/2022-08-12/checkout-with-card";
const CREATE_WALLET_IFRAME_URL = "/sdk/v2/verify-email";
// UNCHANGED: MERGED FROM sdk-common-utilities/blockchain
const ChainToPublicRpc = {
    Ethereum: "https://ethereum.rpc.thirdweb.com",
    Goerli: "https://goerli.rpc.thirdweb.com",
    Mumbai: "https://mumbai.rpc.thirdweb.com",
    Polygon: "https://polygon.rpc.thirdweb.com",
    Avalanche: "https://avalanche.rpc.thirdweb.com",
    Optimism: "https://optimism.rpc.thirdweb.com",
    OptimismGoerli: "https://optimism-goerli.rpc.thirdweb.com",
    BSC: "https://binance.rpc.thirdweb.com",
    BSCTestnet: "https://binance-testnet.rpc.thirdweb.com",
    ArbitrumOne: "https://arbitrum.rpc.thirdweb.com",
    ArbitrumGoerli: "https://arbitrum-goerli.rpc.thirdweb.com",
    Fantom: "https://fantom.rpc.thirdweb.com",
    FantomTestnet: "https://fantom-testnet.rpc.thirdweb.com",
    Sepolia: "https://sepolia.rpc.thirdweb.com",
    AvalancheFuji: "https://avalanche-fuji.rpc.thirdweb.com"
};
const ChainIdToChain = {
    1: "Ethereum",
    5: "Goerli",
    80001: "Mumbai",
    137: "Polygon",
    43114: "Avalanche",
    10: "Optimism",
    420: "OptimismGoerli",
    56: "BSC",
    97: "BSCTestnet",
    42161: "ArbitrumOne",
    421613: "ArbitrumGoerli",
    250: "Fantom",
    4002: "FantomTestnet",
    11155111: "Sepolia",
    43113: "AvalancheFuji"
};
// General Embedded wallet types
// // UNCHANGED: MERGED FROM sdk-common-utilities/style
const DEFAULT_BRAND_OPTIONS = {
    colorPrimary: "#cf3781",
    colorBackground: "#ffffff",
    colorText: "#1a202c",
    borderRadius: 12,
    fontFamily: "Open Sans"
};
// CHANGED: Updated name to Payments
let PaymentsSDKErrorCode = /*#__PURE__*/ function(PaymentsSDKErrorCode) {
    PaymentsSDKErrorCode["UserAbandonedCheckout"] = "User abandoned the checkout";
    PaymentsSDKErrorCode["UserLoginFailed"] = "User login failed";
    PaymentsSDKErrorCode["InvalidProps"] = "The props you passed in to this component are not valid.";
    PaymentsSDKErrorCode["InvalidCard"] = "The card information is invalid. Please double check that the Card, CVC, and Zip code are all correct.";
    PaymentsSDKErrorCode["EmailNotVerified"] = "The email was unable to be verified.";
    PaymentsSDKErrorCode["NotEnoughSupply"] = "There is not enough supply to claim.";
    PaymentsSDKErrorCode["AddressNotAllowed"] = "This address is not on the allowlist.";
    PaymentsSDKErrorCode["NoActiveClaimPhase"] = "There is no active claim phase at the moment.";
    return PaymentsSDKErrorCode;
}({});
let PayWithCryptoErrorCode = /*#__PURE__*/ function(PayWithCryptoErrorCode) {
    PayWithCryptoErrorCode["ErrorConnectingToWallet"] = "Error connecting to wallet";
    PayWithCryptoErrorCode["ErrorSendingTransaction"] = "Something went wrong sending transaction";
    PayWithCryptoErrorCode["InsufficientBalance"] = "Insufficient ETH";
    PayWithCryptoErrorCode["TransactionCancelled"] = "Transaction Cancelled";
    PayWithCryptoErrorCode["WrongChain"] = "Wrong Chain Detected";
    PayWithCryptoErrorCode["ChainSwitchUnderway"] = "There is a network switch already underway";
    PayWithCryptoErrorCode["PendingSignature"] = "Pending Signature";
    return PayWithCryptoErrorCode;
}({});
// CHANGED: added clientId to link
class LinksManager {
    constructor(baseLink){
        this.link = baseLink;
    }
    addStylingOptions(options) {
        if (options.colorPrimary) {
            this.link.searchParams.set("colorPrimary", options.colorPrimary);
        }
        if (options.colorBackground) {
            this.link.searchParams.set("colorBackground", options.colorBackground);
        }
        if (options.colorText) {
            this.link.searchParams.set("colorText", options.colorText);
        }
        if (options.borderRadius !== undefined) {
            this.link.searchParams.set("borderRadius", options.borderRadius.toString());
        }
        if (options.fontFamily) {
            this.link.searchParams.set("fontFamily", options.fontFamily);
        }
        if (options.inputBackgroundColor) {
            this.link.searchParams.set("inputBackgroundColor", options.inputBackgroundColor);
        }
        if (options.inputBorderColor) {
            this.link.searchParams.set("inputBorderColor", options.inputBorderColor);
        }
    }
    addClientSecret(sdkClientSecret) {
        this.link.searchParams.set("sdkClientSecret", sdkClientSecret);
    }
    addClientId(clientId) {
        this.link.searchParams.set("clientId", clientId);
    }
    addLocale(locale) {
        if (locale) {
            this.link.searchParams.set("locale", locale.toString());
        }
    }
    addOTP() {
        this.link.searchParams.set("withOTP", "true");
    }
    addAppName(appName) {
        if (appName) {
            this.link.searchParams.set("appName", appName);
        }
    }
    addShowConnectWalletOptions(showConnectWalletOptions) {
        this.link.searchParams.append("showConnectWalletOptions", showConnectWalletOptions.toString());
    }
    addReceivingWalletType(walletType) {
        this.link.searchParams.append("walletType", walletType || "Preset");
    }
    addRecipientWalletAddress(address) {
        this.link.searchParams.set("recipientWalletAddress", address);
    }
    addPayerWalletAddress(address) {
        this.link.searchParams.append("payerWalletAddress", address);
    }
    addDate(date) {
        this.link.searchParams.set("date", date ? date.toString() : Date.now().toString());
    }
    getLink() {
        return this.link;
    }
}
// UNCHANGED
/**
 * Opens a popup centered on the current window.
 * Note that modern browsers may prevent popups from opening automatically,
 * so try to handle the case where the window returned is null.
 *
 * @returns Window | null - The Window object that was opened. If null is returned, the popup failed to open.
 */ const openCenteredPopup = (_ref)=>{
    let { url, width = 440, height = 700 } = _ref;
    if (!window?.top) {
        return null;
    }
    const y = window.top.outerHeight / 2 + window.top.screenY - height / 2;
    const x = window.top.outerWidth / 2 + window.top.screenX - width / 2;
    return window.open(url, "_blank", `popup=true,width=${width},height=${height},top=${y},left=${x}`);
};
// UNCHANGED
function postMessageToIframe(frame, eventType, data) {
    frame.contentWindow?.postMessage({
        eventType,
        ...data
    }, "*");
}
var packageJson = {
    name: "@thirdweb-dev/payments",
    version: "1.0.5",
    main: "dist/thirdweb-dev-payments.cjs.js",
    module: "dist/thirdweb-dev-payments.esm.js",
    types: "dist/thirdweb-dev-payments.cjs.d.ts",
    browser: {
        "./dist/thirdweb-dev-payments.esm.js": "./dist/thirdweb-dev-payments.browser.esm.js"
    },
    exports: {
        ".": {
            module: {
                browser: "./dist/thirdweb-dev-payments.browser.esm.js",
                "default": "./dist/thirdweb-dev-payments.esm.js"
            },
            "default": "./dist/thirdweb-dev-payments.cjs.js"
        },
        "./package.json": "./package.json"
    },
    repository: "https://github.com/thirdweb-dev/js/tree/main/legacy_packages/payments",
    license: "Apache-2.0",
    bugs: {
        url: "https://github.com/thirdweb-dev/js/issues"
    },
    author: "thirdweb eng <eng@thirdweb.com>",
    files: [
        "dist/"
    ],
    preconstruct: {
        entrypoints: [
            "index.ts"
        ],
        exports: {
            envConditions: [
                "browser"
            ]
        }
    },
    sideEffects: false,
    dependencies: {
        ethers: "^5.7.2"
    },
    devDependencies: {
        eslint: "8.57.0",
        "@preconstruct/cli": "2.7.0",
        "@thirdweb-dev/tsconfig": "^0.1.7",
        "eslint-config-thirdweb": "^0.1.9",
        typescript: "5.4.4"
    },
    scripts: {
        format: "prettier --write 'src/**/*'",
        lint: "eslint src/",
        fix: "eslint src/ --fix",
        clean: "rm -rf dist/",
        build: "tsc && preconstruct build",
        "preconstruct:fix": "preconstruct fix",
        push: "yalc push"
    }
};
// CHANGED: packageJson import + version string
class PaperPaymentElement {
    constructor(_ref){
        let { elementOrId, onLoad } = _ref;
        this.elementOrId = elementOrId;
        this.onLoad = onLoad;
    }
    createPaymentElement(_ref2) {
        let { handler, link, iframeId } = _ref2;
        const iframe = document.createElement("iframe");
        iframe.src = link.href;
        iframe.id = iframeId;
        iframe.allow = "payment";
        iframe.setAttribute("style", "margin-left:auto; margin-right:auto; width:100%; height: 100%; min-height:375px; transition-property:all; transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1); transition-duration:150ms; color-scheme: light;");
        iframe.onload = (event)=>{
            if (this.onLoad) {
                this.onLoad(event);
            }
        };
        iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
        if (!this.elementOrId) {
            window.addEventListener("message", handler(iframe));
            return iframe;
        }
        let container = this.elementOrId;
        if (typeof container === "string") {
            const domElement = document.getElementById(container);
            if (!domElement) {
                throw new Error("Invalid id given");
            }
            container = domElement;
        }
        const existing = container.querySelector("#" + iframeId);
        // if we already created an iframe, consider updating the iframe link if it's new
        if (existing) {
            if (existing.src === link.href) {
                return existing;
            }
            existing.src = link.href;
            return existing;
        }
        window.addEventListener("message", handler(iframe));
        return container.appendChild(iframe);
    }
}
function toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != typeof i) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == typeof i ? i : i + "";
}
function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const fullScreen$1 = {
    top: "0px",
    left: "0px",
    right: "0px",
    bottom: "0px"
};
const getDefaultModalStyles$1 = ()=>({
        main: {
            ...fullScreen$1,
            position: "fixed",
            zIndex: "10000",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            pointerEvents: "auto"
        },
        overlay: {
            ...fullScreen$1,
            position: "absolute",
            backgroundColor: "rgba(0, 0, 0, 0.33)",
            pointerEvents: "auto"
        },
        body: {
            background: "transparent",
            borderRadius: "12px",
            position: "relative",
            overflow: "hidden",
            width: "100%",
            maxWidth: "500px",
            height: "700px",
            maxHeight: "80%",
            animation: "pew-modal-slideIn 0.2s forwards",
            pointerEvents: "auto"
        },
        spinner: {
            position: "absolute",
            top: "0",
            bottom: "0",
            left: "0",
            right: "0",
            margin: "auto",
            borderWidth: "3px",
            borderColor: "#2D3748 #2D3748 transparent transparent",
            borderRadius: "50%",
            width: "30px",
            height: "30px",
            animation: "spin 1s linear infinite"
        },
        iframe: {
            position: "relative",
            height: "100%",
            width: "100%",
            border: "none",
            background: "transparent"
        }
    });
const modalKeyframeAnimations = `
  @keyframes pew-modal-slideIn {
    from {opacity: 0; transform: translate3d(0, 20px, 0);}
    to {opacity: 1; transform: translate3d(0, 0, 0);}
  }

  @keyframes pew-modal-slideOut {
    from {opacity: 1; transform: translate3d(0, 0, 0);}
    to {opacity: 0; transform: translate3d(0, 20px, 0);}
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
`;
const MODAL_ID = "paper-js-sdk-modal";
class Modal {
    constructor(container, styles){
        // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
        _defineProperty(this, "styles", getDefaultModalStyles$1());
        this.container = container || document.body;
        if (styles) {
            this.mergeStyles(styles);
        }
        this.main = document.createElement("div");
        this.main.id = MODAL_ID;
        this.overlay = document.createElement("div");
        this.overlay.id = `${MODAL_ID}-overlay`;
        this.body = document.createElement("div");
        this.body.id = `${MODAL_ID}-body`;
        this.spinner = document.createElement("div");
        this.spinner.id = `${MODAL_ID}-spinner`;
        this.iframe = document.createElement("iframe");
        this.iframe.id = `${MODAL_ID}-iframe`;
        this.iframe.allow = "camera; microphone; payment";
        this.iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
        this.style = document.createElement("style");
        this.style.innerHTML = modalKeyframeAnimations;
        this.assignStyles(this.main, this.styles.main);
        this.assignStyles(this.overlay, this.styles.overlay);
        this.assignStyles(this.body, this.styles.body);
        this.assignStyles(this.spinner, this.styles.spinner);
        this.assignStyles(this.iframe, this.styles.iframe);
    }
    open() {
        let { iframeUrl } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (iframeUrl) {
            this.body.appendChild(this.spinner);
            this.iframe.src = iframeUrl;
            // Remove the spinner when the iframe loads.
            this.iframe.onload = ()=>this.body.removeChild(this.spinner);
            this.body.appendChild(this.iframe);
        }
        this.addAccessibility();
        this.main.appendChild(this.overlay);
        this.main.appendChild(this.style);
        this.main.appendChild(this.body);
        this.container.appendChild(this.main);
        document.body.style.overflow = "hidden";
    }
    close() {
        this.body.style.animation = "pew-modal-slideOut 0.2s forwards";
        window.setTimeout(()=>this.main.remove(), 250);
    }
    mergeStyles(styles) {
        this.styles.body = {
            ...this.styles.body,
            ...styles.body || {}
        };
        this.styles.spinner = {
            ...this.styles.spinner,
            ...styles.spinner || {}
        };
        this.styles.overlay = {
            ...this.styles.overlay,
            ...styles.overlay || {}
        };
        this.styles.main = {
            ...this.styles.main,
            ...styles.main || {}
        };
        this.styles.iframe = {
            ...this.styles.iframe,
            ...styles.iframe || {}
        };
    }
    addAccessibility() {
        this.main.setAttribute("aria-hidden", "true");
        this.overlay.setAttribute("aria-hidden", "true");
        this.body.setAttribute("aria-modal", "true");
        this.body.setAttribute("role", "dialog");
    }
    assignStyles(el, styles) {
        Object.assign(el.style, styles);
    }
}
// CHANGED: Added clientId to interface
function createCheckoutWithCardLink(_ref) {
    let { clientId, sdkClientSecret, appName, options = {
        ...DEFAULT_BRAND_OPTIONS
    }, locale, configs } = _ref;
    const CheckoutWithCardUrlBase = new URL(CHECKOUT_WITH_CARD_IFRAME_URL, PAPER_APP_URL);
    let clientSecret = sdkClientSecret;
    if (!clientSecret && configs) {
        clientSecret = btoa(JSON.stringify(configs));
    }
    if (!clientSecret) {
        const error = `Must have either sdkClientSecret or configs field set. Received neither`;
        const destination = `/error?errorMessage=${error}`;
        const domain = getPaperOriginUrl();
        return new URL(destination, domain);
    }
    if (!clientId) {
        const error = `Must have clientId field set. Please add clientId`;
        const destination = `/error?errorMessage=${error}`;
        const domain = getPaperOriginUrl();
        return new URL(destination, domain);
    }
    const checkoutWithCardLink = new LinksManager(CheckoutWithCardUrlBase);
    checkoutWithCardLink.addClientId(clientId ?? "");
    checkoutWithCardLink.addClientSecret(clientSecret ?? "");
    checkoutWithCardLink.addStylingOptions(options);
    checkoutWithCardLink.addLocale(locale);
    checkoutWithCardLink.addAppName(appName);
    return checkoutWithCardLink.getLink();
}
function createCheckoutWithCardMessageHandler(_ref2) {
    let { iframe, onError, onReview, onPaymentSuccess, onBeforeModalOpen, onPriceUpdate } = _ref2;
    let modal;
    return (event)=>{
        if (!event.origin.startsWith(PAPER_APP_URL)) {
            return;
        }
        const { data } = event;
        switch(data.eventType){
            case "checkoutWithCardError":
                if (onError) {
                    onError({
                        code: data.code,
                        error: data.error
                    });
                }
                break;
            case "paymentSuccess":
                if (onPaymentSuccess) {
                    onPaymentSuccess({
                        transactionId: data.id,
                        id: data.id
                    });
                }
                if (data.postToIframe) {
                    postMessageToIframe(iframe, data.eventType, data);
                }
                break;
            case "reviewComplete":
                if (onReview) {
                    onReview({
                        id: data.id,
                        cardholderName: data.cardholderName
                    });
                }
                break;
            case "openModalWithUrl":
                if (onBeforeModalOpen && data.url && data.url.includes("promptKYCModal")) {
                    onBeforeModalOpen({
                        url: data.url
                    });
                } else {
                    modal = new Modal(undefined, {
                        body: {
                            colorScheme: "light"
                        }
                    });
                    modal.open({
                        iframeUrl: data.url
                    });
                }
                break;
            case "completedSDKModal":
                modal.close();
                if (data.postToIframe) {
                    postMessageToIframe(iframe, data.eventType, data);
                }
                break;
            case "requestedPopup":
                {
                    // The iframe requested a popup.
                    // The reference to this window is not stored so the popup cannot
                    // be programmatically closed.
                    const popupRef = openCenteredPopup({
                        url: data.url,
                        width: data.width,
                        height: data.height
                    });
                    if (!popupRef) {
                        console.error("CheckoutWithCard: Unable to open popup.");
                    }
                    break;
                }
            case "sizing":
                iframe.style.height = data.height + "px";
                iframe.style.maxHeight = data.height + "px";
                break;
            case "onPriceUpdate":
                {
                    onPriceUpdate?.(data);
                    break;
                }
        }
    };
}
function createCheckoutWithCardElement(_ref3) {
    let { clientId, onCloseKycModal, onOpenKycModal, sdkClientSecret, appName, elementOrId, onLoad, onError, locale, options, onPaymentSuccess, onReview, onBeforeModalOpen, onPriceUpdate, useAltDomain = true, configs } = _ref3;
    const checkoutWithCardId = "checkout-with-card-iframe";
    const checkoutWithCardMessageHandler = (iframe)=>createCheckoutWithCardMessageHandler({
            iframe,
            onCloseKycModal,
            onOpenKycModal,
            onError,
            onPaymentSuccess,
            onReview,
            onBeforeModalOpen,
            onPriceUpdate,
            useAltDomain
        });
    const checkoutWithCardUrl = createCheckoutWithCardLink({
        clientId,
        sdkClientSecret,
        appName,
        locale,
        options,
        useAltDomain,
        configs
    });
    const paymentElement = new PaperPaymentElement({
        onLoad,
        elementOrId
    });
    return paymentElement.createPaymentElement({
        handler: checkoutWithCardMessageHandler,
        iframeId: checkoutWithCardId,
        link: checkoutWithCardUrl
    });
}
// Changed: Updated PaperSDKError
const handlePayWithCryptoError = async (error, onError, postToParent)=>{
    if ("isErrorObject" in error) {
        if (onError) {
            await onError({
                code: error.title,
                error: new Error(error.title)
            });
        }
        if (postToParent) {
            postToParent({
                ...error
            });
        }
    } else if (!("message" in error)) {
        if (onError) {
            await onError({
                code: PayWithCryptoErrorCode.ErrorSendingTransaction,
                error: new Error(JSON.stringify(error))
            });
        }
        if (postToParent) {
            postToParent({
                description: `${error}`,
                title: PayWithCryptoErrorCode.ErrorSendingTransaction
            });
        }
    } else {
        if (error.message.includes("rejected") || error.message.includes("denied transaction")) {
            if (onError) {
                await onError({
                    code: PayWithCryptoErrorCode.TransactionCancelled,
                    error
                });
            }
            if (postToParent) {
                postToParent({
                    description: "",
                    title: PayWithCryptoErrorCode.TransactionCancelled
                });
            }
        } else if (error.message.includes("insufficient funds")) {
            if (onError) {
                await onError({
                    code: PayWithCryptoErrorCode.InsufficientBalance,
                    error
                });
            }
            if (postToParent) {
                postToParent({
                    description: "Check your wallet's ETH balance to make sure you have enough!",
                    title: PayWithCryptoErrorCode.InsufficientBalance
                });
            }
        } else if (error.message.includes("Error switching chain")) {
            if (onError) {
                await onError({
                    code: PayWithCryptoErrorCode.ChainSwitchUnderway,
                    error
                });
            }
            if (postToParent) {
                postToParent({
                    description: "Check your wallet app",
                    title: PayWithCryptoErrorCode.ChainSwitchUnderway
                });
            }
        } else {
            if (onError) {
                await onError({
                    code: PayWithCryptoErrorCode.ErrorSendingTransaction,
                    error
                });
            }
            if (postToParent) {
                postToParent({
                    description: `${error.message}`,
                    title: PayWithCryptoErrorCode.ErrorSendingTransaction
                });
            }
        }
    }
};
// CHANGED: Imports only
const PAY_WITH_ETH_ERROR = "payWithEthError";
async function checkAndSendEth(_ref) {
    let { data, iframe, payingWalletSigner, suppressErrorToast, onError, onPaymentSuccess } = _ref;
    try {
        const chainId = await payingWalletSigner.getChainId();
        if (chainId !== data.chainId) {
            throw {
                isErrorObject: true,
                title: PayWithCryptoErrorCode.WrongChain,
                description: `Please change to ${data.chainName} to proceed.`
            };
        }
    } catch (e) {
        await handlePayWithCryptoError(e, onError, (errorObject)=>{
            postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                error: errorObject,
                suppressErrorToast
            });
        });
        return;
    }
    // send the transaction
    try {
        console.log("sending funds...", data);
        const result = await payingWalletSigner.sendTransaction({
            chainId: data.chainId,
            data: data.blob,
            to: data.paymentAddress,
            value: data.value
        });
        const receipt = await result.wait();
        if (onPaymentSuccess && result) {
            await onPaymentSuccess({
                onChainTxResponse: result,
                onChainTxReceipt: receipt,
                transactionId: data.transactionId
            });
        }
        if (result) {
            postMessageToIframe(iframe, "paymentSuccess", {
                suppressErrorToast,
                transactionHash: result.hash
            });
        }
    } catch (error) {
        console.log("error sending funds", error);
        await handlePayWithCryptoError(error, onError, (errorObject)=>{
            postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                error: errorObject,
                suppressErrorToast
            });
        });
    }
}
function createCheckoutWithEthMessageHandler(_ref2) {
    let { iframe, onError, onPaymentSuccess, onPriceUpdate, payingWalletSigner, suppressErrorToast = false, setUpUserPayingWalletSigner } = _ref2;
    return async (event)=>{
        if (!event.origin.startsWith(PAPER_APP_URL)) {
            return;
        }
        const data = event.data;
        switch(data.eventType){
            case "payWithEth":
                {
                    if (data.error) {
                        await handlePayWithCryptoError(new Error(data.error), onError, (errorObject)=>{
                            postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                                error: errorObject,
                                suppressErrorToast
                            });
                        });
                        return;
                    }
                    // Allows Dev's to inject any chain switching for their custom signer here.
                    if (setUpUserPayingWalletSigner) {
                        try {
                            console.log("setting up signer");
                            await setUpUserPayingWalletSigner({
                                chainId: data.chainId,
                                chainName: data.chainName
                            });
                        } catch (error) {
                            console.log("error setting up signer", error);
                            await handlePayWithCryptoError(error, onError, (errorObject)=>{
                                postMessageToIframe(iframe, PAY_WITH_ETH_ERROR, {
                                    error: errorObject,
                                    suppressErrorToast
                                });
                            });
                            return;
                        }
                    }
                    await checkAndSendEth({
                        data,
                        iframe,
                        payingWalletSigner,
                        suppressErrorToast,
                        onError,
                        onPaymentSuccess
                    });
                    break;
                }
            case "checkout-with-eth-sizing":
                {
                    iframe.style.height = data.height + "px";
                    iframe.style.maxHeight = data.height + "px";
                    break;
                }
            case "onPriceUpdate":
                {
                    onPriceUpdate?.(data);
                    break;
                }
        }
    };
}
async function createCheckoutWithEthLink(_ref3) {
    let { sdkClientSecret, payingWalletSigner, receivingWalletType, showConnectWalletOptions = false, appName, locale, options = {
        ...DEFAULT_BRAND_OPTIONS
    }, configs } = _ref3;
    const checkoutWithEthUrlBase = new URL(CHECKOUT_WITH_ETH_IFRAME_URL, PAPER_APP_URL);
    const address = await payingWalletSigner.getAddress();
    let clientSecret = sdkClientSecret;
    if (!clientSecret && configs) {
        clientSecret = btoa(JSON.stringify(configs));
    }
    if (!clientSecret) {
        const error = `Must have either sdkClientSecret or configs field set. Received neither`;
        const destination = `/error?errorMessage=${error}`;
        const domain = getPaperOriginUrl();
        return new URL(destination, domain);
    }
    const checkoutWithEthLink = new LinksManager(checkoutWithEthUrlBase);
    checkoutWithEthLink.addClientSecret(clientSecret ?? "");
    checkoutWithEthLink.addRecipientWalletAddress(address);
    checkoutWithEthLink.addPayerWalletAddress(address);
    checkoutWithEthLink.addReceivingWalletType(receivingWalletType);
    checkoutWithEthLink.addAppName(appName);
    checkoutWithEthLink.addShowConnectWalletOptions(showConnectWalletOptions);
    checkoutWithEthLink.addStylingOptions(options);
    checkoutWithEthLink.addLocale(locale);
    return checkoutWithEthLink.getLink();
}
async function createCheckoutWithEthElement(_ref4) {
    let { sdkClientSecret, suppressErrorToast, onError, onLoad, payingWalletSigner, receivingWalletType, appName, showConnectWalletOptions, locale, options, elementOrId, onPaymentSuccess: _onPaymentSuccess, onSuccess } = _ref4;
    const onPaymentSuccess = _onPaymentSuccess ?? onSuccess;
    const checkoutWithEthId = "checkout-with-eth-iframe";
    const checkoutWithEthMessageHandler = (iframe)=>createCheckoutWithEthMessageHandler({
            iframe,
            onError,
            payingWalletSigner,
            suppressErrorToast,
            onPaymentSuccess
        });
    const checkoutWithEthUrl = await createCheckoutWithEthLink({
        payingWalletSigner,
        sdkClientSecret,
        appName,
        locale,
        options,
        receivingWalletType,
        showConnectWalletOptions
    });
    const paymentElement = new PaperPaymentElement({
        onLoad,
        elementOrId
    });
    return paymentElement.createPaymentElement({
        handler: checkoutWithEthMessageHandler,
        iframeId: checkoutWithEthId,
        link: checkoutWithEthUrl
    });
}
const fullScreen = {
    position: "fixed",
    top: "0px",
    left: "0px",
    right: "0px",
    bottom: "0px"
};
const getDefaultModalStyles = ()=>({
        main: {
            ...fullScreen,
            zIndex: "2147483646",
            display: "flex",
            alignItems: "center",
            justifyContent: "end"
        },
        overlay: {
            ...fullScreen,
            backgroundColor: "rgba(0, 0, 0, 0)",
            transition: "background-color ease-out 0.2s"
        },
        body: {
            position: "fixed",
            width: "100%",
            maxWidth: "420px",
            top: "0px",
            bottom: "0px",
            right: "-100px",
            opacity: "0",
            boxShadow: "0px 10px 20px rgba(0, 0, 0, 0.25)",
            backgroundColor: window.matchMedia("(prefers-color-scheme: dark)").matches ? "#2F2F2F" : "white",
            overflow: "hidden",
            transition: "all ease-out 0.2s"
        },
        spinner: {
            position: "absolute",
            top: "0",
            bottom: "0",
            left: "0",
            right: "0",
            margin: "auto",
            borderWidth: "3px",
            borderColor: "#2D3748 #2D3748 transparent transparent",
            borderRadius: "50%",
            width: "30px",
            height: "30px",
            animation: "spin 1s linear infinite"
        },
        iframe: {
            height: "100%",
            width: "100%",
            border: "none",
            backgroundColor: "transparent"
        },
        closeButton: {
            position: "fixed",
            cursor: "pointer",
            top: "0.75rem",
            right: "1rem",
            color: "#888",
            padding: "2px 8px"
        }
    });
const MAIN_CLASSNAME = "paper--drawer-main";
const OVERLAY_CLASSNAME = "paper--drawer-overlay";
const BODY_CLASSNAME = "paper--drawer-body";
const CLOSE_CLASSNAME = "paper--drawer-close";
class Drawer {
    constructor(container, styles){
        // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
        _defineProperty(this, "styles", getDefaultModalStyles());
        this.container = container || document.body;
        if (styles) {
            this.mergeStyles(styles);
        }
        this.main = document.createElement("div");
        this.main.className = MAIN_CLASSNAME;
        this.overlay = document.createElement("div");
        this.overlay.className = OVERLAY_CLASSNAME;
        this.body = document.createElement("div");
        this.body.className = BODY_CLASSNAME;
        this.closeButton = document.createElement("button");
        this.closeButton.className = CLOSE_CLASSNAME;
        this.closeButton.innerHTML = "&#x2715;";
        this.closeButton.onclick = ()=>{
            this.close();
        };
        this.iframe = document.createElement("iframe");
        this.iframe.allow = "camera; microphone; payment";
        this.iframe.setAttribute("data-thirdweb-sdk-version", `${packageJson.name}@${packageJson.version}`);
        this.assignStyles(this.main, this.styles.main);
        this.assignStyles(this.overlay, this.styles.overlay);
        this.assignStyles(this.body, this.styles.body);
        this.assignStyles(this.iframe, this.styles.iframe);
        if (this.styles.closeButton) {
            this.assignStyles(this.closeButton, this.styles.closeButton);
        }
    }
    open() {
        let { iframeUrl } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        if (iframeUrl) {
            this.iframe.src = iframeUrl;
            this.body.appendChild(this.iframe);
        }
        this.addAccessibility();
        this.main.appendChild(this.overlay);
        this.main.appendChild(this.body);
        this.main.appendChild(this.closeButton);
        this.container.appendChild(this.main);
        document.body.style.overflow = "hidden";
        // Animate in.
        this.overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        this.body.style.right = "0px";
        this.body.style.opacity = "1";
        return this.iframe;
    }
    close() {
        this.closeButton.remove();
        // Animate out.
        this.overlay.style.backgroundColor = "rgba(0, 0, 0, 0)";
        this.body.style.right = "-100px";
        this.body.style.opacity = "0";
        // Remove drawer from DOM.
        this.closeTimeout = window.setTimeout(()=>{
            document.body.style.overflow = "visible";
            this.main.remove();
            window.clearTimeout(this.closeTimeout);
            this.onCloseCallback?.();
        }, 250);
    }
    setOnCloseCallback(callback) {
        this.onCloseCallback = callback;
    }
    mergeStyles(styles) {
        this.styles.body = {
            ...this.styles.body,
            ...styles.body || {}
        };
        this.styles.overlay = {
            ...this.styles.overlay,
            ...styles.overlay || {}
        };
        this.styles.main = {
            ...this.styles.main,
            ...styles.main || {}
        };
        this.styles.iframe = {
            ...this.styles.iframe,
            ...styles.iframe || {}
        };
        this.styles.closeButton = {
            ...this.styles.closeButton,
            ...styles.closeButton || {}
        };
    }
    addAccessibility() {
        this.main.setAttribute("aria-hidden", "true");
        this.overlay.setAttribute("aria-hidden", "true");
        this.body.setAttribute("aria-modal", "true");
        this.body.setAttribute("role", "dialog");
    }
    assignStyles(el, styles) {
        Object.assign(el.style, styles);
    }
}
// UNCHANGED
async function sleepForSeconds(seconds) {
    return new Promise((res)=>{
        setTimeout(()=>{
            res(0);
        }, seconds * 1000);
    });
}
function renderPaperCheckoutLink(_ref) {
    let { checkoutLinkUrl, onPaymentSucceeded, onPaymentFailed, onTransferSucceeded, onModalClosed } = _ref;
    const drawer = new Drawer();
    const formattedCheckoutLinkUrl = new URL(checkoutLinkUrl);
    formattedCheckoutLinkUrl.searchParams.set("display", "DRAWER");
    drawer.open({
        iframeUrl: formattedCheckoutLinkUrl.href
    });
    if (onModalClosed) {
        drawer.setOnCloseCallback(onModalClosed);
    }
    const messageHandler = async (e)=>{
        if (e.origin !== PAPER_APP_URL) {
            return;
        }
        const result = e.data;
        if (!result.eventType) {
            return;
        }
        switch(result.eventType){
            case "paymentSuccess":
                {
                    const transactionId = e.data.id;
                    onPaymentSucceeded?.({
                        transactionId
                    });
                    break;
                }
            case "claimSuccessful":
                {
                    const { id: transactionId, claimedTokens } = e.data;
                    onTransferSucceeded?.({
                        transactionId,
                        claimedTokens
                    });
                    await sleepForSeconds(3.5);
                    drawer.close();
                    break;
                }
            case "redirectAfterSuccess":
                {
                    const redirectUrl = e.data.redirectUrl;
                    window.location.assign(redirectUrl);
                    break;
                }
            case "paymentFailed":
                {
                    const transactionId = e.data.id;
                    onPaymentFailed?.({
                        transactionId
                    });
                    break;
                }
            case "modalClosed":
                {
                    onModalClosed?.();
                    break;
                }
            default:
                throw new Error(`Unsupported eventType ${result.eventType}`);
        }
    };
    window.addEventListener("message", messageHandler);
}
;
}}),
}]);

//# sourceMappingURL=node_modules_%40thirdweb-dev_22e8ee68._.js.map