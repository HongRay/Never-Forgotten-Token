(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@google/model-viewer/lib/constants.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ // NOTE(cdata): The HAS_WEBXR_* constants can be enabled in Chrome by turning on
// the appropriate flags. However, just because we have the API does not
// guarantee that AR will work.
__turbopack_context__.s({
    "HAS_INTERSECTION_OBSERVER": (()=>HAS_INTERSECTION_OBSERVER),
    "HAS_RESIZE_OBSERVER": (()=>HAS_RESIZE_OBSERVER),
    "HAS_WEBXR_DEVICE_API": (()=>HAS_WEBXR_DEVICE_API),
    "HAS_WEBXR_HIT_TEST_API": (()=>HAS_WEBXR_HIT_TEST_API),
    "IS_ANDROID": (()=>IS_ANDROID),
    "IS_AR_QUICKLOOK_CANDIDATE": (()=>IS_AR_QUICKLOOK_CANDIDATE),
    "IS_CHROMEOS": (()=>IS_CHROMEOS),
    "IS_FIREFOX": (()=>IS_FIREFOX),
    "IS_IOS": (()=>IS_IOS),
    "IS_IOS_CHROME": (()=>IS_IOS_CHROME),
    "IS_IOS_SAFARI": (()=>IS_IOS_SAFARI),
    "IS_MOBILE": (()=>IS_MOBILE),
    "IS_OCULUS": (()=>IS_OCULUS),
    "IS_SAFARI": (()=>IS_SAFARI),
    "IS_SCENEVIEWER_CANDIDATE": (()=>IS_SCENEVIEWER_CANDIDATE),
    "IS_WEBXR_AR_CANDIDATE": (()=>IS_WEBXR_AR_CANDIDATE),
    "IS_WKWEBVIEW": (()=>IS_WKWEBVIEW)
});
const HAS_WEBXR_DEVICE_API = navigator.xr != null && self.XRSession != null && navigator.xr.isSessionSupported != null;
const HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API && self.XRSession.prototype.requestHitTestSource != null;
const HAS_RESIZE_OBSERVER = self.ResizeObserver != null;
const HAS_INTERSECTION_OBSERVER = self.IntersectionObserver != null;
const IS_WEBXR_AR_CANDIDATE = HAS_WEBXR_HIT_TEST_API;
const IS_MOBILE = (()=>{
    const userAgent = navigator.userAgent || navigator.vendor || self.opera;
    let check = false;
    // eslint-disable-next-line
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4))) {
        check = true;
    }
    return check;
})();
const IS_CHROMEOS = /\bCrOS\b/.test(navigator.userAgent);
const IS_ANDROID = /android/i.test(navigator.userAgent);
const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1;
const IS_SAFARI = /Safari\//.test(navigator.userAgent);
const IS_FIREFOX = /firefox/i.test(navigator.userAgent);
const IS_OCULUS = /OculusBrowser/.test(navigator.userAgent);
const IS_IOS_CHROME = IS_IOS && /CriOS\//.test(navigator.userAgent);
const IS_IOS_SAFARI = IS_IOS && IS_SAFARI;
const IS_SCENEVIEWER_CANDIDATE = IS_ANDROID && !IS_FIREFOX && !IS_OCULUS;
const IS_WKWEBVIEW = Boolean(window.webkit && window.webkit.messageHandlers);
const IS_AR_QUICKLOOK_CANDIDATE = (()=>{
    if (IS_IOS) {
        if (!IS_WKWEBVIEW) {
            const tempAnchor = document.createElement('a');
            return Boolean(tempAnchor.relList && tempAnchor.relList.supports && tempAnchor.relList.supports('ar'));
        } else {
            return Boolean(/CriOS\/|EdgiOS\/|FxiOS\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent));
        }
    } else {
        return false;
    }
})(); //# sourceMappingURL=constants.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "CAPPED_DEVICE_PIXEL_RATIO": (()=>CAPPED_DEVICE_PIXEL_RATIO),
    "assertIsArCandidate": (()=>assertIsArCandidate),
    "clamp": (()=>clamp),
    "debounce": (()=>debounce),
    "deserializeUrl": (()=>deserializeUrl),
    "getFirstMapKey": (()=>getFirstMapKey),
    "isDebugMode": (()=>isDebugMode),
    "resolveDpr": (()=>resolveDpr),
    "step": (()=>step),
    "throttle": (()=>throttle),
    "timePasses": (()=>timePasses),
    "toFullUrl": (()=>toFullUrl),
    "waitForEvent": (()=>waitForEvent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/constants.js [app-client] (ecmascript)");
;
const deserializeUrl = (url)=>!!url && url !== 'null' ? toFullUrl(url) : null;
const assertIsArCandidate = ()=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBXR_AR_CANDIDATE"]) {
        return;
    }
    const missingApis = [];
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_WEBXR_DEVICE_API"]) {
        missingApis.push('WebXR Device API');
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_WEBXR_HIT_TEST_API"]) {
        missingApis.push('WebXR Hit Test API');
    }
    throw new Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(', ')}`);
};
const toFullUrl = (partialUrl)=>{
    const url = new URL(partialUrl, window.location.toString());
    return url.toString();
};
const throttle = (fn, ms)=>{
    let timer = null;
    const throttled = (...args)=>{
        if (timer != null) {
            return;
        }
        fn(...args);
        timer = self.setTimeout(()=>timer = null, ms);
    };
    throttled.flush = ()=>{
        if (timer != null) {
            self.clearTimeout(timer);
            timer = null;
        }
    };
    return throttled;
};
const debounce = (fn, ms)=>{
    let timer = null;
    return (...args)=>{
        if (timer != null) {
            self.clearTimeout(timer);
        }
        timer = self.setTimeout(()=>{
            timer = null;
            fn(...args);
        }, ms);
    };
};
const step = (edge, value)=>{
    return value < edge ? 0 : 1;
};
const clamp = (value, lowerLimit, upperLimit)=>Math.max(lowerLimit, Math.min(upperLimit, value));
const CAPPED_DEVICE_PIXEL_RATIO = 1;
const resolveDpr = (()=>{
    // If true, implies that the user is conscious of the viewport scaling
    // relative to the device screen size.
    const HAS_META_VIEWPORT_TAG = (()=>{
        var _a;
        // Search result pages sometimes do not include a meta viewport tag even
        // though they are certainly modern and work properly with devicePixelRatio.
        if ((_a = document.documentElement.getAttribute('itemtype')) === null || _a === void 0 ? void 0 : _a.includes('schema.org/SearchResultsPage')) {
            return true;
        }
        const metas = document.head != null ? Array.from(document.head.querySelectorAll('meta')) : [];
        for (const meta of metas){
            if (meta.name === 'viewport') {
                return true;
            }
        }
        return false;
    })();
    if (!HAS_META_VIEWPORT_TAG) {
        console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.');
    }
    return ()=>HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : CAPPED_DEVICE_PIXEL_RATIO;
})();
const isDebugMode = (()=>{
    const debugQueryParameterName = 'model-viewer-debug-mode';
    const debugQueryParameter = new RegExp(`[?&]${debugQueryParameterName}(&|$)`);
    return ()=>self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(debugQueryParameter);
})();
const getFirstMapKey = (map)=>{
    if (map.keys != null) {
        return map.keys().next().value || null;
    }
    let firstKey = null;
    try {
        map.forEach((_value, key, _map)=>{
            firstKey = key;
            // Stop iterating the Map with forEach:
            throw new Error();
        });
    } catch (_error) {}
    return firstKey;
};
const timePasses = (ms = 0)=>new Promise((resolve)=>setTimeout(resolve, ms));
const waitForEvent = (target, eventName, predicate = null)=>new Promise((resolve)=>{
        function handler(event) {
            if (!predicate || predicate(event)) {
                resolve(event);
                target.removeEventListener(eventName, handler);
            }
        }
        target.addEventListener(eventName, handler);
    }); //# sourceMappingURL=utilities.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/environment.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$currentBackground": (()=>$currentBackground),
    "$currentEnvironmentMap": (()=>$currentEnvironmentMap),
    "$updateEnvironment": (()=>$updateEnvironment),
    "BASE_OPACITY": (()=>BASE_OPACITY),
    "EnvironmentMixin": (()=>EnvironmentMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
const BASE_OPACITY = 0.5;
const DEFAULT_SHADOW_INTENSITY = 0.0;
const DEFAULT_SHADOW_SOFTNESS = 1.0;
const DEFAULT_EXPOSURE = 1.0;
const $currentEnvironmentMap = Symbol('currentEnvironmentMap');
const $currentBackground = Symbol('currentBackground');
const $updateEnvironment = Symbol('updateEnvironment');
const $cancelEnvironmentUpdate = Symbol('cancelEnvironmentUpdate');
const EnvironmentMixin = (ModelViewerElement)=>{
    var _a, _b, _c;
    class EnvironmentModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this.environmentImage = null;
            this.skyboxImage = null;
            this.shadowIntensity = DEFAULT_SHADOW_INTENSITY;
            this.shadowSoftness = DEFAULT_SHADOW_SOFTNESS;
            this.exposure = DEFAULT_EXPOSURE;
            this[_a] = null;
            this[_b] = null;
            this[_c] = null;
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('shadowIntensity')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].setShadowIntensity(this.shadowIntensity * BASE_OPACITY);
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
            if (changedProperties.has('shadowSoftness')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].setShadowSoftness(this.shadowSoftness);
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
            if (changedProperties.has('exposure')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].exposure = this.exposure;
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
            if ((changedProperties.has('environmentImage') || changedProperties.has('skyboxImage')) && this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$shouldAttemptPreload"]]()) {
                this[$updateEnvironment]();
            }
        }
        hasBakedShadow() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].bakedShadows.size > 0;
        }
        async [(_a = $currentEnvironmentMap, _b = $currentBackground, _c = $cancelEnvironmentUpdate, $updateEnvironment)]() {
            const { skyboxImage, environmentImage } = this;
            if (this[$cancelEnvironmentUpdate] != null) {
                this[$cancelEnvironmentUpdate]();
                this[$cancelEnvironmentUpdate] = null;
            }
            const { textureUtils } = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]];
            if (textureUtils == null) {
                return;
            }
            const updateEnvProgress = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$progressTracker"]].beginActivity();
            try {
                const { environmentMap, skybox } = await textureUtils.generateEnvironmentMapAndSkybox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deserializeUrl"])(skyboxImage), environmentImage, (progress)=>updateEnvProgress((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(progress, 0, 1)));
                if (this[$currentEnvironmentMap] !== environmentMap) {
                    this[$currentEnvironmentMap] = environmentMap;
                    this.dispatchEvent(new CustomEvent('environment-change'));
                }
                if (skybox != null) {
                    // When using the same environment and skybox, use the environment as
                    // it gives HDR filtering.
                    this[$currentBackground] = skybox.name === environmentMap.name ? environmentMap : skybox;
                } else {
                    this[$currentBackground] = null;
                }
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].setEnvironmentAndSkybox(this[$currentEnvironmentMap], this[$currentBackground]);
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].dispatchEvent({
                    type: 'envmap-update'
                });
            } catch (errorOrPromise) {
                if (errorOrPromise instanceof Error) {
                    this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].setEnvironmentAndSkybox(null, null);
                    throw errorOrPromise;
                }
            } finally{
                updateEnvProgress(1.0);
            }
        }
    }
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'environment-image'
        })
    ], EnvironmentModelViewerElement.prototype, "environmentImage", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'skybox-image'
        })
    ], EnvironmentModelViewerElement.prototype, "skyboxImage", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'shadow-intensity'
        })
    ], EnvironmentModelViewerElement.prototype, "shadowIntensity", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'shadow-softness'
        })
    ], EnvironmentModelViewerElement.prototype, "shadowSoftness", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number
        })
    ], EnvironmentModelViewerElement.prototype, "exposure", void 0);
    return EnvironmentModelViewerElement;
}; //# sourceMappingURL=environment.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/assets/close-material-svg.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lit-html/development/lit-html.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["html"]`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`;
 //# sourceMappingURL=close-material-svg.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/assets/controls-svg.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lit-html/development/lit-html.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["html"]`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`;
 //# sourceMappingURL=controls-svg.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/assets/view-in-ar-material-svg.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lit-html/development/lit-html.js [app-client] (ecmascript)");
;
const __TURBOPACK__default__export__ = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["html"]`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`;
 //# sourceMappingURL=view-in-ar-material-svg.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/template.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "makeTemplate": (()=>makeTemplate)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lit-html/development/lit-html.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$close$2d$material$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/assets/close-material-svg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$controls$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/assets/controls-svg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$view$2d$in$2d$ar$2d$material$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/assets/view-in-ar-material-svg.js [app-client] (ecmascript)");
;
;
;
;
const templateResult = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["html"]`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

/* NOTE: This rule set is our integration surface area with the
 * :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196 */
:host([data-js-focus-visible]:focus:not(.focus-visible)),
:host([data-js-focus-visible]) :focus:not(.focus-visible) {
  outline: none;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          aria-label="View in your space">
        ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$view$2d$in$2d$ar$2d$material$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$controls$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$assets$2f$close$2d$material$2d$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`;
const makeTemplate = (shadowRoot)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2d$html$2f$development$2f$lit$2d$html$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["render"])(templateResult, shadowRoot);
}; //# sourceMappingURL=template.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities/cache-eviction-policy.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "CacheEvictionPolicy": (()=>CacheEvictionPolicy)
});
var _a, _b;
const $retainerCount = Symbol('retainerCount');
const $recentlyUsed = Symbol('recentlyUsed');
const $evict = Symbol('evict');
const $evictionThreshold = Symbol('evictionThreshold');
const $cache = Symbol('cache');
class CacheEvictionPolicy {
    constructor(cache, evictionThreshold = 5){
        this[_a] = new Map();
        this[_b] = [];
        this[$cache] = cache;
        this[$evictionThreshold] = evictionThreshold;
    }
    /**
     * The eviction threshold is the maximum number of items to hold
     * in cache indefinitely. Items within the threshold (in recently
     * used order) will continue to be cached even if they have zero
     * retainers.
     */ set evictionThreshold(value) {
        this[$evictionThreshold] = value;
        this[$evict]();
    }
    get evictionThreshold() {
        return this[$evictionThreshold];
    }
    /**
     * A reference to the cache that operates under this policy
     */ get cache() {
        return this[$cache];
    }
    /**
     * Given an item key, returns the number of retainers of that item
     */ retainerCount(key) {
        return this[$retainerCount].get(key) || 0;
    }
    /**
     * Resets the internal tracking of cache item retainers. Use only in cases
     * where it is certain that all retained cache items have been accounted for!
     */ reset() {
        this[$retainerCount].clear();
        this[$recentlyUsed] = [];
    }
    /**
     * Mark a given cache item as retained, where the item is represented
     * by its key. An item can have any number of retainers.
     */ retain(key) {
        if (!this[$retainerCount].has(key)) {
            this[$retainerCount].set(key, 0);
        }
        this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);
        const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);
        if (recentlyUsedIndex !== -1) {
            this[$recentlyUsed].splice(recentlyUsedIndex, 1);
        }
        this[$recentlyUsed].unshift(key);
        // Evict, in case retaining a new item pushed an evictable item beyond the
        // eviction threshold
        this[$evict]();
    }
    /**
     * Mark a given cache item as released by one of its retainers, where the item
     * is represented by its key. When all retainers of an item have released it,
     * the item is considered evictable.
     */ release(key) {
        if (this[$retainerCount].has(key)) {
            this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));
        }
        this[$evict]();
    }
    [(_a = $retainerCount, _b = $recentlyUsed, $evict)]() {
        if (this[$recentlyUsed].length < this[$evictionThreshold]) {
            return;
        }
        for(let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i){
            const key = this[$recentlyUsed][i];
            const retainerCount = this[$retainerCount].get(key);
            if (retainerCount === 0) {
                this[$cache].delete(key);
                this[$recentlyUsed].splice(i, 1);
            }
        }
    }
} //# sourceMappingURL=cache-eviction-policy.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * KHR_materials_variants specification allows duplicated variant names
 * but it makes handling the extension complex.
 * We ensure tha names and make it easier.
 * If you want to export the extension with the original names
 * you are recommended to write GLTFExporter plugin to restore the names.
 *
 * @param variantNames {Array<string>}
 * @return {Array<string>}
 */ __turbopack_context__.s({
    "default": (()=>GLTFMaterialsVariantsExtension)
});
const ensureUniqueNames = (variantNames)=>{
    const uniqueNames = [];
    const knownNames = new Set();
    for (const name of variantNames){
        let uniqueName = name;
        let suffix = 0;
        // @TODO: An easy solution.
        //        O(N^2) in the worst scenario where N is variantNames.length.
        //        Fix me if needed.
        while(knownNames.has(uniqueName)){
            uniqueName = name + '.' + ++suffix;
        }
        knownNames.add(uniqueName);
        uniqueNames.push(uniqueName);
    }
    return uniqueNames;
};
/**
 * Convert mappings array to table object to make handling the extension easier.
 *
 * @param
 *     extensionDef {glTF.meshes[n].primitive.extensions.KHR_materials_variants}
 * @param variantNames {Array<string>} Required to be unique names
 * @return {Map}
 */ const mappingsArrayToTable = (extensionDef)=>{
    const table = new Map();
    for (const mapping of extensionDef.mappings){
        for (const variant of mapping.variants){
            table.set(variant, {
                material: null,
                gltfMaterialIndex: mapping.material
            });
        }
    }
    return table;
};
class GLTFMaterialsVariantsExtension {
    constructor(parser){
        this.parser = parser;
        this.name = 'KHR_materials_variants';
    }
    // Note that the following properties will be overridden even if they are
    // pre-defined
    // - gltf.userData.variants
    // - mesh.userData.variantMaterials
    afterRoot(gltf) {
        const parser = this.parser;
        const json = parser.json;
        if (json.extensions === undefined || json.extensions[this.name] === undefined) {
            return null;
        }
        const extensionDef = json.extensions[this.name];
        const variantsDef = extensionDef.variants || [];
        const variants = ensureUniqueNames(variantsDef.map((v)=>v.name));
        for (const scene of gltf.scenes){
            // Save the variants data under associated mesh.userData
            scene.traverse((object)=>{
                const mesh = object;
                if (!mesh.isMesh) {
                    return;
                }
                const association = parser.associations.get(mesh);
                if (association == null || association.meshes == null || association.primitives == null) {
                    return;
                }
                const meshDef = json.meshes[association.meshes];
                const primitivesDef = meshDef.primitives;
                const primitiveDef = primitivesDef[association.primitives];
                const extensionsDef = primitiveDef.extensions;
                if (!extensionsDef || !extensionsDef[this.name]) {
                    return;
                }
                mesh.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name]);
            });
        }
        gltf.userData.variants = variants;
        return Promise.resolve();
    }
} //# sourceMappingURL=VariantMaterialLoaderPlugin.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$evictionPolicy": (()=>$evictionPolicy),
    "$loader": (()=>$loader),
    "CachingGLTFLoader": (()=>CachingGLTFLoader),
    "loadWithLoader": (()=>loadWithLoader)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$DRACOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/loaders/DRACOLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/loaders/GLTFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$KTX2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/loaders/KTX2Loader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$cache$2d$eviction$2d$policy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities/cache-eviction-policy.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$VariantMaterialLoaderPlugin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialLoaderPlugin.js [app-client] (ecmascript)");
var _a, _b;
;
;
;
;
;
;
const loadWithLoader = (url, loader, progressCallback = ()=>{})=>{
    const onProgress = (event)=>{
        const fraction = event.loaded / event.total;
        progressCallback(Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)));
    };
    return new Promise((resolve, reject)=>{
        loader.load(url, resolve, onProgress, reject);
    });
};
/** Helper to load a script tag. */ const fetchScript = (src)=>{
    return new Promise((resolve, reject)=>{
        const script = document.createElement('script');
        document.body.appendChild(script);
        script.onload = resolve;
        script.onerror = reject;
        script.async = true;
        script.src = src;
    });
};
const cache = new Map();
const preloaded = new Map();
let dracoDecoderLocation;
const dracoLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$DRACOLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DRACOLoader"]();
let ktx2TranscoderLocation;
const ktx2Loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$KTX2Loader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["KTX2Loader"]();
let meshoptDecoderLocation;
let meshoptDecoder;
const $loader = Symbol('loader');
const $evictionPolicy = Symbol('evictionPolicy');
const $GLTFInstance = Symbol('GLTFInstance');
class CachingGLTFLoader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
    constructor(GLTFInstance){
        super();
        this[_b] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$GLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFLoader"]().register((parser)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$VariantMaterialLoaderPlugin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](parser));
        this[$GLTFInstance] = GLTFInstance;
        this[$loader].setDRACOLoader(dracoLoader);
        this[$loader].setKTX2Loader(ktx2Loader);
    }
    static setDRACODecoderLocation(url) {
        dracoDecoderLocation = url;
        dracoLoader.setDecoderPath(url);
    }
    static getDRACODecoderLocation() {
        return dracoDecoderLocation;
    }
    static setKTX2TranscoderLocation(url) {
        ktx2TranscoderLocation = url;
        ktx2Loader.setTranscoderPath(url);
    }
    static getKTX2TranscoderLocation() {
        return ktx2TranscoderLocation;
    }
    static setMeshoptDecoderLocation(url) {
        if (meshoptDecoderLocation !== url) {
            meshoptDecoderLocation = url;
            meshoptDecoder = fetchScript(url).then(()=>MeshoptDecoder.ready).then(()=>MeshoptDecoder);
        }
    }
    static getMeshoptDecoderLocation() {
        return meshoptDecoderLocation;
    }
    static initializeKTX2Loader(renderer) {
        ktx2Loader.detectSupport(renderer);
    }
    static get cache() {
        return cache;
    }
    /** @nocollapse */ static clearCache() {
        cache.forEach((_value, url)=>{
            this.delete(url);
        });
        this[$evictionPolicy].reset();
    }
    static has(url) {
        return cache.has(url);
    }
    /** @nocollapse */ static async delete(url) {
        if (!this.has(url)) {
            return;
        }
        const gltfLoads = cache.get(url);
        preloaded.delete(url);
        cache.delete(url);
        const gltf = await gltfLoads;
        // Dispose of the cached glTF's materials and geometries:
        gltf.dispose();
    }
    /**
     * Returns true if the model that corresponds to the specified url is
     * available in our local cache.
     */ static hasFinishedLoading(url) {
        return !!preloaded.get(url);
    }
    get [(_a = $evictionPolicy, _b = $loader, $evictionPolicy)]() {
        return this.constructor[$evictionPolicy];
    }
    /**
     * Preloads a glTF, populating the cache. Returns a promise that resolves
     * when the cache is populated.
     */ async preload(url, element, progressCallback = ()=>{}) {
        this[$loader].setWithCredentials(CachingGLTFLoader.withCredentials);
        this.dispatchEvent({
            type: 'preload',
            element: element,
            src: url
        });
        if (!cache.has(url)) {
            if (meshoptDecoder != null) {
                this[$loader].setMeshoptDecoder(await meshoptDecoder);
            }
            const rawGLTFLoads = loadWithLoader(url, this[$loader], (progress)=>{
                progressCallback(progress * 0.8);
            });
            const GLTFInstance = this[$GLTFInstance];
            const gltfInstanceLoads = rawGLTFLoads.then((rawGLTF)=>{
                return GLTFInstance.prepare(rawGLTF);
            }).then((preparedGLTF)=>{
                progressCallback(0.9);
                return new GLTFInstance(preparedGLTF);
            }).catch((reason)=>{
                console.error(reason);
                return new GLTFInstance();
            });
            cache.set(url, gltfInstanceLoads);
        }
        await cache.get(url);
        preloaded.set(url, true);
        if (progressCallback) {
            progressCallback(1.0);
        }
    }
    /**
     * Loads a glTF from the specified url and resolves a unique clone of the
     * glTF. If the glTF has already been loaded, makes a clone of the cached
     * copy.
     */ async load(url, element, progressCallback = ()=>{}) {
        await this.preload(url, element, progressCallback);
        const gltf = await cache.get(url);
        const clone = await gltf.clone();
        this[$evictionPolicy].retain(url);
        // Patch dispose so that we can properly account for instance use
        // in the caching layer:
        clone.dispose = ()=>{
            this[$evictionPolicy].release(url);
        };
        return clone;
    }
}
CachingGLTFLoader[_a] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$cache$2d$eviction$2d$policy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CacheEvictionPolicy"](CachingGLTFLoader); //# sourceMappingURL=CachingGLTFLoader.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * @param object {THREE.Object3D}
 * @return {boolean}
 */ __turbopack_context__.s({
    "default": (()=>GLTFExporterMaterialsVariantsExtension)
});
const compatibleObject = (object)=>{
    // @TODO: Need properer variantMaterials format validation?
    return object.material !== undefined && // easier than (!object.isMesh && !object.isLine &&
    // !object.isPoints)
    object.userData && // just in case
    object.userData.variantMaterials && // Is this line costly?
    !!Array.from(object.userData.variantMaterials.values()).filter((m)=>compatibleMaterial(m.material));
};
/**
 * @param material {THREE.Material}
 * @return {boolean}
 */ const compatibleMaterial = (material)=>{
    // @TODO: support multi materials?
    return material && material.isMaterial && !Array.isArray(material);
};
class GLTFExporterMaterialsVariantsExtension {
    constructor(writer){
        this.writer = writer;
        this.name = 'KHR_materials_variants';
        this.variantNames = [];
    }
    beforeParse(objects) {
        // Find all variant names and store them to the table
        const variantNameSet = new Set();
        for (const object of objects){
            object.traverse((o)=>{
                if (!compatibleObject(o)) {
                    return;
                }
                const variantMaterials = o.userData.variantMaterials;
                const variantDataMap = o.userData.variantData;
                for (const [variantName, variantData] of variantDataMap){
                    const variantMaterial = variantMaterials.get(variantData.index);
                    // Ignore unloaded variant materials
                    if (variantMaterial && compatibleMaterial(variantMaterial.material)) {
                        variantNameSet.add(variantName);
                    }
                }
            });
        }
        // We may want to sort?
        variantNameSet.forEach((name)=>this.variantNames.push(name));
    }
    writeMesh(mesh, meshDef) {
        if (!compatibleObject(mesh)) {
            return;
        }
        const userData = mesh.userData;
        const variantMaterials = userData.variantMaterials;
        const variantDataMap = userData.variantData;
        const mappingTable = new Map();
        // Removes gaps in the variant indices list (caused by deleting variants).
        const reIndexedVariants = new Map();
        const variants = Array.from(variantDataMap.values()).sort((a, b)=>{
            return a.index - b.index;
        });
        for (const [i, variantData] of variants.entries()){
            reIndexedVariants.set(variantData.index, i);
        }
        for (const variantData of variantDataMap.values()){
            const variantInstance = variantMaterials.get(variantData.index);
            if (!variantInstance || !compatibleMaterial(variantInstance.material)) {
                continue;
            }
            const materialIndex = this.writer.processMaterial(variantInstance.material);
            if (!mappingTable.has(materialIndex)) {
                mappingTable.set(materialIndex, {
                    material: materialIndex,
                    variants: []
                });
            }
            mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));
        }
        const mappingsDef = Array.from(mappingTable.values()).map((m)=>{
            return m.variants.sort((a, b)=>a - b) && m;
        }).sort((a, b)=>a.material - b.material);
        if (mappingsDef.length === 0) {
            return;
        }
        const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;
        for (const primitiveDef of meshDef.primitives){
            // Override primitiveDef.material with original material.
            if (originalMaterialIndex >= 0) {
                primitiveDef.material = originalMaterialIndex;
            }
            primitiveDef.extensions = primitiveDef.extensions || {};
            primitiveDef.extensions[this.name] = {
                mappings: mappingsDef
            };
        }
    }
    afterParse() {
        if (this.variantNames.length === 0) {
            return;
        }
        const root = this.writer.json;
        root.extensions = root.extensions || {};
        const variantsDef = this.variantNames.map((n)=>{
            return {
                name: n
            };
        });
        root.extensions[this.name] = {
            variants: variantsDef
        };
        this.writer.extensionsUsed[this.name] = true;
    }
} //# sourceMappingURL=VariantMaterialExporterPlugin.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "DECAY_MILLISECONDS": (()=>DECAY_MILLISECONDS),
    "Damper": (()=>Damper),
    "SETTLING_TIME": (()=>SETTLING_TIME)
});
const SETTLING_TIME = 10000; // plenty long enough
const MIN_DECAY_MILLISECONDS = 0.001;
const DECAY_MILLISECONDS = 50;
class Damper {
    constructor(decayMilliseconds = DECAY_MILLISECONDS){
        this.velocity = 0;
        this.naturalFrequency = 0;
        this.setDecayTime(decayMilliseconds);
    }
    setDecayTime(decayMilliseconds) {
        this.naturalFrequency = 1 / Math.max(MIN_DECAY_MILLISECONDS, decayMilliseconds);
    }
    update(x, xGoal, timeStepMilliseconds, xNormalization) {
        const nilSpeed = 0.0002 * this.naturalFrequency;
        if (x == null || xNormalization === 0) {
            return xGoal;
        }
        if (x === xGoal && this.velocity === 0) {
            return xGoal;
        }
        if (timeStepMilliseconds < 0) {
            return x;
        }
        // Exact solution to a critically damped second-order system, where:
        // acceleration = this.naturalFrequency * this.naturalFrequency * (xGoal
        // - x) - 2 * this.naturalFrequency * this.velocity;
        const deltaX = x - xGoal;
        const intermediateVelocity = this.velocity + this.naturalFrequency * deltaX;
        const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;
        const decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds);
        const newVelocity = (intermediateVelocity - this.naturalFrequency * intermediateX) * decay;
        const acceleration = -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);
        if (Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) && acceleration * deltaX >= 0) {
            // This ensures the controls settle and stop calling this function instead
            // of asymptotically approaching their goal.
            this.velocity = 0;
            return xGoal;
        } else {
            this.velocity = newVelocity;
            return xGoal + intermediateX * decay;
        }
    }
} //# sourceMappingURL=Damper.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/PlacementBox.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "PlacementBox": (()=>PlacementBox)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)");
;
;
const RADIUS = 0.2;
const LINE_WIDTH = 0.03;
const MAX_OPACITY = 0.75;
const SEGMENTS = 12;
const DELTA_PHI = Math.PI / (2 * SEGMENTS);
const vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
/**
 * Adds a quarter-annulus of vertices to the array, centered on cornerX,
 * cornerY.
 */ const addCorner = (vertices, cornerX, cornerY)=>{
    let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;
    for(let i = 0; i <= SEGMENTS; ++i){
        vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);
        phi += DELTA_PHI;
    }
};
class PlacementBox extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"] {
    constructor(scene, side){
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BufferGeometry"]();
        const triangles = [];
        const vertices = [];
        const { size, boundingBox } = scene;
        const x = size.x / 2;
        const y = (side === 'back' ? size.y : size.z) / 2;
        addCorner(vertices, x, y);
        addCorner(vertices, -x, y);
        addCorner(vertices, -x, -y);
        addCorner(vertices, x, -y);
        const numVertices = vertices.length / 3;
        for(let i = 0; i < numVertices - 2; i += 2){
            triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);
        }
        const i = numVertices - 2;
        triangles.push(i, i + 1, 1, i, 1, 0);
        geometry.setAttribute('position', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Float32BufferAttribute"](vertices, 3));
        geometry.setIndex(triangles);
        super(geometry);
        this.side = side;
        const material = this.material;
        material.side = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
        material.transparent = true;
        material.opacity = 0;
        this.goalOpacity = 0;
        this.opacityDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.hitPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2 * (x + RADIUS), 2 * (y + RADIUS)));
        this.hitPlane.visible = false;
        this.hitPlane.material.side = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"];
        this.add(this.hitPlane);
        boundingBox.getCenter(this.position);
        switch(side){
            case 'bottom':
                this.rotateX(-Math.PI / 2);
                this.shadowHeight = boundingBox.min.y;
                this.position.y = this.shadowHeight;
                break;
            case 'back':
                this.shadowHeight = boundingBox.min.z;
                this.position.z = this.shadowHeight;
        }
        scene.target.add(this);
        this.offsetHeight = 0;
    }
    /**
     * Get the world hit position if the touch coordinates hit the box, and null
     * otherwise. Pass the scene in to get access to its raycaster.
     */ getHit(scene, screenX, screenY) {
        vector2.set(screenX, -screenY);
        this.hitPlane.visible = true;
        const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);
        this.hitPlane.visible = false;
        return hitResult == null ? null : hitResult.position;
    }
    getExpandedHit(scene, screenX, screenY) {
        this.hitPlane.scale.set(1000, 1000, 1000);
        this.hitPlane.updateMatrixWorld();
        const hitResult = this.getHit(scene, screenX, screenY);
        this.hitPlane.scale.set(1, 1, 1);
        return hitResult;
    }
    /**
     * Offset the height of the box relative to the bottom of the scene. Positive
     * is up, so generally only negative values are used.
     */ set offsetHeight(offset) {
        offset -= 0.001; // push 1 mm below shadow to avoid z-fighting
        if (this.side === 'back') {
            this.position.z = this.shadowHeight + offset;
        } else {
            this.position.y = this.shadowHeight + offset;
        }
    }
    get offsetHeight() {
        if (this.side === 'back') {
            return this.position.z - this.shadowHeight;
        } else {
            return this.position.y - this.shadowHeight;
        }
    }
    /**
     * Set the box's visibility; it will fade in and out.
     */ set show(visible) {
        this.goalOpacity = visible ? MAX_OPACITY : 0;
    }
    /**
     * Call on each frame with the frame delta to fade the box.
     */ updateOpacity(delta) {
        const material = this.material;
        material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);
        this.visible = material.opacity > 0;
    }
    /**
     * Call this to clean up Three's cache when you remove the box.
     */ dispose() {
        var _a;
        const { geometry, material } = this.hitPlane;
        geometry.dispose();
        material.dispose();
        this.geometry.dispose();
        this.material.dispose();
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.remove(this);
    }
} //# sourceMappingURL=PlacementBox.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/ARRenderer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ARRenderer": (()=>ARRenderer),
    "ARStatus": (()=>ARStatus),
    "ARTracking": (()=>ARTracking)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$webxr$2f$XREstimatedLight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/webxr/XREstimatedLight.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$PlacementBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/PlacementBox.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
// number of initial null pose XRFrames allowed before we post not-tracking
const INIT_FRAMES = 30;
// AR shadow is not user-configurable. This is to pave the way for AR lighting
// estimation, which will be used once available in WebXR.
const AR_SHADOW_INTENSITY = 0.8;
const ROTATION_RATE = 1.5;
// Angle down (towards bottom of screen) from camera center ray to use for hit
// testing against the floor. This makes placement faster and more intuitive
// assuming the phone is in portrait mode. This seems to be a reasonable
// assumption for the start of the session and UI will lack landscape mode to
// encourage upright use.
const HIT_ANGLE_DEG = 20;
const SCALE_SNAP_HIGH = 1.3;
const SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;
// For automatic dynamic viewport scaling, don't let the scale drop below this
// limit.
const MIN_VIEWPORT_SCALE = 0.25;
// Furthest away you can move an object (meters).
const MAX_DISTANCE = 10;
const ARStatus = {
    NOT_PRESENTING: 'not-presenting',
    SESSION_STARTED: 'session-started',
    OBJECT_PLACED: 'object-placed',
    FAILED: 'failed'
};
const ARTracking = {
    TRACKING: 'tracking',
    NOT_TRACKING: 'not-tracking'
};
const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const matrix4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const hitPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](45, 1, 0.1, 100);
class ARRenderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
    constructor(renderer){
        super();
        this.renderer = renderer;
        this.currentSession = null;
        this.placeOnWall = false;
        this.placementBox = null;
        this.lastTick = null;
        this.turntableRotation = null;
        this.oldShadowIntensity = null;
        this.frame = null;
        this.initialHitSource = null;
        this.transientHitTestSource = null;
        this.inputSource = null;
        this._presentedScene = null;
        this.resolveCleanup = null;
        this.exitWebXRButtonContainer = null;
        this.overlay = null;
        this.xrLight = null;
        this.tracking = true;
        this.frames = 0;
        this.initialized = false;
        this.oldTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.placementComplete = false;
        this.isTranslating = false;
        this.isRotating = false;
        this.isTwoFingering = false;
        this.lastDragPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.firstRatio = 0;
        this.lastAngle = 0;
        this.goalPosition = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.goalYaw = 0;
        this.goalScale = 1;
        this.xDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.yDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.zDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.yawDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.scaleDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.onExitWebXRButtonContainerClick = ()=>this.stopPresenting();
        this.onUpdateScene = ()=>{
            if (this.placementBox != null && this.isPresenting) {
                this.placementBox.dispose();
                this.placementBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$PlacementBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlacementBox"](this.presentedScene, this.placeOnWall ? 'back' : 'bottom');
            }
        };
        this.onSelectStart = (event)=>{
            const hitSource = this.transientHitTestSource;
            if (hitSource == null) {
                return;
            }
            const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);
            const scene = this.presentedScene;
            const box = this.placementBox;
            if (fingers.length === 1) {
                this.inputSource = event.inputSource;
                const { axes } = this.inputSource.gamepad;
                const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);
                box.show = true;
                if (hitPosition != null) {
                    this.isTranslating = true;
                    this.lastDragPosition.copy(hitPosition);
                } else if (this.placeOnWall === false) {
                    this.isRotating = true;
                    this.lastAngle = axes[0] * ROTATION_RATE;
                }
            } else if (fingers.length === 2) {
                box.show = true;
                this.isTwoFingering = true;
                const { separation } = this.fingerPolar(fingers);
                this.firstRatio = separation / scene.scale.x;
            }
        };
        this.onSelectEnd = ()=>{
            this.isTranslating = false;
            this.isRotating = false;
            this.isTwoFingering = false;
            this.inputSource = null;
            this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x;
            this.placementBox.show = false;
        };
        this.threeRenderer = renderer.threeRenderer;
        this.threeRenderer.xr.enabled = true;
    }
    async resolveARSession() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertIsArCandidate"])();
        const session = await navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: [
                'hit-test'
            ],
            optionalFeatures: [
                'dom-overlay',
                'light-estimation'
            ],
            domOverlay: this.overlay ? {
                root: this.overlay
            } : undefined
        });
        this.threeRenderer.xr.setReferenceSpaceType('local');
        await this.threeRenderer.xr.setSession(session);
        this.threeRenderer.xr.cameraAutoUpdate = false;
        return session;
    }
    /**
     * The currently presented scene, if any
     */ get presentedScene() {
        return this._presentedScene;
    }
    /**
     * Resolves to true if the renderer has detected all the necessary qualities
     * to support presentation in AR.
     */ async supportsPresentation() {
        try {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertIsArCandidate"])();
            return await navigator.xr.isSessionSupported('immersive-ar');
        } catch (error) {
            console.warn('Request to present in WebXR denied:');
            console.warn(error);
            console.warn('Falling back to next ar-mode');
            return false;
        }
    }
    /**
     * Present a scene in AR
     */ async present(scene, environmentEstimation = false) {
        if (this.isPresenting) {
            console.warn('Cannot present while a model is already presenting');
        }
        let waitForAnimationFrame = new Promise((resolve, _reject)=>{
            requestAnimationFrame(()=>resolve());
        });
        scene.setHotspotsVisibility(false);
        scene.queueRender();
        // Render a frame to turn off the hotspots
        await waitForAnimationFrame;
        // This sets isPresenting to true
        this._presentedScene = scene;
        this.overlay = scene.element.shadowRoot.querySelector('div.default');
        if (environmentEstimation === true) {
            this.xrLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$webxr$2f$XREstimatedLight$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["XREstimatedLight"](this.threeRenderer);
            this.xrLight.addEventListener('estimationstart', ()=>{
                if (!this.isPresenting || this.xrLight == null) {
                    return;
                }
                const scene = this.presentedScene;
                scene.add(this.xrLight);
                scene.environment = this.xrLight.environment;
            });
        }
        const currentSession = await this.resolveARSession();
        currentSession.addEventListener('end', ()=>{
            this.postSessionCleanup();
        }, {
            once: true
        });
        const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');
        exitButton.classList.add('enabled');
        exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);
        this.exitWebXRButtonContainer = exitButton;
        const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');
        this.tracking = true;
        this.frames = 0;
        this.initialized = false;
        this.turntableRotation = scene.yaw;
        this.goalYaw = scene.yaw;
        this.goalScale = 1;
        scene.background = null;
        this.oldShadowIntensity = scene.shadowIntensity;
        scene.setShadowIntensity(0.01); // invisible, but not changing the shader
        this.oldTarget.copy(scene.getTarget());
        scene.element.addEventListener('load', this.onUpdateScene);
        const radians = HIT_ANGLE_DEG * Math.PI / 180;
        const ray = this.placeOnWall === true ? undefined : new XRRay(new DOMPoint(0, 0, 0), {
            x: 0,
            y: -Math.sin(radians),
            z: -Math.cos(radians)
        });
        currentSession.requestHitTestSource({
            space: viewerRefSpace,
            offsetRay: ray
        }).then((hitTestSource)=>{
            this.initialHitSource = hitTestSource;
        });
        this.currentSession = currentSession;
        this.placementBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$PlacementBox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlacementBox"](scene, this.placeOnWall ? 'back' : 'bottom');
        this.placementComplete = false;
        this.lastTick = performance.now();
        this.dispatchEvent({
            type: 'status',
            status: ARStatus.SESSION_STARTED
        });
    }
    /**
     * If currently presenting a scene in AR, stops presentation and exits AR.
     */ async stopPresenting() {
        if (!this.isPresenting) {
            return;
        }
        const cleanupPromise = new Promise((resolve)=>{
            this.resolveCleanup = resolve;
        });
        try {
            await this.currentSession.end();
            await cleanupPromise;
        } catch (error) {
            console.warn('Error while trying to end WebXR AR session');
            console.warn(error);
            this.postSessionCleanup();
        }
    }
    /**
     * True if a scene is currently in the process of being presented in AR
     */ get isPresenting() {
        return this.presentedScene != null;
    }
    get target() {
        return this.oldTarget;
    }
    updateTarget() {
        const scene = this.presentedScene;
        if (scene != null) {
            const target = scene.getTarget();
            this.oldTarget.copy(target);
            if (this.placeOnWall) {
                // Move the scene's target to the center of the back of the model's
                // bounding box.
                target.z = scene.boundingBox.min.z;
            } else {
                // Move the scene's target to the model's floor height.
                target.y = scene.boundingBox.min.y;
            }
            scene.setTarget(target.x, target.y, target.z);
        }
    }
    postSessionCleanup() {
        const session = this.currentSession;
        if (session != null) {
            session.removeEventListener('selectstart', this.onSelectStart);
            session.removeEventListener('selectend', this.onSelectEnd);
            this.currentSession = null;
        }
        const scene = this.presentedScene;
        this._presentedScene = null;
        if (scene != null) {
            const { element } = scene;
            if (this.xrLight != null) {
                scene.remove(this.xrLight);
                this.xrLight.dispose();
                this.xrLight = null;
            }
            scene.position.set(0, 0, 0);
            scene.scale.set(1, 1, 1);
            scene.setShadowOffset(0);
            const yaw = this.turntableRotation;
            if (yaw != null) {
                scene.yaw = yaw;
            }
            const intensity = this.oldShadowIntensity;
            if (intensity != null) {
                scene.setShadowIntensity(intensity);
            }
            scene.setEnvironmentAndSkybox(element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$currentEnvironmentMap"]], element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$currentBackground"]]);
            const point = this.oldTarget;
            scene.setTarget(point.x, point.y, point.z);
            scene.xrCamera = null;
            scene.element.removeEventListener('load', this.onUpdateScene);
            scene.orientHotspots(0);
            element.requestUpdate('cameraTarget');
            element.requestUpdate('maxCameraOrbit');
            element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onResize"]](element.getBoundingClientRect());
        }
        // Force the Renderer to update its size
        this.renderer.height = 0;
        const exitButton = this.exitWebXRButtonContainer;
        if (exitButton != null) {
            exitButton.classList.remove('enabled');
            exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);
            this.exitWebXRButtonContainer = null;
        }
        const hitSource = this.transientHitTestSource;
        if (hitSource != null) {
            hitSource.cancel();
            this.transientHitTestSource = null;
        }
        const hitSourceInitial = this.initialHitSource;
        if (hitSourceInitial != null) {
            hitSourceInitial.cancel();
            this.initialHitSource = null;
        }
        if (this.placementBox != null) {
            this.placementBox.dispose();
            this.placementBox = null;
        }
        this.lastTick = null;
        this.turntableRotation = null;
        this.oldShadowIntensity = null;
        this.frame = null;
        this.inputSource = null;
        this.overlay = null;
        if (this.resolveCleanup != null) {
            this.resolveCleanup();
        }
        this.dispatchEvent({
            type: 'status',
            status: ARStatus.NOT_PRESENTING
        });
    }
    updateView(view) {
        const scene = this.presentedScene;
        const xr = this.threeRenderer.xr;
        xr.updateCamera(camera);
        scene.xrCamera = xr.getCamera();
        const { elements } = scene.getCamera().matrixWorld;
        scene.orientHotspots(Math.atan2(elements[1], elements[5]));
        if (!this.initialized) {
            this.placeInitially();
            this.initialized = true;
        }
        // Use automatic dynamic viewport scaling if supported.
        if (view.requestViewportScale && view.recommendedViewportScale) {
            const scale = view.recommendedViewportScale;
            view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));
        }
        const layer = this.currentSession.renderState.baseLayer;
        const viewport = layer.getViewport(view);
        this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
    }
    placeInitially() {
        const scene = this.presentedScene;
        const { position, element } = scene;
        const xrCamera = scene.getCamera();
        const { width, height } = this.overlay.getBoundingClientRect();
        scene.setSize(width, height);
        xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();
        const { theta, radius } = element.getCameraOrbit();
        // Orient model to match the 3D camera view
        const cameraDirection = xrCamera.getWorldDirection(vector3);
        scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;
        this.goalYaw = scene.yaw;
        position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius));
        this.updateTarget();
        const target = scene.getTarget();
        position.add(target).sub(this.oldTarget);
        this.goalPosition.copy(position);
        scene.setHotspotsVisibility(true);
        const { session } = this.frame;
        session.addEventListener('selectstart', this.onSelectStart);
        session.addEventListener('selectend', this.onSelectEnd);
        session.requestHitTestSourceForTransientInput({
            profile: 'generic-touchscreen'
        }).then((hitTestSource)=>{
            this.transientHitTestSource = hitTestSource;
        });
    }
    getTouchLocation() {
        const { axes } = this.inputSource.gamepad;
        let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);
        if (location != null) {
            vector3.copy(location).sub(this.presentedScene.getCamera().position);
            if (vector3.length() > MAX_DISTANCE) return null;
        }
        return location;
    }
    getHitPoint(hitResult) {
        const refSpace = this.threeRenderer.xr.getReferenceSpace();
        const pose = hitResult.getPose(refSpace);
        if (pose == null) {
            return null;
        }
        const hitMatrix = matrix4.fromArray(pose.transform.matrix);
        if (this.placeOnWall === true) {
            // Orient the model to the wall's normal vector.
            this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);
        }
        // Check that the y-coordinate of the normal is large enough that the normal
        // is pointing up for floor placement; opposite for wall placement.
        return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null;
    }
    moveToFloor(frame) {
        const hitSource = this.initialHitSource;
        if (hitSource == null) {
            return;
        }
        const hitTestResults = frame.getHitTestResults(hitSource);
        if (hitTestResults.length == 0) {
            return;
        }
        const hit = hitTestResults[0];
        const hitPoint = this.getHitPoint(hit);
        if (hitPoint == null) {
            return;
        }
        this.placementBox.show = true;
        // If the user is translating, let the finger hit-ray take precedence and
        // ignore this hit result.
        if (!this.isTranslating) {
            if (this.placeOnWall) {
                this.goalPosition.copy(hitPoint);
            } else {
                this.goalPosition.y = hitPoint.y;
            }
        }
        hitSource.cancel();
        this.initialHitSource = null;
        this.dispatchEvent({
            type: 'status',
            status: ARStatus.OBJECT_PLACED
        });
    }
    fingerPolar(fingers) {
        const fingerOne = fingers[0].inputSource.gamepad.axes;
        const fingerTwo = fingers[1].inputSource.gamepad.axes;
        const deltaX = fingerTwo[0] - fingerOne[0];
        const deltaY = fingerTwo[1] - fingerOne[1];
        const angle = Math.atan2(deltaY, deltaX);
        let deltaYaw = this.lastAngle - angle;
        if (deltaYaw > Math.PI) {
            deltaYaw -= 2 * Math.PI;
        } else if (deltaYaw < -Math.PI) {
            deltaYaw += 2 * Math.PI;
        }
        this.lastAngle = angle;
        return {
            separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),
            deltaYaw: deltaYaw
        };
    }
    processInput(frame) {
        const hitSource = this.transientHitTestSource;
        if (hitSource == null) {
            return;
        }
        if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {
            return;
        }
        const fingers = frame.getHitTestResultsForTransientInput(hitSource);
        const scene = this.presentedScene;
        const scale = scene.scale.x;
        // Rotating, translating and scaling are mutually exclusive operations; only
        // one can happen at a time, but we can switch during a gesture.
        if (this.isTwoFingering) {
            if (fingers.length < 2) {
                // If we lose the second finger, stop scaling (in fact, stop processing
                // input altogether until a new gesture starts).
                this.isTwoFingering = false;
            } else {
                const { separation, deltaYaw } = this.fingerPolar(fingers);
                if (this.placeOnWall === false) {
                    this.goalYaw += deltaYaw;
                }
                if (scene.canScale) {
                    const scale = separation / this.firstRatio;
                    this.goalScale = scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;
                }
            }
            return;
        } else if (fingers.length === 2) {
            // If we were rotating or translating and we get a second finger, switch
            // to scaling instead.
            this.isTranslating = false;
            this.isRotating = false;
            this.isTwoFingering = true;
            const { separation } = this.fingerPolar(fingers);
            this.firstRatio = separation / scale;
            return;
        }
        if (this.isRotating) {
            const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;
            this.goalYaw += angle - this.lastAngle;
            this.lastAngle = angle;
        } else if (this.isTranslating) {
            fingers.forEach((finger)=>{
                if (finger.inputSource !== this.inputSource) {
                    return;
                }
                let hit = null;
                if (finger.results.length > 0) {
                    hit = this.getHitPoint(finger.results[0]);
                }
                if (hit == null) {
                    hit = this.getTouchLocation();
                }
                if (hit == null) {
                    return;
                }
                this.goalPosition.sub(this.lastDragPosition);
                if (this.placeOnWall === false) {
                    const offset = hit.y - this.lastDragPosition.y;
                    // When a lower floor is found, keep the model at the same height, but
                    // drop the placement box to the floor. The model falls on select end.
                    if (offset < 0) {
                        this.placementBox.offsetHeight = offset / scale;
                        this.presentedScene.setShadowOffset(offset);
                        // Interpolate hit ray up to drag plane
                        const cameraPosition = vector3.copy(scene.getCamera().position);
                        const alpha = -offset / (cameraPosition.y - hit.y);
                        cameraPosition.multiplyScalar(alpha);
                        hit.multiplyScalar(1 - alpha).add(cameraPosition);
                    }
                }
                this.goalPosition.add(hit);
                this.lastDragPosition.copy(hit);
            });
        }
    }
    moveScene(delta) {
        const scene = this.presentedScene;
        const { position, yaw } = scene;
        const boundingRadius = scene.boundingSphere.radius;
        const goal = this.goalPosition;
        const oldScale = scene.scale.x;
        const box = this.placementBox;
        if (!goal.equals(position) || this.goalScale !== oldScale) {
            let { x, y, z } = position;
            x = this.xDamper.update(x, goal.x, delta, boundingRadius);
            y = this.yDamper.update(y, goal.y, delta, boundingRadius);
            z = this.zDamper.update(z, goal.z, delta, boundingRadius);
            position.set(x, y, z);
            const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);
            scene.scale.set(newScale, newScale, newScale);
            if (!this.isTranslating) {
                const offset = goal.y - y;
                if (this.placementComplete && this.placeOnWall === false) {
                    box.offsetHeight = offset / newScale;
                    scene.setShadowOffset(offset);
                } else if (offset === 0) {
                    this.placementComplete = true;
                    box.show = false;
                    scene.setShadowIntensity(AR_SHADOW_INTENSITY);
                }
            }
        }
        box.updateOpacity(delta);
        scene.updateTarget(delta);
        // yaw must be updated last, since this also updates the shadow position.
        scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);
    }
    /**
     * Only public to make it testable.
     */ onWebXRFrame(time, frame) {
        this.frame = frame;
        ++this.frames;
        const refSpace = this.threeRenderer.xr.getReferenceSpace();
        const pose = frame.getViewerPose(refSpace);
        if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {
            this.tracking = false;
            this.dispatchEvent({
                type: 'tracking',
                status: ARTracking.NOT_TRACKING
            });
        }
        const scene = this.presentedScene;
        if (pose == null || scene == null || !scene.element.loaded) {
            this.threeRenderer.clear();
            return;
        }
        if (this.tracking === false) {
            this.tracking = true;
            this.dispatchEvent({
                type: 'tracking',
                status: ARTracking.TRACKING
            });
        }
        // WebXR may return multiple views, i.e. for headset AR. This
        // isn't really supported at this point, but make a best-effort
        // attempt to render other views also, using the first view
        // as the main viewpoint.
        let isFirstView = true;
        for (const view of pose.views){
            this.updateView(view);
            if (isFirstView) {
                this.moveToFloor(frame);
                this.processInput(frame);
                const delta = time - this.lastTick;
                this.moveScene(delta);
                this.renderer.preRender(scene, time, delta);
                this.lastTick = time;
                scene.renderShadow(this.threeRenderer);
            }
            this.threeRenderer.render(scene, scene.getCamera());
            isFirstView = false;
        }
    }
} //# sourceMappingURL=ARRenderer.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/Debugger.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "Debugger": (()=>Debugger)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
class Debugger {
    constructor(renderer){
        // Force WebGL shader debugging on:
        renderer.threeRenderer.debug = {
            checkShaderErrors: true
        };
        // Announce debug details at microtask timing to give the `Renderer`
        // constructor time to complete its initialization, just to be on the safe
        // side:
        Promise.resolve().then(()=>{
            self.dispatchEvent(new CustomEvent('model-viewer-renderer-debug', {
                detail: {
                    renderer,
                    THREE: {
                        ShaderMaterial: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"],
                        Texture: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"],
                        Mesh: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"],
                        Scene: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"],
                        PlaneGeometry: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"],
                        OrthographicCamera: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"],
                        WebGLRenderTarget: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"]
                    }
                }
            }));
        });
    }
    addScene(scene) {
        self.dispatchEvent(new CustomEvent('model-viewer-scene-added-debug', {
            detail: {
                scene
            }
        }));
    }
    removeScene(scene) {
        self.dispatchEvent(new CustomEvent('model-viewer-scene-removed-debug', {
            detail: {
                scene
            }
        }));
    }
} //# sourceMappingURL=Debugger.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/GLTFInstance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$clone": (()=>$clone),
    "$prepare": (()=>$prepare),
    "$prepared": (()=>$prepared),
    "$preparedGLTF": (()=>$preparedGLTF),
    "GLTFInstance": (()=>GLTFInstance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$utils$2f$SkeletonUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/utils/SkeletonUtils.js [app-client] (ecmascript)");
;
;
const $prepared = Symbol('prepared');
const $prepare = Symbol('prepare');
const $preparedGLTF = Symbol('preparedGLTF');
const $clone = Symbol('clone');
class GLTFInstance {
    constructor(preparedGLTF){
        this[$preparedGLTF] = preparedGLTF;
    }
    /**
     * Prepares a given GLTF for presentation and future cloning. A GLTF that is
     * prepared can safely have this method invoked on it multiple times; it will
     * only be prepared once, including after being cloned.
     */ static prepare(source) {
        if (source.scene == null) {
            throw new Error('Model does not have a scene');
        }
        if (source[$prepared]) {
            return source;
        }
        const prepared = this[$prepare](source);
        // NOTE: ES5 Symbol polyfill is not compatible with spread operator
        // so {...prepared, [$prepared]: true} does not work
        prepared[$prepared] = true;
        return prepared;
    }
    /**
     * Override in an inheriting class to apply specialty one-time preparations
     * for a given input GLTF.
     */ static [$prepare](source) {
        // TODO(#195,#1003): We don't currently support multiple scenes, so we don't
        // bother preparing extra scenes for now:
        const { scene } = source;
        const scenes = [
            scene
        ];
        return Object.assign(Object.assign({}, source), {
            scene,
            scenes
        });
    }
    get parser() {
        return this[$preparedGLTF].parser;
    }
    get animations() {
        return this[$preparedGLTF].animations;
    }
    get scene() {
        return this[$preparedGLTF].scene;
    }
    get scenes() {
        return this[$preparedGLTF].scenes;
    }
    get cameras() {
        return this[$preparedGLTF].cameras;
    }
    get asset() {
        return this[$preparedGLTF].asset;
    }
    get userData() {
        return this[$preparedGLTF].userData;
    }
    /**
     * Creates and returns a copy of this instance.
     */ clone() {
        const GLTFInstanceConstructor = this.constructor;
        const clonedGLTF = this[$clone]();
        return new GLTFInstanceConstructor(clonedGLTF);
    }
    /**
     * Cleans up any retained memory that might not otherwise be released when
     * this instance is done being used.
     */ dispose() {
        this.scenes.forEach((scene)=>{
            scene.traverse((object)=>{
                if (!object.isMesh) {
                    return;
                }
                const mesh = object;
                const materials = Array.isArray(mesh.material) ? mesh.material : [
                    mesh.material
                ];
                materials.forEach((material)=>{
                    // Explicitly dispose any textures assigned to this material
                    for(const propertyName in material){
                        const texture = material[propertyName];
                        if (texture instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"]) {
                            const image = texture.source.data;
                            if (image.close != null) {
                                image.close();
                            }
                            texture.dispose();
                        }
                    }
                    material.dispose();
                });
                mesh.geometry.dispose();
            });
        });
    }
    /**
     * Override in an inheriting class to implement specialized cloning strategies
     */ [$clone]() {
        const source = this[$preparedGLTF];
        // TODO(#195,#1003): We don't currently support multiple scenes, so we don't
        // bother cloning extra scenes for now:
        const scene = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$utils$2f$SkeletonUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clone"])(this.scene);
        cloneVariantMaterials(scene, this.scene);
        const scenes = [
            scene
        ];
        const userData = source.userData ? Object.assign({}, source.userData) : {};
        return Object.assign(Object.assign({}, source), {
            scene,
            scenes,
            userData
        });
    }
}
// Variant materials and original material instances are stored under
// object.userData.variantMaterials/originalMaterial.
// Three.js Object3D.clone() doesn't clone Three.js objects under
// .userData so this function is a workaround.
const cloneVariantMaterials = (dst, src)=>{
    traversePair(dst, src, (dst, src)=>{
        if (src.userData.variantMaterials !== undefined) {
            dst.userData.variantMaterials = new Map(src.userData.variantMaterials);
        }
        if (src.userData.variantData !== undefined) {
            dst.userData.variantData = src.userData.variantData;
        }
        if (src.userData.originalMaterial !== undefined) {
            dst.userData.originalMaterial = src.userData.originalMaterial;
        }
    });
};
const traversePair = (obj1, obj2, callback)=>{
    callback(obj1, obj2);
    // Assume obj1 and obj2 have the same tree structure
    for(let i = 0; i < obj1.children.length; i++){
        traversePair(obj1.children[i], obj2.children[i], callback);
    }
}; //# sourceMappingURL=GLTFInstance.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/correlated-scene-graph.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CorrelatedSceneGraph": (()=>CorrelatedSceneGraph)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
const $threeGLTF = Symbol('threeGLTF');
const $gltf = Symbol('gltf');
const $gltfElementMap = Symbol('gltfElementMap');
const $threeObjectMap = Symbol('threeObjectMap');
const $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');
const $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');
const $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');
class CorrelatedSceneGraph {
    constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap){
        this[$threeGLTF] = threeGLTF;
        this[$gltf] = gltf;
        this[$gltfElementMap] = gltfElementMap;
        this[$threeObjectMap] = threeObjectMap;
    }
    /**
     * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.
     * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached
     * details that expedite the correlation step.
     *
     * If a CorrelatedSceneGraph is provided as the second argument, re-correlates
     * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce
     * the upstream Three.js GLTF that the clone was created from. The result
     * CorrelatedSceneGraph is representative of the cloned hierarchy.
     */ static from(threeGLTF, upstreamCorrelatedSceneGraph) {
        if (upstreamCorrelatedSceneGraph != null) {
            return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);
        } else {
            return this[$correlateOriginalThreeGLTF](threeGLTF);
        }
    }
    static [$correlateOriginalThreeGLTF](threeGLTF) {
        const gltf = threeGLTF.parser.json;
        const associations = threeGLTF.parser.associations;
        const gltfElementMap = new Map();
        const defaultMaterial = {
            name: 'Default'
        };
        const defaultReference = {
            type: 'materials',
            index: -1
        };
        for (const threeMaterial of associations.keys()){
            // Note: GLTFLoader creates a "default" material that has no
            // corresponding glTF element in the case that no materials are
            // specified in the source glTF. In this case we append a default
            // material to allow this to be operated upon.
            if (threeMaterial instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"] && associations.get(threeMaterial) == null) {
                if (defaultReference.index < 0) {
                    if (gltf.materials == null) {
                        gltf.materials = [];
                    }
                    defaultReference.index = gltf.materials.length;
                    gltf.materials.push(defaultMaterial);
                }
                threeMaterial.name = defaultMaterial.name;
                associations.set(threeMaterial, {
                    materials: defaultReference.index
                });
            }
        }
        // Creates a reverse look up map (gltf-object to Three-object)
        for (const [threeObject, gltfMappings] of associations){
            if (gltfMappings) {
                const objWithUserData = threeObject;
                objWithUserData.userData = objWithUserData.userData || {};
                objWithUserData.userData.associations = gltfMappings;
            }
            for(const mapping in gltfMappings){
                if (mapping != null && mapping !== 'primitives') {
                    const type = mapping;
                    const elementArray = gltf[type] || [];
                    const gltfElement = elementArray[gltfMappings[type]];
                    if (gltfElement == null) {
                        continue;
                    }
                    let threeObjects = gltfElementMap.get(gltfElement);
                    if (threeObjects == null) {
                        threeObjects = new Set();
                        gltfElementMap.set(gltfElement, threeObjects);
                    }
                    threeObjects.add(threeObject);
                }
            }
        }
        return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);
    }
    /**
     * Transfers the association between a raw glTF and a Three.js scene graph
     * to a clone of the Three.js scene graph, resolved as a new
     * CorrelatedSceneGraph instance.
     */ static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {
        const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;
        const originalGLTF = upstreamCorrelatedSceneGraph.gltf;
        const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));
        const cloneThreeObjectMap = new Map();
        const cloneGLTFElementMap = new Map();
        for(let i = 0; i < originalThreeGLTF.scenes.length; i++){
            this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject)=>{
                const elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);
                if (elementReference == null) {
                    return;
                }
                for(const mapping in elementReference){
                    if (mapping != null && mapping !== 'primitives') {
                        const type = mapping;
                        const index = elementReference[type];
                        const cloneElement = cloneGLTF[type][index];
                        const mappings = cloneThreeObjectMap.get(cloneObject) || {};
                        mappings[type] = index;
                        cloneThreeObjectMap.set(cloneObject, mappings);
                        const cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set();
                        cloneObjects.add(cloneObject);
                        cloneGLTFElementMap.set(cloneElement, cloneObjects);
                    }
                }
            });
        }
        return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);
    }
    /**
     * Traverses two presumably identical Three.js scenes, and invokes a
     * callback for each Object3D or Material encountered, including the initial
     * scene. Adapted from
     * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596
     */ static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {
        const isMesh = (object)=>{
            return object.isMesh;
        };
        const traverse = (a, b)=>{
            callback(a, b);
            if (a.isObject3D) {
                if (isMesh(a)) {
                    if (Array.isArray(a.material)) {
                        for(let i = 0; i < a.material.length; ++i){
                            traverse(a.material[i], b.material[i]);
                        }
                    } else {
                        traverse(a.material, b.material);
                    }
                }
                for(let i = 0; i < a.children.length; ++i){
                    traverse(a.children[i], b.children[i]);
                }
            }
        };
        traverse(sceneOne, sceneTwo);
    }
    /**
     * The source Three.js GLTF result given to us by a Three.js GLTFLoader.
     */ get threeGLTF() {
        return this[$threeGLTF];
    }
    /**
     * The in-memory deserialized source glTF.
     */ get gltf() {
        return this[$gltf];
    }
    /**
     * A Map of glTF element references to arrays of corresponding Three.js
     * object references. Three.js objects are kept in arrays to account for
     * cases where more than one Three.js object corresponds to a single glTF
     * element.
     */ get gltfElementMap() {
        return this[$gltfElementMap];
    }
    /**
     * A map of individual Three.js objects to corresponding elements in the
     * source glTF.
     */ get threeObjectMap() {
        return this[$threeObjectMap];
    }
} //# sourceMappingURL=correlated-scene-graph.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ModelViewerGLTFInstance": (()=>ModelViewerGLTFInstance)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/GLTFInstance.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$correlated$2d$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/correlated-scene-graph.js [app-client] (ecmascript)");
;
;
;
const $correlatedSceneGraph = Symbol('correlatedSceneGraph');
class ModelViewerGLTFInstance extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFInstance"] {
    /**
     * @override
     */ static [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$prepare"]](source) {
        const prepared = super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$prepare"]](source);
        if (prepared[$correlatedSceneGraph] == null) {
            prepared[$correlatedSceneGraph] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$correlated$2d$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CorrelatedSceneGraph"].from(prepared);
        }
        const { scene } = prepared;
        const nullSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"](undefined, Infinity);
        scene.traverse((node)=>{
            // Set a high renderOrder while we're here to ensure the model
            // always renders on top of the sky sphere
            node.renderOrder = 1000;
            // Three.js seems to cull some animated models incorrectly. Since we
            // expect to view our whole scene anyway, we turn off the frustum
            // culling optimization here.
            node.frustumCulled = false;
            // Animations for objects without names target their UUID instead. When
            // objects are cloned, they get new UUIDs which the animation can't
            // find. To fix this, we assign their UUID as their name.
            if (!node.name) {
                node.name = node.uuid;
            }
            const mesh = node;
            if (mesh.isMesh) {
                const { geometry } = mesh;
                mesh.castShadow = true;
                if (mesh.isSkinnedMesh) {
                    // Akin to disabling frustum culling above, we have to also manually
                    // disable the bounds to make raycasting correct for skinned meshes.
                    geometry.boundingSphere = nullSphere;
                    // The bounding box is set in GLTFLoader by the accessor bounds, which
                    // are not updated with animation.
                    geometry.boundingBox = null;
                }
                const material = mesh.material;
                if (material.isMeshBasicMaterial === true) {
                    material.toneMapped = false;
                }
                // This makes shadows better for non-manifold meshes
                material.shadowSide = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"];
                // Fixes an edge case with unused extra UV-coords being incorrectly
                // referenced by three.js; remove when
                // https://github.com/mrdoob/three.js/pull/23974 is merged.
                if (material.aoMap) {
                    const { gltf, threeObjectMap } = prepared[$correlatedSceneGraph];
                    const gltfRef = threeObjectMap.get(material);
                    if (gltf.materials != null && gltfRef != null && gltfRef.materials != null) {
                        const gltfMaterial = gltf.materials[gltfRef.materials];
                        if (gltfMaterial.occlusionTexture && gltfMaterial.occlusionTexture.texCoord === 0 && geometry.attributes.uv != null) {
                            geometry.setAttribute('uv2', geometry.attributes.uv);
                        }
                    }
                }
            }
        });
        return prepared;
    }
    get correlatedSceneGraph() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$preparedGLTF"]][$correlatedSceneGraph];
    }
    /**
     * @override
     */ [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$clone"]]() {
        const clone = super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$GLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$clone"]]();
        const sourceUUIDToClonedMaterial = new Map();
        clone.scene.traverse((node)=>{
            // Materials aren't cloned when cloning meshes; geometry
            // and materials are copied by reference. This is necessary
            // for the same model to be used twice with different
            // scene-graph operations.
            if (node.isMesh) {
                const mesh = node;
                const material = mesh.material;
                if (material != null) {
                    if (sourceUUIDToClonedMaterial.has(material.uuid)) {
                        mesh.material = sourceUUIDToClonedMaterial.get(material.uuid);
                        return;
                    }
                    mesh.material = material.clone();
                    sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);
                }
            }
        });
        // Cross-correlate the scene graph by relying on information in the
        // current scene graph; without this step, relationships between the
        // Three.js object graph and the glTF scene graph will be lost.
        clone[$correlatedSceneGraph] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$correlated$2d$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CorrelatedSceneGraph"].from(clone, this.correlatedSceneGraph);
        return clone;
    }
} //# sourceMappingURL=ModelViewerGLTFInstance.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/EnvironmentScene.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>EnvironmentScene)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
class EnvironmentScene extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"] {
    constructor(){
        super();
        this.position.y = -3.5;
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"]();
        geometry.deleteAttribute('uv');
        const roomMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            metalness: 0,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"]
        });
        const boxMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            metalness: 0
        });
        const mainLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](0xffffff, 500.0, 28, 2);
        mainLight.position.set(0.418, 16.199, 0.300);
        this.add(mainLight);
        const room = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, roomMaterial);
        room.position.set(-0.757, 13.219, 0.717);
        room.scale.set(31.713, 28.305, 28.591);
        this.add(room);
        const box1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box1.position.set(-10.906, 2.009, 1.846);
        box1.rotation.set(0, -0.195, 0);
        box1.scale.set(2.328, 7.905, 4.651);
        this.add(box1);
        const box2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box2.position.set(-5.607, -0.754, -0.758);
        box2.rotation.set(0, 0.994, 0);
        box2.scale.set(1.970, 1.534, 3.955);
        this.add(box2);
        const box3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box3.position.set(6.167, 0.857, 7.803);
        box3.rotation.set(0, 0.561, 0);
        box3.scale.set(3.927, 6.285, 3.687);
        this.add(box3);
        const box4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box4.position.set(-2.017, 0.018, 6.124);
        box4.rotation.set(0, 0.333, 0);
        box4.scale.set(2.002, 4.566, 2.064);
        this.add(box4);
        const box5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box5.position.set(2.291, -0.756, -2.621);
        box5.rotation.set(0, -0.286, 0);
        box5.scale.set(1.546, 1.552, 1.496);
        this.add(box5);
        const box6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box6.position.set(-2.193, -0.369, -5.547);
        box6.rotation.set(0, 0.516, 0);
        box6.scale.set(3.875, 3.487, 2.986);
        this.add(box6);
        // -x right
        const light1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(50));
        light1.position.set(-16.116, 14.37, 8.208);
        light1.scale.set(0.1, 2.428, 2.739);
        this.add(light1);
        // -x left
        const light2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(50));
        light2.position.set(-16.109, 18.021, -8.207);
        light2.scale.set(0.1, 2.425, 2.751);
        this.add(light2);
        // +x
        const light3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(17));
        light3.position.set(14.904, 12.198, -1.832);
        light3.scale.set(0.15, 4.265, 6.331);
        this.add(light3);
        // +z
        const light4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(43));
        light4.position.set(-0.462, 8.89, 14.520);
        light4.scale.set(4.38, 5.441, 0.088);
        this.add(light4);
        // -z
        const light5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(20));
        light5.position.set(3.235, 11.486, -12.541);
        light5.scale.set(2.5, 2.0, 0.1);
        this.add(light5);
        // +y
        const light6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(100));
        light6.position.set(0.0, 20.0, 0.0);
        light6.scale.set(1.0, 0.1, 1.0);
        this.add(light6);
    }
    createAreaLightMaterial(intensity) {
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
        material.color.setScalar(intensity);
        return material;
    }
} //# sourceMappingURL=EnvironmentScene.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/EnvironmentSceneAlt.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>EnvironmentSceneAlt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
class EnvironmentSceneAlt extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"] {
    constructor(){
        super();
        this.position.y = -3.5;
        const geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"]();
        geometry.deleteAttribute('uv');
        const roomMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            metalness: 0,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"]
        });
        const boxMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshStandardMaterial"]({
            metalness: 0
        });
        const mainLight = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PointLight"](0xffffff, 400.0, 28, 2);
        mainLight.position.set(0.5, 14.0, 0.5);
        this.add(mainLight);
        const room = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, roomMaterial);
        room.position.set(0.0, 13.2, 0.0);
        room.scale.set(31.5, 28.5, 31.5);
        this.add(room);
        const box1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box1.position.set(-10.906, -1.0, 1.846);
        box1.rotation.set(0, -0.195, 0);
        box1.scale.set(2.328, 7.905, 4.651);
        this.add(box1);
        const box2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box2.position.set(-5.607, -0.754, -0.758);
        box2.rotation.set(0, 0.994, 0);
        box2.scale.set(1.970, 1.534, 3.955);
        this.add(box2);
        const box3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box3.position.set(6.167, -0.16, 7.803);
        box3.rotation.set(0, 0.561, 0);
        box3.scale.set(3.927, 6.285, 3.687);
        this.add(box3);
        const box4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box4.position.set(-2.017, 0.018, 6.124);
        box4.rotation.set(0, 0.333, 0);
        box4.scale.set(2.002, 4.566, 2.064);
        this.add(box4);
        const box5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box5.position.set(2.291, -0.756, -2.621);
        box5.rotation.set(0, -0.286, 0);
        box5.scale.set(1.546, 1.552, 1.496);
        this.add(box5);
        const box6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, boxMaterial);
        box6.position.set(-2.193, -0.369, -5.547);
        box6.rotation.set(0, 0.516, 0);
        box6.scale.set(3.875, 3.487, 2.986);
        this.add(box6);
        // -x_left
        const light1 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(80));
        light1.position.set(-14.0, 10.0, 8.0);
        light1.scale.set(0.1, 2.5, 2.5);
        this.add(light1);
        // -x_right
        const light2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(80));
        light2.position.set(-14.0, 14.0, -4.0);
        light2.scale.set(0.1, 2.5, 2.5);
        this.add(light2);
        // +x only on light
        const light3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(23));
        light3.position.set(14.0, 12.0, 0.0);
        light3.scale.set(0.1, 5.0, 5.0);
        this.add(light3);
        // +z
        const light4 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(16));
        light4.position.set(0.0, 9.0, 14.0);
        light4.scale.set(5.0, 5.0, 0.1);
        this.add(light4);
        // -z right
        const light5 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(80));
        light5.position.set(7.0, 8.0, -14.0);
        light5.scale.set(2.5, 2.5, 0.1);
        this.add(light5);
        // -z left
        const light6 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(80));
        light6.position.set(-7.0, 16.0, -14.0);
        light6.scale.set(2.5, 2.5, 0.1);
        this.add(light6);
        // +y
        const light7 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](geometry, this.createAreaLightMaterial(1));
        light7.position.set(0.0, 20.0, 0.0);
        light7.scale.set(0.1, 0.1, 0.1);
        this.add(light7);
    }
    createAreaLightMaterial(intensity) {
        const material = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
        material.color.setScalar(intensity);
        return material;
    }
} //# sourceMappingURL=EnvironmentSceneAlt.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/TextureUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "default": (()=>TextureUtils)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/loaders/RGBELoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$EnvironmentScene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/EnvironmentScene.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$EnvironmentSceneAlt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/EnvironmentSceneAlt.js [app-client] (ecmascript)");
;
;
;
;
;
const GENERATED_SIGMA = 0.04;
// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;
const HDR_FILE_RE = /\.hdr(\.js)?$/;
const ldrLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"]();
const hdrLoader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$loaders$2f$RGBELoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBELoader"]();
hdrLoader.setDataType(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"]);
class TextureUtils extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
    constructor(threeRenderer){
        super();
        this.threeRenderer = threeRenderer;
        this.generatedEnvironmentMap = null;
        this.generatedEnvironmentMapAlt = null;
        this.skyboxCache = new Map();
        this.blurMaterial = null;
        this.blurScene = null;
    }
    async load(url, progressCallback = ()=>{}) {
        try {
            const isHDR = HDR_FILE_RE.test(url);
            const loader = isHDR ? hdrLoader : ldrLoader;
            const texture = await new Promise((resolve, reject)=>loader.load(url, resolve, (event)=>{
                    progressCallback(event.loaded / event.total * 0.9);
                }, reject));
            progressCallback(1.0);
            texture.name = url;
            texture.mapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EquirectangularReflectionMapping"];
            if (!isHDR) {
                texture.encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sRGBEncoding"];
            }
            return texture;
        } finally{
            if (progressCallback) {
                progressCallback(1);
            }
        }
    }
    /**
     * Returns a { skybox, environmentMap } object with the targets/textures
     * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`
     * is a Texture from a WebGLRenderCubeTarget.
     */ async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = ()=>{}) {
        const useAltEnvironment = environmentMapUrl !== 'legacy';
        if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {
            environmentMapUrl = null;
        }
        environmentMapUrl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deserializeUrl"])(environmentMapUrl);
        let skyboxLoads = Promise.resolve(null);
        let environmentMapLoads;
        // If we have a skybox URL, attempt to load it as a cubemap
        if (!!skyboxUrl) {
            skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);
        }
        if (!!environmentMapUrl) {
            // We have an available environment map URL
            environmentMapLoads = this.loadEquirectFromUrl(environmentMapUrl, progressCallback);
        } else if (!!skyboxUrl) {
            // Fallback to deriving the environment map from an available skybox
            environmentMapLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback);
        } else {
            // Fallback to generating the environment map
            environmentMapLoads = useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
        }
        const [environmentMap, skybox] = await Promise.all([
            environmentMapLoads,
            skyboxLoads
        ]);
        if (environmentMap == null) {
            throw new Error('Failed to load environment map.');
        }
        return {
            environmentMap,
            skybox
        };
    }
    /**
     * Loads an equirect Texture from a given URL, for use as a skybox.
     */ async loadEquirectFromUrl(url, progressCallback) {
        if (!this.skyboxCache.has(url)) {
            const skyboxMapLoads = this.load(url, progressCallback);
            this.skyboxCache.set(url, skyboxMapLoads);
        }
        return this.skyboxCache.get(url);
    }
    async GenerateEnvironmentMap(scene, name) {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timePasses"])();
        const renderer = this.threeRenderer;
        const cubeTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLCubeRenderTarget"](256, {
            generateMipmaps: false,
            type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HalfFloatType"],
            format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"],
            encoding: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearEncoding"],
            depthBuffer: true
        });
        const cubeCamera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeCamera"](0.1, 100, cubeTarget);
        const generatedEnvironmentMap = cubeCamera.renderTarget.texture;
        generatedEnvironmentMap.name = name;
        const outputEncoding = renderer.outputEncoding;
        const toneMapping = renderer.toneMapping;
        renderer.toneMapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoToneMapping"];
        renderer.outputEncoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearEncoding"];
        cubeCamera.update(renderer, scene);
        this.blurCubemap(cubeTarget, GENERATED_SIGMA);
        renderer.toneMapping = toneMapping;
        renderer.outputEncoding = outputEncoding;
        return generatedEnvironmentMap;
    }
    /**
     * Loads a dynamically generated environment map.
     */ async loadGeneratedEnvironmentMap() {
        if (this.generatedEnvironmentMap == null) {
            this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$EnvironmentScene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](), 'legacy');
        }
        return this.generatedEnvironmentMap;
    }
    /**
     * Loads a dynamically generated environment map, designed to be neutral and
     * color-preserving. Shows less contrast around the different sides of the
     * object.
     */ async loadGeneratedEnvironmentMapAlt() {
        if (this.generatedEnvironmentMapAlt == null) {
            this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$EnvironmentSceneAlt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](), 'neutral');
        }
        return this.generatedEnvironmentMapAlt;
    }
    blurCubemap(cubeTarget, sigma) {
        if (this.blurMaterial == null) {
            this.blurMaterial = this.getBlurShader(MAX_SAMPLES);
            const box = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BoxGeometry"]();
            const blurMesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](box, this.blurMaterial);
            this.blurScene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
            this.blurScene.add(blurMesh);
        }
        const tempTarget = cubeTarget.clone();
        this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');
        this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');
    // Disposing this target after we're done with it somehow corrupts Safari's
    // whole graphics driver. It's random, but occurs more frequently on
    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes
    // beyond just messing up the PMREM, as it also occasionally causes
    // visible corruption on the canvas and even on the rest of the page.
    /** tempTarget.dispose(); */ }
    halfblur(targetIn, targetOut, sigmaRadians, direction) {
        // Number of standard deviations at which to cut off the discrete
        // approximation.
        const STANDARD_DEVIATIONS = 3;
        const pixels = targetIn.width;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
            console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for(let i = 0; i < MAX_SAMPLES; ++i){
            const x = i / sigmaPixels;
            const weight = Math.exp(-x * x / 2);
            weights.push(weight);
            if (i == 0) {
                sum += weight;
            } else if (i < samples) {
                sum += 2 * weight;
            }
        }
        for(let i = 0; i < weights.length; i++){
            weights[i] = weights[i] / sum;
        }
        const blurUniforms = this.blurMaterial.uniforms;
        blurUniforms['envMap'].value = targetIn.texture;
        blurUniforms['samples'].value = samples;
        blurUniforms['weights'].value = weights;
        blurUniforms['latitudinal'].value = direction === 'latitudinal';
        blurUniforms['dTheta'].value = radiansPerPixel;
        const cubeCamera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CubeCamera"](0.1, 100, targetOut);
        cubeCamera.update(this.threeRenderer, this.blurScene);
    }
    getBlurShader(maxSamples) {
        const weights = new Float32Array(maxSamples);
        const poleAxis = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        const shaderMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"]({
            name: 'SphericalGaussianBlur',
            defines: {
                'n': maxSamples
            },
            uniforms: {
                'envMap': {
                    value: null
                },
                'samples': {
                    value: 1
                },
                'weights': {
                    value: weights
                },
                'latitudinal': {
                    value: false
                },
                'dTheta': {
                    value: 0
                },
                'poleAxis': {
                    value: poleAxis
                }
            },
            vertexShader: /* glsl */ `
      
      varying vec3 vOutputDirection;
  
      void main() {
  
        vOutputDirection = vec3( position );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
      }
    `,
            fragmentShader: /* glsl */ `
        varying vec3 vOutputDirection;
  
        uniform samplerCube envMap;
        uniform int samples;
        uniform float weights[ n ];
        uniform bool latitudinal;
        uniform float dTheta;
        uniform vec3 poleAxis;
  
        vec3 getSample( float theta, vec3 axis ) {
  
          float cosTheta = cos( theta );
          // Rodrigues' axis-angle rotation
          vec3 sampleDirection = vOutputDirection * cosTheta
            + cross( axis, vOutputDirection ) * sin( theta )
            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );
  
          return vec3( textureCube( envMap, sampleDirection ) );
  
        }
  
        void main() {
  
          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );
  
          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {
  
            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );
  
          }
  
          axis = normalize( axis );
  
          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );
  
          for ( int i = 1; i < n; i++ ) {
  
            if ( i >= samples ) {
  
              break;
  
            }
  
            float theta = dTheta * float( i );
            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
  
          }
        }
      `,
            blending: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NoBlending"],
            depthTest: false,
            depthWrite: false,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"]
        });
        return shaderMaterial;
    }
    async dispose() {
        for (const [, promise] of this.skyboxCache){
            const skybox = await promise;
            skybox.dispose();
        }
        if (this.generatedEnvironmentMap != null) {
            (await this.generatedEnvironmentMap).dispose();
            this.generatedEnvironmentMap = null;
        }
        if (this.generatedEnvironmentMapAlt != null) {
            (await this.generatedEnvironmentMapAlt).dispose();
            this.generatedEnvironmentMapAlt = null;
        }
        if (this.blurMaterial != null) {
            this.blurMaterial.dispose();
        }
    }
} //# sourceMappingURL=TextureUtils.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/Renderer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "DEFAULT_POWER_PREFERENCE": (()=>DEFAULT_POWER_PREFERENCE),
    "Renderer": (()=>Renderer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/ARRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Debugger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Debugger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$ModelViewerGLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/ModelViewerGLTFInstance.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$TextureUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/TextureUtils.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
// Between 0 and 1: larger means the average responds faster and is less smooth.
const DURATION_DECAY = 0.2;
const LOW_FRAME_DURATION_MS = 40;
const HIGH_FRAME_DURATION_MS = 60;
const MAX_AVG_CHANGE_MS = 5;
const SCALE_STEPS = [
    1,
    0.79,
    0.62,
    0.5,
    0.4,
    0.31,
    0.25
];
const DEFAULT_LAST_STEP = 3;
const DEFAULT_POWER_PREFERENCE = 'high-performance';
class Renderer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
    constructor(options){
        super();
        this.loader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$ModelViewerGLTFInstance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModelViewerGLTFInstance"]);
        this.width = 0;
        this.height = 0;
        this.dpr = 1;
        this.debugger = null;
        this.scenes = new Set();
        this.multipleScenesVisible = false;
        this.lastTick = performance.now();
        this.renderedLastFrame = false;
        this.scaleStep = 0;
        this.lastStep = DEFAULT_LAST_STEP;
        this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;
        this.onWebGLContextLost = (event)=>{
            this.dispatchEvent({
                type: 'contextlost',
                sourceEvent: event
            });
        };
        this.onWebGLContextRestored = ()=>{
            var _a;
            (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();
            this.textureUtils = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$TextureUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.threeRenderer);
            for (const scene of this.scenes){
                scene.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateEnvironment"]]();
            }
        };
        this.dpr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveDpr"])();
        this.canvas3D = document.createElement('canvas');
        this.canvas3D.id = 'webgl-canvas';
        this.canvas3D.classList.add('show');
        try {
            this.threeRenderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderer"]({
                canvas: this.canvas3D,
                alpha: true,
                antialias: true,
                powerPreference: options.powerPreference,
                preserveDrawingBuffer: true
            });
            this.threeRenderer.autoClear = true;
            this.threeRenderer.outputEncoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sRGBEncoding"];
            this.threeRenderer.physicallyCorrectLights = true;
            this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally
            this.debugger = !!options.debug ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Debugger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Debugger"](this) : null;
            this.threeRenderer.debug = {
                checkShaderErrors: !!this.debugger
            };
            // ACESFilmicToneMapping appears to be the most "saturated",
            // and similar to Filament's gltf-viewer.
            this.threeRenderer.toneMapping = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ACESFilmicToneMapping"];
        } catch (error) {
            console.warn(error);
        }
        this.arRenderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARRenderer"](this);
        this.textureUtils = this.canRender ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$TextureUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](this.threeRenderer) : null;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].initializeKTX2Loader(this.threeRenderer);
        this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);
        this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);
        this.updateRendererSize();
    }
    static get singleton() {
        return this._singleton;
    }
    static resetSingleton() {
        const elements = this._singleton.dispose();
        for (const element of elements){
            element.disconnectedCallback();
        }
        this._singleton = new Renderer({
            powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,
            debug: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDebugMode"])()
        });
        for (const element of elements){
            element.connectedCallback();
        }
    }
    get canRender() {
        return this.threeRenderer != null;
    }
    get scaleFactor() {
        return SCALE_STEPS[this.scaleStep];
    }
    set minScale(scale) {
        let i = 1;
        while(i < SCALE_STEPS.length){
            if (SCALE_STEPS[i] < scale) {
                break;
            }
            ++i;
        }
        this.lastStep = i - 1;
    }
    registerScene(scene) {
        this.scenes.add(scene);
        scene.forceRescale();
        const size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
        this.threeRenderer.getSize(size);
        scene.canvas.width = size.x;
        scene.canvas.height = size.y;
        if (this.canRender && this.scenes.size > 0) {
            this.threeRenderer.setAnimationLoop((time, frame)=>this.render(time, frame));
        }
        if (this.debugger != null) {
            this.debugger.addScene(scene);
        }
    }
    unregisterScene(scene) {
        this.scenes.delete(scene);
        if (this.canvas3D.parentElement === scene.canvas.parentElement) {
            scene.canvas.parentElement.removeChild(this.canvas3D);
        }
        if (this.canRender && this.scenes.size === 0) {
            this.threeRenderer.setAnimationLoop(null);
        }
        if (this.debugger != null) {
            this.debugger.removeScene(scene);
        }
    }
    displayCanvas(scene) {
        return this.multipleScenesVisible ? scene.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$canvas"]] : this.canvas3D;
    }
    /**
     * The function enables an optimization, where when there is only a single
     * <model-viewer> element, we can use the renderer's 3D canvas directly for
     * display. Otherwise we need to use the element's 2D canvas and copy the
     * renderer's result into it.
     */ countVisibleScenes() {
        const { canvas3D } = this;
        let visibleScenes = 0;
        let canvas3DScene = null;
        for (const scene of this.scenes){
            const { element } = scene;
            if (element.modelIsVisible && scene.externalRenderer == null) {
                ++visibleScenes;
            }
            if (canvas3D.parentElement === scene.canvas.parentElement) {
                canvas3DScene = scene;
            }
        }
        const multipleScenesVisible = visibleScenes > 1;
        if (canvas3DScene != null) {
            const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;
            const disappearing = !canvas3DScene.element.modelIsVisible;
            if (newlyMultiple || disappearing) {
                const { width, height } = this.sceneSize(canvas3DScene);
                this.copyPixels(canvas3DScene, width, height);
                canvas3D.parentElement.removeChild(canvas3D);
            }
        }
        this.multipleScenesVisible = multipleScenesVisible;
    }
    /**
     * Updates the renderer's size based on the largest scene and any changes to
     * device pixel ratio.
     */ updateRendererSize() {
        const dpr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveDpr"])();
        if (dpr !== this.dpr) {
            // If the device pixel ratio has changed due to page zoom, elements
            // specified by % width do not fire a resize event even though their CSS
            // pixel dimensions change, so we force them to update their size here.
            for (const scene of this.scenes){
                const { element } = scene;
                element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateSize"]](element.getBoundingClientRect());
            }
        }
        // Make the renderer the size of the largest scene
        let width = 0;
        let height = 0;
        for (const scene of this.scenes){
            width = Math.max(width, scene.width);
            height = Math.max(height, scene.height);
        }
        if (width === this.width && height === this.height && dpr === this.dpr) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dpr = dpr;
        width = Math.ceil(width * dpr);
        height = Math.ceil(height * dpr);
        if (this.canRender) {
            this.threeRenderer.setSize(width, height, false);
        }
        // Each scene's canvas must match the renderer size. In general they can be
        // larger than the element that contains them, but the overflow is hidden
        // and only the portion that is shown is copied over.
        for (const scene of this.scenes){
            const { canvas } = scene;
            canvas.width = width;
            canvas.height = height;
            scene.forceRescale();
        }
    }
    updateRendererScale(delta) {
        const scaleStep = this.scaleStep;
        this.avgFrameDuration += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);
        if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {
            ++this.scaleStep;
        } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {
            --this.scaleStep;
        }
        this.scaleStep = Math.min(this.scaleStep, this.lastStep);
        if (scaleStep !== this.scaleStep) {
            this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;
        }
    }
    shouldRender(scene) {
        if (!scene.shouldRender()) {
            // The first frame we stop rendering the scene (because it stops moving),
            // trigger one extra render at full scale.
            if (scene.scaleStep != 0) {
                scene.scaleStep = 0;
                this.rescaleCanvas(scene);
            } else {
                return false;
            }
        } else if (scene.scaleStep != this.scaleStep) {
            // Update render scale
            scene.scaleStep = this.scaleStep;
            this.rescaleCanvas(scene);
        }
        return true;
    }
    rescaleCanvas(scene) {
        const scale = SCALE_STEPS[scene.scaleStep];
        const width = Math.ceil(this.width / scale);
        const height = Math.ceil(this.height / scale);
        const { style } = scene.canvas;
        style.width = `${width}px`;
        style.height = `${height}px`;
        this.canvas3D.style.width = `${width}px`;
        this.canvas3D.style.height = `${height}px`;
        const renderedDpr = this.dpr * scale;
        const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';
        scene.element.dispatchEvent(new CustomEvent('render-scale', {
            detail: {
                reportedDpr: window.devicePixelRatio,
                renderedDpr: renderedDpr,
                minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],
                pixelWidth: Math.ceil(scene.width * renderedDpr),
                pixelHeight: Math.ceil(scene.height * renderedDpr),
                reason: reason
            }
        }));
    }
    sceneSize(scene) {
        const { dpr } = this;
        const scaleFactor = SCALE_STEPS[scene.scaleStep];
        // We avoid using the Three.js PixelRatio and handle it ourselves here so
        // that we can do proper rounding and avoid white boundary pixels.
        const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);
        const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);
        return {
            width,
            height
        };
    }
    copyPixels(scene, width, height) {
        const context2D = scene.context;
        if (context2D == null) {
            console.log('could not acquire 2d context');
            return;
        }
        context2D.clearRect(0, 0, width, height);
        context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);
        scene.canvas.classList.add('show');
    }
    /**
     * Returns an array version of this.scenes where the non-visible ones are
     * first. This allows eager scenes to be rendered before they are visible,
     * without needing the multi-canvas render path.
     */ orderedScenes() {
        const scenes = [];
        for (const visible of [
            false,
            true
        ]){
            for (const scene of this.scenes){
                if (scene.element.modelIsVisible === visible) {
                    scenes.push(scene);
                }
            }
        }
        return scenes;
    }
    get isPresenting() {
        return this.arRenderer.isPresenting;
    }
    /**
     * This method takes care of updating the element and renderer state based on
     * the time that has passed since the last rendered frame.
     */ preRender(scene, t, delta) {
        const { element, exposure } = scene;
        element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](t, delta);
        const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);
        this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;
    }
    render(t, frame) {
        if (frame != null) {
            this.arRenderer.onWebXRFrame(t, frame);
            return;
        }
        const delta = t - this.lastTick;
        this.lastTick = t;
        if (!this.canRender || this.isPresenting) {
            return;
        }
        this.countVisibleScenes();
        this.updateRendererSize();
        if (this.renderedLastFrame) {
            this.updateRendererScale(delta);
            this.renderedLastFrame = false;
        }
        const { canvas3D } = this;
        for (const scene of this.orderedScenes()){
            const { element } = scene;
            if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {
                continue;
            }
            this.preRender(scene, t, delta);
            if (!this.shouldRender(scene)) {
                continue;
            }
            if (scene.externalRenderer != null) {
                const camera = scene.getCamera();
                camera.updateMatrix();
                const { matrix, projectionMatrix } = camera;
                const viewMatrix = matrix.elements.slice();
                const target = scene.getTarget();
                viewMatrix[12] += target.x;
                viewMatrix[13] += target.y;
                viewMatrix[14] += target.z;
                scene.externalRenderer.render({
                    viewMatrix: viewMatrix,
                    projectionMatrix: projectionMatrix.elements
                });
                continue;
            }
            if (!element.modelIsVisible && !this.multipleScenesVisible) {
                // Here we are pre-rendering on the visible canvas, so we must mark the
                // visible scene dirty to ensure it overwrites us.
                for (const visibleScene of this.scenes){
                    if (visibleScene.element.modelIsVisible) {
                        visibleScene.queueRender();
                    }
                }
            }
            const { width, height } = this.sceneSize(scene);
            scene.renderShadow(this.threeRenderer);
            // Need to set the render target in order to prevent
            // clearing the depth from a different buffer
            this.threeRenderer.setRenderTarget(null);
            this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);
            this.threeRenderer.render(scene, scene.camera);
            if (this.multipleScenesVisible || scene.renderCount === 0) {
                this.copyPixels(scene, width, height);
            } else {
                if (canvas3D.parentElement !== scene.canvas.parentElement) {
                    scene.canvas.parentElement.appendChild(canvas3D);
                    scene.canvas.classList.remove('show');
                }
            }
            scene.hasRendered();
            ++scene.renderCount;
            this.renderedLastFrame = true;
        }
    }
    dispose() {
        if (this.textureUtils != null) {
            this.textureUtils.dispose();
        }
        if (this.threeRenderer != null) {
            this.threeRenderer.dispose();
        }
        this.textureUtils = null;
        this.threeRenderer = null;
        const elements = [];
        for (const scene of this.scenes){
            elements.push(scene.element);
        }
        this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);
        this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);
        return elements;
    }
}
Renderer._singleton = new Renderer({
    powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,
    debug: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDebugMode"])()
}); //# sourceMappingURL=Renderer.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$correlatedObjects": (()=>$correlatedObjects),
    "$onUpdate": (()=>$onUpdate),
    "$sourceObject": (()=>$sourceObject),
    "ThreeDOMElement": (()=>ThreeDOMElement)
});
const $correlatedObjects = Symbol('correlatedObjects');
const $sourceObject = Symbol('sourceObject');
const $onUpdate = Symbol('onUpdate');
class ThreeDOMElement {
    constructor(onUpdate, element, correlatedObjects = null){
        this[$onUpdate] = onUpdate;
        this[$sourceObject] = element;
        this[$correlatedObjects] = correlatedObjects;
    }
} //# sourceMappingURL=three-dom-element.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/image.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$applyTexture": (()=>$applyTexture),
    "$threeTexture": (()=>$threeTexture),
    "Image": (()=>Image)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Renderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
;
;
;
;
const quadMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]();
const quad = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"](2, 2);
let adhocNum = 0;
const $threeTexture = Symbol('threeTexture');
const $applyTexture = Symbol('applyTexture');
class Image extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThreeDOMElement"] {
    get [$threeTexture]() {
        var _a;
        console.assert(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]] != null && this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]].size > 0, 'Image correlated object is undefined');
        return (_a = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]) === null || _a === void 0 ? void 0 : _a.values().next().value;
    }
    constructor(onUpdate, texture, gltfImage){
        gltfImage = gltfImage !== null && gltfImage !== void 0 ? gltfImage : {
            name: texture && texture.image && texture.image.src ? texture.image.src.split('/').pop() : 'adhoc_image',
            uri: texture && texture.image && texture.image.src ? texture.image.src : 'adhoc_image' + adhocNum++
        };
        super(onUpdate, gltfImage, new Set(texture ? [
            texture
        ] : []));
    }
    get name() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name || '';
    }
    get uri() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].uri;
    }
    get bufferView() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].bufferView;
    }
    get type() {
        return this.uri != null ? 'external' : 'embedded';
    }
    set name(name) {
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name = name;
    }
    async createThumbnail(width, height) {
        const scene = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"]();
        quadMaterial.map = this[$threeTexture];
        const mesh = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](quad, quadMaterial);
        scene.add(mesh);
        const camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"](-1, 1, 1, -1, 0, 1);
        const { threeRenderer } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"].singleton;
        const renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height);
        threeRenderer.setRenderTarget(renderTarget);
        threeRenderer.render(scene, camera);
        threeRenderer.setRenderTarget(null);
        const buffer = new Uint8Array(width * height * 4);
        threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blobCanvas"].width = width;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blobCanvas"].height = height;
        const blobContext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blobCanvas"].getContext('2d');
        const imageData = blobContext.createImageData(width, height);
        imageData.data.set(buffer);
        blobContext.putImageData(imageData, 0, 0);
        return new Promise(async (resolve, reject)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blobCanvas"].toBlob((blob)=>{
                if (!blob) {
                    return reject('Failed to capture thumbnail.');
                }
                resolve(URL.createObjectURL(blob));
            }, 'image/png');
        });
    }
} //# sourceMappingURL=image.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/gltf-2.0.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Filter": (()=>Filter),
    "Wrap": (()=>Wrap)
});
var Filter;
(function(Filter) {
    Filter[Filter["Nearest"] = 9728] = "Nearest";
    Filter[Filter["Linear"] = 9729] = "Linear";
    Filter[Filter["NearestMipmapNearest"] = 9984] = "NearestMipmapNearest";
    Filter[Filter["LinearMipmapNearest"] = 9985] = "LinearMipmapNearest";
    Filter[Filter["NearestMipmapLinear"] = 9986] = "NearestMipmapLinear";
    Filter[Filter["LinearMipmapLinear"] = 9987] = "LinearMipmapLinear";
})(Filter || (Filter = {}));
var Wrap;
(function(Wrap) {
    Wrap[Wrap["ClampToEdge"] = 33071] = "ClampToEdge";
    Wrap[Wrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
    Wrap[Wrap["Repeat"] = 10497] = "Repeat";
})(Wrap || (Wrap = {})); //# sourceMappingURL=gltf-2.0.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "Sampler": (()=>Sampler)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/gltf-2.0.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
;
;
const isMinFilter = (()=>{
    const minFilterValues = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].Nearest,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].Linear,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].NearestMipmapNearest,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].LinearMipmapLinear,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].NearestMipmapLinear,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].LinearMipmapLinear
    ];
    return (value)=>minFilterValues.indexOf(value) > -1;
})();
const isMagFilter = (()=>{
    const magFilterValues = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].Nearest,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].Linear
    ];
    return (value)=>magFilterValues.indexOf(value) > -1;
})();
const isWrapMode = (()=>{
    const wrapModes = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Wrap"].ClampToEdge,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Wrap"].MirroredRepeat,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Wrap"].Repeat
    ];
    return (value)=>wrapModes.indexOf(value) > -1;
})();
const isValidSamplerValue = (property, value)=>{
    switch(property){
        case 'minFilter':
            return isMinFilter(value);
        case 'magFilter':
            return isMagFilter(value);
        case 'wrapS':
        case 'wrapT':
            return isWrapMode(value);
        default:
            throw new Error(`Cannot configure property "${property}" on Sampler`);
    }
};
const $threeTextures = Symbol('threeTextures');
const $setProperty = Symbol('setProperty');
const $sourceSampler = Symbol('sourceSampler');
class Sampler extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThreeDOMElement"] {
    get [$threeTextures]() {
        console.assert(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]] != null && this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]].size > 0, 'Sampler correlated object is undefined');
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]];
    }
    get [$sourceSampler]() {
        console.assert(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]] != null, 'Sampler source is undefined');
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
    }
    constructor(onUpdate, texture, gltfSampler){
        gltfSampler = gltfSampler !== null && gltfSampler !== void 0 ? gltfSampler : {};
        // These defaults represent a convergence of glTF defaults for wrap mode and
        // Three.js defaults for filters. Per glTF 2.0 spec, a renderer may choose
        // its own defaults for filters.
        // @see https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-sampler
        // @see https://threejs.org/docs/#api/en/textures/Texture
        if (gltfSampler.minFilter == null) {
            gltfSampler.minFilter = texture ? texture.minFilter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].LinearMipmapLinear;
        }
        if (gltfSampler.magFilter == null) {
            gltfSampler.magFilter = texture ? texture.magFilter : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Filter"].Linear;
        }
        if (gltfSampler.wrapS == null) {
            gltfSampler.wrapS = texture ? texture.wrapS : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Wrap"].Repeat;
        }
        if (gltfSampler.wrapT == null) {
            gltfSampler.wrapT = texture ? texture.wrapT : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$gltf$2d$2$2e$0$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Wrap"].Repeat;
        }
        super(onUpdate, gltfSampler, new Set(texture ? [
            texture
        ] : []));
    }
    get name() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name || '';
    }
    get minFilter() {
        return this[$sourceSampler].minFilter;
    }
    get magFilter() {
        return this[$sourceSampler].magFilter;
    }
    get wrapS() {
        return this[$sourceSampler].wrapS;
    }
    get wrapT() {
        return this[$sourceSampler].wrapT;
    }
    setMinFilter(filter) {
        this[$setProperty]('minFilter', filter);
    }
    setMagFilter(filter) {
        this[$setProperty]('magFilter', filter);
    }
    setWrapS(mode) {
        this[$setProperty]('wrapS', mode);
    }
    setWrapT(mode) {
        this[$setProperty]('wrapT', mode);
    }
    [$setProperty](property, value) {
        const sampler = this[$sourceSampler];
        if (sampler != null) {
            if (isValidSamplerValue(property, value)) {
                sampler[property] = value;
                for (const texture of this[$threeTextures]){
                    texture[property] = value;
                    texture.needsUpdate = true;
                }
            }
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
        }
    }
} //# sourceMappingURL=sampler.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "Texture": (()=>Texture)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$image$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/image.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/sampler.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
;
;
;
const $image = Symbol('image');
const $sampler = Symbol('sampler');
class Texture extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThreeDOMElement"] {
    constructor(onUpdate, threeTexture, gltfTexture = null, gltfSampler = null, gltfImage = null){
        super(onUpdate, gltfTexture ? gltfTexture : {}, new Set(threeTexture ? [
            threeTexture
        ] : []));
        this[$sampler] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$sampler$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sampler"](onUpdate, threeTexture, gltfSampler);
        this[$image] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$image$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Image"](onUpdate, threeTexture, gltfImage);
    }
    get name() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name || '';
    }
    set name(name) {
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name = name;
    }
    get sampler() {
        return this[$sampler];
    }
    get source() {
        return this[$image];
    }
} //# sourceMappingURL=texture.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$materials": (()=>$materials),
    "$usage": (()=>$usage),
    "TextureInfo": (()=>TextureInfo),
    "TextureUsage": (()=>TextureUsage)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$image$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/image.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture.js [app-client] (ecmascript)");
var _a, _b;
;
;
;
const $texture = Symbol('texture');
const $transform = Symbol('transform');
const $materials = Symbol('materials');
const $usage = Symbol('usage');
var TextureUsage;
(function(TextureUsage) {
    TextureUsage[TextureUsage["Base"] = 0] = "Base";
    TextureUsage[TextureUsage["MetallicRoughness"] = 1] = "MetallicRoughness";
    TextureUsage[TextureUsage["Normal"] = 2] = "Normal";
    TextureUsage[TextureUsage["Occlusion"] = 3] = "Occlusion";
    TextureUsage[TextureUsage["Emissive"] = 4] = "Emissive";
})(TextureUsage || (TextureUsage = {}));
class TextureInfo {
    constructor(onUpdate, usage, threeTexture, material, gltf, gltfTextureInfo){
        this[_a] = null;
        this[_b] = {
            rotation: 0,
            scale: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](1, 1),
            offset: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"](0, 0)
        };
        // Creates image, sampler, and texture if valid texture info is provided.
        if (gltfTextureInfo && threeTexture) {
            const gltfTexture = gltf.textures ? gltf.textures[gltfTextureInfo.index] : null;
            const sampler = gltfTexture ? gltf.samplers ? gltf.samplers[gltfTexture.sampler] : null : null;
            const image = gltfTexture ? gltf.images ? gltf.images[gltfTexture.source] : null : null;
            this[$transform].rotation = threeTexture.rotation;
            this[$transform].scale.copy(threeTexture.repeat);
            this[$transform].offset.copy(threeTexture.offset);
            this[$texture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](onUpdate, threeTexture, gltfTexture, sampler, image);
        }
        this.onUpdate = onUpdate;
        this[$materials] = material;
        this[$usage] = usage;
    }
    get texture() {
        return this[$texture];
    }
    setTexture(texture) {
        const threeTexture = texture != null ? texture.source[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$image$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$threeTexture"]] : null;
        let encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sRGBEncoding"];
        this[$texture] = texture;
        if (this[$materials]) {
            for (const material of this[$materials]){
                switch(this[$usage]){
                    case TextureUsage.Base:
                        material.map = threeTexture;
                        break;
                    case TextureUsage.MetallicRoughness:
                        encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearEncoding"];
                        material.metalnessMap = threeTexture;
                        material.roughnessMap = threeTexture;
                        break;
                    case TextureUsage.Normal:
                        encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearEncoding"];
                        material.normalMap = threeTexture;
                        break;
                    case TextureUsage.Occlusion:
                        encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LinearEncoding"];
                        material.aoMap = threeTexture;
                        break;
                    case TextureUsage.Emissive:
                        material.emissiveMap = threeTexture;
                        break;
                    default:
                }
                material.needsUpdate = true;
            }
        }
        if (threeTexture) {
            // Updates the encoding for the texture, affects all references.
            threeTexture.encoding = encoding;
            threeTexture.rotation = this[$transform].rotation;
            threeTexture.repeat = this[$transform].scale;
            threeTexture.offset = this[$transform].offset;
        }
        this.onUpdate();
    }
}
_a = $texture, _b = $transform; //# sourceMappingURL=texture-info.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/pbr-metallic-roughness.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "PBRMetallicRoughness": (()=>PBRMetallicRoughness)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
;
;
;
const $threeMaterials = Symbol('threeMaterials');
const $baseColorTexture = Symbol('baseColorTexture');
const $metallicRoughnessTexture = Symbol('metallicRoughnessTexture');
class PBRMetallicRoughness extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThreeDOMElement"] {
    constructor(onUpdate, gltf, pbrMetallicRoughness, correlatedMaterials){
        super(onUpdate, pbrMetallicRoughness, correlatedMaterials);
        // Assign glTF default values
        if (pbrMetallicRoughness.baseColorFactor == null) {
            pbrMetallicRoughness.baseColorFactor = [
                1,
                1,
                1,
                1
            ];
        }
        if (pbrMetallicRoughness.roughnessFactor == null) {
            pbrMetallicRoughness.roughnessFactor = 1;
        }
        if (pbrMetallicRoughness.metallicFactor == null) {
            pbrMetallicRoughness.metallicFactor = 1;
        }
        const { baseColorTexture: gltfBaseColorTexture, metallicRoughnessTexture: gltfMetallicRoughnessTexture } = pbrMetallicRoughness;
        const { map, metalnessMap } = correlatedMaterials.values().next().value;
        this[$baseColorTexture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureInfo"](onUpdate, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureUsage"].Base, map, correlatedMaterials, gltf, gltfBaseColorTexture ? gltfBaseColorTexture : null);
        this[$metallicRoughnessTexture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureInfo"](onUpdate, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureUsage"].MetallicRoughness, metalnessMap, correlatedMaterials, gltf, gltfMetallicRoughnessTexture ? gltfMetallicRoughnessTexture : null);
    }
    get [$threeMaterials]() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]];
    }
    get baseColorFactor() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].baseColorFactor;
    }
    get metallicFactor() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].metallicFactor;
    }
    get roughnessFactor() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].roughnessFactor;
    }
    get baseColorTexture() {
        return this[$baseColorTexture];
    }
    get metallicRoughnessTexture() {
        return this[$metallicRoughnessTexture];
    }
    setBaseColorFactor(rgba) {
        const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        if (rgba instanceof Array) {
            color.fromArray(rgba);
        } else {
            color.set(rgba).convertSRGBToLinear();
        }
        for (const material of this[$threeMaterials]){
            material.color.set(color);
            if (rgba instanceof Array) {
                material.opacity = rgba[3];
            } else {
                rgba = [
                    0,
                    0,
                    0,
                    material.opacity
                ];
                color.toArray(rgba);
            }
        }
        const pbrMetallicRoughness = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        pbrMetallicRoughness.baseColorFactor = rgba;
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    setMetallicFactor(value) {
        for (const material of this[$threeMaterials]){
            material.metalness = value;
        }
        const pbrMetallicRoughness = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        pbrMetallicRoughness.metallicFactor = value;
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    setRoughnessFactor(value) {
        for (const material of this[$threeMaterials]){
            material.roughness = value;
        }
        const pbrMetallicRoughness = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        pbrMetallicRoughness.roughnessFactor = value;
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
} //# sourceMappingURL=pbr-metallic-roughness.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/material.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$ensureMaterialIsLoaded": (()=>$ensureMaterialIsLoaded),
    "$getLoadedMaterial": (()=>$getLoadedMaterial),
    "$gltfIndex": (()=>$gltfIndex),
    "$lazyLoadGLTFInfo": (()=>$lazyLoadGLTFInfo),
    "$setActive": (()=>$setActive),
    "$variantIndices": (()=>$variantIndices),
    "$variantSet": (()=>$variantSet),
    "Material": (()=>Material)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$pbr$2d$metallic$2d$roughness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/pbr-metallic-roughness.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture-info.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
var _a;
;
;
;
;
const $pbrMetallicRoughness = Symbol('pbrMetallicRoughness');
const $normalTexture = Symbol('normalTexture');
const $occlusionTexture = Symbol('occlusionTexture');
const $emissiveTexture = Symbol('emissiveTexture');
const $backingThreeMaterial = Symbol('backingThreeMaterial');
const $applyAlphaCutoff = Symbol('applyAlphaCutoff');
const $lazyLoadGLTFInfo = Symbol('lazyLoadGLTFInfo');
const $initialize = Symbol('initialize');
const $getLoadedMaterial = Symbol('getLoadedMaterial');
const $ensureMaterialIsLoaded = Symbol('ensureMaterialIsLoaded');
const $gltfIndex = Symbol('gltfIndex');
const $setActive = Symbol('setActive');
const $variantIndices = Symbol('variantIndices');
const $isActive = Symbol('isActive');
const $variantSet = Symbol('variantSet');
const $modelVariants = Symbol('modelVariants');
class Material extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ThreeDOMElement"] {
    constructor(onUpdate, gltf, gltfMaterial, gltfIndex, isActive, modelVariants, correlatedMaterials, lazyLoadInfo = undefined){
        super(onUpdate, gltfMaterial, correlatedMaterials);
        this[_a] = new Set();
        this[$gltfIndex] = gltfIndex;
        this[$isActive] = isActive;
        this[$modelVariants] = modelVariants;
        if (lazyLoadInfo == null) {
            this[$initialize](gltf);
        } else {
            this[$lazyLoadGLTFInfo] = lazyLoadInfo;
        }
    }
    get [(_a = $variantSet, $backingThreeMaterial)]() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]].values().next().value;
    }
    [$initialize](gltf) {
        const onUpdate = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]];
        const gltfMaterial = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        const correlatedMaterials = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]];
        if (gltfMaterial.extensions && gltfMaterial.extensions['KHR_materials_pbrSpecularGlossiness']) {
            console.warn(`Material ${gltfMaterial.name} uses a deprecated extension
          "KHR_materials_pbrSpecularGlossiness", please use
          "pbrMetallicRoughness" instead. Specular Glossiness materials are
          currently supported for rendering, but not for our scene-graph API,
          nor for auto-generation of USDZ for Quick Look.`);
        }
        if (gltfMaterial.pbrMetallicRoughness == null) {
            gltfMaterial.pbrMetallicRoughness = {};
        }
        this[$pbrMetallicRoughness] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$pbr$2d$metallic$2d$roughness$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PBRMetallicRoughness"](onUpdate, gltf, gltfMaterial.pbrMetallicRoughness, correlatedMaterials);
        if (gltfMaterial.emissiveFactor == null) {
            gltfMaterial.emissiveFactor = [
                0,
                0,
                0
            ];
        }
        if (gltfMaterial.doubleSided == null) {
            gltfMaterial.doubleSided = false;
        }
        if (gltfMaterial.alphaMode == null) {
            gltfMaterial.alphaMode = 'OPAQUE';
        }
        if (gltfMaterial.alphaCutoff == null) {
            gltfMaterial.alphaCutoff = 0.5;
        }
        const { normalTexture: gltfNormalTexture, occlusionTexture: gltfOcclusionTexture, emissiveTexture: gltfEmissiveTexture } = gltfMaterial;
        const { normalMap, aoMap, emissiveMap } = correlatedMaterials.values().next().value;
        this[$normalTexture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureInfo"](onUpdate, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureUsage"].Normal, normalMap, correlatedMaterials, gltf, gltfNormalTexture ? gltfNormalTexture : null);
        this[$occlusionTexture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureInfo"](onUpdate, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureUsage"].Occlusion, aoMap, correlatedMaterials, gltf, gltfOcclusionTexture ? gltfOcclusionTexture : null);
        this[$emissiveTexture] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureInfo"](onUpdate, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2d$info$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureUsage"].Emissive, emissiveMap, correlatedMaterials, gltf, gltfEmissiveTexture ? gltfEmissiveTexture : null);
    }
    async [$getLoadedMaterial]() {
        if (this[$lazyLoadGLTFInfo] != null) {
            const { set, material } = await this[$lazyLoadGLTFInfo].doLazyLoad();
            // Fills in the missing data.
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]] = set;
            this[$initialize](this[$lazyLoadGLTFInfo].gltf);
            // Releases lazy load info.
            this[$lazyLoadGLTFInfo] = undefined;
            // Redefines the method as a noop method.
            this.ensureLoaded = async ()=>{};
            return material;
        }
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]].values().next().value;
    }
    [$ensureMaterialIsLoaded]() {
        if (this[$lazyLoadGLTFInfo] == null) {
            return;
        }
        throw new Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`);
    }
    async ensureLoaded() {
        await this[$getLoadedMaterial]();
    }
    get isLoaded() {
        return this[$lazyLoadGLTFInfo] == null;
    }
    get isActive() {
        return this[$isActive];
    }
    [$setActive](isActive) {
        this[$isActive] = isActive;
    }
    get name() {
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].name;
    }
    set name(name) {
        const sourceMaterial = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        if (sourceMaterial != null) {
            sourceMaterial.name = name;
        }
        if (this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]] != null) {
            for (const threeMaterial of this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]){
                threeMaterial.name = name;
            }
        }
    }
    get pbrMetallicRoughness() {
        this[$ensureMaterialIsLoaded]();
        return this[$pbrMetallicRoughness];
    }
    get normalTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$normalTexture];
    }
    get occlusionTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$occlusionTexture];
    }
    get emissiveTexture() {
        this[$ensureMaterialIsLoaded]();
        return this[$emissiveTexture];
    }
    get emissiveFactor() {
        this[$ensureMaterialIsLoaded]();
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].emissiveFactor;
    }
    get index() {
        return this[$gltfIndex];
    }
    [$variantIndices]() {
        return this[$variantSet];
    }
    hasVariant(name) {
        const variantData = this[$modelVariants].get(name);
        return variantData != null && this[$variantSet].has(variantData.index);
    }
    setEmissiveFactor(rgb) {
        this[$ensureMaterialIsLoaded]();
        const color = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Color"]();
        if (rgb instanceof Array) {
            color.fromArray(rgb);
        } else {
            color.set(rgb).convertSRGBToLinear();
        }
        for (const material of this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]){
            material.emissive.set(color);
        }
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].emissiveFactor = color.toArray();
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    [$applyAlphaCutoff]() {
        this[$ensureMaterialIsLoaded]();
        const gltfMaterial = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]];
        for (const material of this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]){
            if (this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].alphaMode === 'MASK') {
                material.alphaTest = gltfMaterial.alphaCutoff;
            } else {
                material.alphaTest = undefined;
            }
            material.needsUpdate = true;
        }
    }
    setAlphaCutoff(cutoff) {
        this[$ensureMaterialIsLoaded]();
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].alphaCutoff = cutoff;
        this[$applyAlphaCutoff]();
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    getAlphaCutoff() {
        this[$ensureMaterialIsLoaded]();
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].alphaCutoff;
    }
    setDoubleSided(doubleSided) {
        this[$ensureMaterialIsLoaded]();
        for (const material of this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]){
            // When double-sided is disabled gltf spec dictates that Back-Face culling
            // must be disabled, in three.js parlance that would mean FrontSide
            // rendering only.
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#double-sided
            material.side = doubleSided ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DoubleSide"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FrontSide"];
            material.needsUpdate = true;
        }
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].doubleSided = doubleSided;
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    getDoubleSided() {
        this[$ensureMaterialIsLoaded]();
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].doubleSided;
    }
    setAlphaMode(alphaMode) {
        this[$ensureMaterialIsLoaded]();
        const enableTransparency = (material, enabled)=>{
            material.transparent = enabled;
            material.depthWrite = !enabled;
        };
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].alphaMode = alphaMode;
        for (const material of this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]]){
            enableTransparency(material, alphaMode === 'BLEND');
            this[$applyAlphaCutoff]();
            material.needsUpdate = true;
        }
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onUpdate"]]();
    }
    getAlphaMode() {
        this[$ensureMaterialIsLoaded]();
        return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]].alphaMode;
    }
} //# sourceMappingURL=material.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/nodes/primitive-node.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "$activeMaterialIdx": (()=>$activeMaterialIdx),
    "$children": (()=>$children),
    "$initialMaterialIdx": (()=>$initialMaterialIdx),
    "$loadVariant": (()=>$loadVariant),
    "$prepareVariantsForExport": (()=>$prepareVariantsForExport),
    "$primitives": (()=>$primitives),
    "$switchVariant": (()=>$switchVariant),
    "Node": (()=>Node),
    "PrimitiveNode": (()=>PrimitiveNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
var _a, _b, _c, _d, _e;
;
;
const $materials = Symbol('materials');
const $variantToMaterialMap = Symbol('variantToMaterialMap');
const $modelVariants = Symbol('modelVariants');
const $mesh = Symbol('mesh');
const $primitives = Symbol('primitives');
const $loadVariant = Symbol('loadVariant');
const $prepareVariantsForExport = Symbol('prepareVariantsForExport');
const $switchVariant = Symbol('switchVariant');
const $children = Symbol('children');
const $initialMaterialIdx = Symbol('initialMaterialIdx');
const $activeMaterialIdx = Symbol('activeMaterialIdx');
class Node {
    constructor(name){
        this.name = '';
        this[_a] = new Array();
        this.name = name;
    }
}
_a = $children;
class PrimitiveNode extends Node {
    constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph){
        super(mesh.name);
        // Maps glTF material index number to a material that this primitive supports.
        this[_b] = new Map();
        // Maps variant index to material.
        this[_c] = new Map();
        this[_d] = 0;
        this[_e] = 0;
        this[$mesh] = mesh;
        const { gltf, threeGLTF, threeObjectMap } = correlatedSceneGraph;
        this[$modelVariants] = modelVariants;
        this.mesh.userData.variantData = modelVariants;
        // Captures the primitive's initial material.
        const materialMappings = threeObjectMap.get(mesh.material);
        if (materialMappings.materials != null) {
            this[$initialMaterialIdx] = this[$activeMaterialIdx] = materialMappings.materials;
        } else {
            console.error(`Primitive (${mesh.name}) missing initial material reference.`);
        }
        // Gets the mesh index from the node.
        const associations = mesh.userData.associations || {};
        if (associations.meshes == null) {
            console.error('Mesh is missing primitive index association');
            return;
        }
        // The gltf mesh array to sample from.
        const meshElementArray = gltf['meshes'] || [];
        // List of primitives under the mesh.
        const gltfPrimitives = meshElementArray[associations.meshes].primitives || [];
        const gltfPrimitive = gltfPrimitives[associations.primitives];
        if (gltfPrimitive == null) {
            console.error('Mesh primitive definition is missing.');
            return;
        }
        // Maps the gltfPrimitive default to a material.
        if (gltfPrimitive.material != null) {
            this[$materials].set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);
        } else {
            const defaultIdx = mvMaterials.findIndex((mat)=>{
                return mat.name === 'Default';
            });
            if (defaultIdx >= 0) {
                this[$materials].set(defaultIdx, mvMaterials[defaultIdx]);
            } else {
                console.warn('gltfPrimitive has no material!');
            }
        }
        if (gltfPrimitive.extensions && gltfPrimitive.extensions['KHR_materials_variants']) {
            const variantsExtension = gltfPrimitive.extensions['KHR_materials_variants'];
            const extensions = threeGLTF.parser.json.extensions;
            const variantNames = extensions['KHR_materials_variants'].variants;
            // Provides definition now that we know there are variants to
            // support.
            for (const mapping of variantsExtension.mappings){
                const mvMaterial = mvMaterials[mapping.material];
                // Maps variant indices to Materials.
                this[$materials].set(mapping.material, mvMaterial);
                for (const variant of mapping.variants){
                    const { name } = variantNames[variant];
                    this[$variantToMaterialMap].set(variant, mvMaterial);
                    // Provides variant info for material self lookup.
                    mvMaterial[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$variantIndices"]]().add(variant);
                    // Updates the models variant data.
                    if (!modelVariants.has(name)) {
                        modelVariants.set(name, {
                            name,
                            index: variant
                        });
                    }
                }
            }
        }
    }
    get mesh() {
        return this[$mesh];
    }
    async setActiveMaterial(material) {
        const mvMaterial = this[$materials].get(material);
        if (mvMaterial != null) {
            this.mesh.material = await mvMaterial[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getLoadedMaterial"]]();
            this[$activeMaterialIdx] = material;
        }
        return this.mesh.material;
    }
    getActiveMaterial() {
        return this[$materials].get(this[$activeMaterialIdx]);
    }
    getMaterial(index) {
        return this[$materials].get(index);
    }
    async enableVariant(name) {
        if (name == null) {
            return this.setActiveMaterial(this[$initialMaterialIdx]);
        }
        if (this[$variantToMaterialMap] != null && this[$modelVariants].has(name)) {
            const modelVariants = this[$modelVariants].get(name);
            return this.enableVariantHelper(modelVariants.index);
        }
        return null;
    }
    async enableVariantHelper(index) {
        if (this[$variantToMaterialMap] != null && index != null) {
            const material = this[$variantToMaterialMap].get(index);
            if (material != null) {
                return this.setActiveMaterial(material.index);
            }
        }
        return null;
    }
    async instantiateVariants() {
        if (this[$variantToMaterialMap] == null) {
            return;
        }
        for (const index of this[$variantToMaterialMap].keys()){
            const variantMaterial = this.mesh.userData.variantMaterials.get(index);
            if (variantMaterial.material != null) {
                continue;
            }
            const threeMaterial = await this.enableVariantHelper(index);
            if (threeMaterial != null) {
                variantMaterial.material = threeMaterial;
            }
        }
    }
    get variantInfo() {
        return this[$variantToMaterialMap];
    }
    addVariant(materialVariant, variantName) {
        if (!this.ensureVariantIsUnused(variantName)) {
            return false;
        }
        // Adds the variant to the model variants if needed.
        if (!this[$modelVariants].has(variantName)) {
            this[$modelVariants].set(variantName, {
                name: variantName,
                index: this[$modelVariants].size
            });
        }
        const modelVariantData = this[$modelVariants].get(variantName);
        const variantIndex = modelVariantData.index;
        // Updates materials mapped to the variant.
        materialVariant[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$variantIndices"]]().add(variantIndex);
        // Updates internal mappings.
        this[$variantToMaterialMap].set(variantIndex, materialVariant);
        this[$materials].set(materialVariant.index, materialVariant);
        this.updateVariantUserData(variantIndex, materialVariant);
        return true;
    }
    deleteVariant(variantIndex) {
        if (this.variantInfo.has(variantIndex)) {
            this.variantInfo.delete(variantIndex);
            const userDataMap = this.mesh.userData.variantMaterials;
            if (userDataMap != null) {
                userDataMap.delete(variantIndex);
            }
        }
    }
    updateVariantUserData(variantIndex, materialVariant) {
        // Adds variants name to material variants set.
        materialVariant[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$variantIndices"]]().add(variantIndex);
        this.mesh.userData.variantData = this[$modelVariants];
        // Updates import data (see VariantMaterialLoaderPlugin.ts).
        this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map();
        const map = this.mesh.userData.variantMaterials;
        map.set(variantIndex, {
            material: materialVariant[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]].values().next().value,
            gltfMaterialIndex: materialVariant.index
        });
    }
    ensureVariantIsUnused(variantName) {
        const modelVariants = this[$modelVariants].get(variantName);
        if (modelVariants != null && this.variantInfo.has(modelVariants.index)) {
            console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`);
            return false;
        }
        return true;
    }
}
_b = $materials, _c = $variantToMaterialMap, _d = $initialMaterialIdx, _e = $activeMaterialIdx; //# sourceMappingURL=primitive-node.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph/model.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$availableVariants": (()=>$availableVariants),
    "$correlatedSceneGraph": (()=>$correlatedSceneGraph),
    "$loadVariant": (()=>$loadVariant),
    "$materialFromPoint": (()=>$materialFromPoint),
    "$materials": (()=>$materials),
    "$materialsFromPoint": (()=>$materialsFromPoint),
    "$prepareVariantsForExport": (()=>$prepareVariantsForExport),
    "$primitivesList": (()=>$primitivesList),
    "$switchVariant": (()=>$switchVariant),
    "$threeScene": (()=>$threeScene),
    "$variantData": (()=>$variantData),
    "LazyLoader": (()=>LazyLoader),
    "Model": (()=>Model)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/material.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$nodes$2f$primitive$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/nodes/primitive-node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/three-dom-element.js [app-client] (ecmascript)");
var _a, _b, _c, _d, _e, _f;
;
;
;
;
const $materials = Symbol('materials');
const $hierarchy = Symbol('hierarchy');
const $roots = Symbol('roots');
const $primitivesList = Symbol('primitives');
const $loadVariant = Symbol('loadVariant');
const $correlatedSceneGraph = Symbol('correlatedSceneGraph');
const $prepareVariantsForExport = Symbol('prepareVariantsForExport');
const $switchVariant = Symbol('switchVariant');
const $threeScene = Symbol('threeScene');
const $materialsFromPoint = Symbol('materialsFromPoint');
const $materialFromPoint = Symbol('materialFromPoint');
const $variantData = Symbol('variantData');
const $availableVariants = Symbol('availableVariants');
const $modelOnUpdate = Symbol('modelOnUpdate');
const $cloneMaterial = Symbol('cloneMaterial');
class LazyLoader {
    constructor(gltf, gltfElementMap, mapKey, doLazyLoad){
        this.gltf = gltf;
        this.gltfElementMap = gltfElementMap;
        this.mapKey = mapKey;
        this.doLazyLoad = doLazyLoad;
    }
}
class Model {
    constructor(correlatedSceneGraph, onUpdate = ()=>{}){
        this[_a] = new Array();
        this[_b] = new Array();
        this[_c] = new Array();
        this[_d] = new Array();
        this[_e] = ()=>{};
        this[_f] = new Map();
        this[$modelOnUpdate] = onUpdate;
        this[$correlatedSceneGraph] = correlatedSceneGraph;
        const { gltf, threeGLTF, gltfElementMap } = correlatedSceneGraph;
        this[$threeScene] = threeGLTF.scene;
        for (const [i, material] of gltf.materials.entries()){
            const correlatedMaterial = gltfElementMap.get(material);
            if (correlatedMaterial != null) {
                this[$materials].push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"](onUpdate, gltf, material, i, true, this[$variantData], correlatedMaterial));
            } else {
                const elementArray = gltf['materials'] || [];
                const gltfMaterialDef = elementArray[i];
                // Loads the three.js material.
                const capturedMatIndex = i;
                const materialLoadCallback = async ()=>{
                    const threeMaterial = await threeGLTF.parser.getDependency('material', capturedMatIndex);
                    // Adds correlation, maps the variant gltf-def to the
                    // three material set containing the variant material.
                    const threeMaterialSet = new Set();
                    gltfElementMap.set(gltfMaterialDef, threeMaterialSet);
                    threeMaterialSet.add(threeMaterial);
                    return {
                        set: threeMaterialSet,
                        material: threeMaterial
                    };
                };
                // Configures the material for lazy loading.
                this[$materials].push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"](onUpdate, gltf, gltfMaterialDef, i, false, this[$variantData], correlatedMaterial, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));
            }
        }
        // Creates a hierarchy of Nodes. Allows not just for switching which
        // material is applied to a mesh but also exposes a way to provide API
        // for switching materials and general assignment/modification.
        // Prepares for scene iteration.
        const parentMap = new Map();
        const nodeStack = new Array();
        for (const object of threeGLTF.scene.children){
            nodeStack.push(object);
        }
        // Walks the hierarchy and creates a node tree.
        while(nodeStack.length > 0){
            const object = nodeStack.pop();
            let node = null;
            if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"]) {
                node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$nodes$2f$primitive$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrimitiveNode"](object, this.materials, this[$variantData], correlatedSceneGraph);
                this[$primitivesList].push(node);
            } else {
                node = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$nodes$2f$primitive$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Node"](object.name);
            }
            const parent = parentMap.get(object);
            if (parent != null) {
                parent[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$nodes$2f$primitive$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$children"]].push(node);
            } else {
                this[$roots].push(node);
            }
            this[$hierarchy].push(node);
            for (const child of object.children){
                nodeStack.push(child);
                parentMap.set(object, node);
            }
        }
    }
    /**
     * Materials are listed in the order of the GLTF materials array, plus a
     * default material at the end if one is used.
     *
     * TODO(#1003): How do we handle non-active scenes?
     */ get materials() {
        return this[$materials];
    }
    [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {
        const variants = Array.from(this[$variantData].values());
        variants.sort((a, b)=>{
            return a.index - b.index;
        });
        return variants.map((data)=>{
            return data.name;
        });
    }
    getMaterialByName(name) {
        const matches = this[$materials].filter((material)=>{
            return material.name === name;
        });
        if (matches.length > 0) {
            return matches[0];
        }
        return null;
    }
    /**
     * Intersects a ray with the Model and returns a list of materials whose
     * objects were intersected.
     */ [$materialsFromPoint](raycaster) {
        const hits = raycaster.intersectObject(this[$threeScene], true);
        // Map the object hits to primitives and then to the active material of
        // the primitive.
        return hits.map((hit)=>{
            const found = this[$hierarchy].find((node)=>{
                if (node instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$nodes$2f$primitive$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PrimitiveNode"]) {
                    const primitive = node;
                    if (primitive.mesh === hit.object) {
                        return true;
                    }
                }
                return false;
            });
            if (found != null) {
                return found.getActiveMaterial();
            }
            return null;
        });
    }
    /**
     * Intersects a ray with the Model and returns the first material whose
     * object was intersected.
     */ [$materialFromPoint](raycaster) {
        const materials = this[$materialsFromPoint](raycaster);
        if (materials.length > 0) {
            return materials[0];
        }
        return null;
    }
    /**
     * Switches model variant to the variant name provided, or switches to
     * default/initial materials if 'null' is provided.
     */ async [$switchVariant](variantName) {
        for (const primitive of this[$primitivesList]){
            await primitive.enableVariant(variantName);
        }
        for (const material of this.materials){
            material[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$setActive"]](false);
        }
        // Marks the materials that are now in use after the variant switch.
        for (const primitive of this[$primitivesList]){
            this.materials[primitive.getActiveMaterial().index][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$setActive"]](true);
        }
    }
    async [$prepareVariantsForExport]() {
        const promises = new Array();
        for (const primitive of this[$primitivesList]){
            promises.push(primitive.instantiateVariants());
        }
        await Promise.all(promises);
    }
    [$cloneMaterial](index, newMaterialName) {
        const material = this.materials[index];
        if (!material.isLoaded) {
            console.error(`Cloning an unloaded material,
           call 'material.ensureLoaded() before cloning the material.`);
        }
        const threeMaterialSet = material[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$correlatedObjects"]];
        // clones the gltf material data and updates the material name.
        const gltfSourceMaterial = JSON.parse(JSON.stringify(material[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$three$2d$dom$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$sourceObject"]]));
        gltfSourceMaterial.name = newMaterialName;
        // Adds the source material clone to the gltf def.
        const gltf = this[$correlatedSceneGraph].gltf;
        gltf.materials.push(gltfSourceMaterial);
        const clonedSet = new Set();
        for (const [i, threeMaterial] of threeMaterialSet.entries()){
            const clone = threeMaterial.clone();
            clone.name = newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');
            clonedSet.add(clone);
        }
        const clonedMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Material"](this[$modelOnUpdate], this[$correlatedSceneGraph].gltf, gltfSourceMaterial, this[$materials].length, false, this[$variantData], clonedSet);
        this[$materials].push(clonedMaterial);
        return clonedMaterial;
    }
    createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {
        let variantMaterialInstance = null;
        for (const primitive of this[$primitivesList]){
            const variantData = this[$variantData].get(variantName);
            // Skips the primitive if the variant already exists.
            if (variantData != null && primitive.variantInfo.has(variantData.index)) {
                continue;
            }
            // Skips the primitive if the source/original material does not exist.
            if (primitive.getMaterial(originalMaterialIndex) == null) {
                continue;
            }
            if (!this.hasVariant(variantName)) {
                this.createVariant(variantName);
            }
            if (variantMaterialInstance == null) {
                variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName);
            }
            primitive.addVariant(variantMaterialInstance, variantName);
        }
        if (activateVariant && variantMaterialInstance != null) {
            variantMaterialInstance[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$setActive"]](true);
            this.materials[originalMaterialIndex][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$setActive"]](false);
            for (const primitive of this[$primitivesList]){
                primitive.enableVariant(variantName);
            }
        }
        return variantMaterialInstance;
    }
    createVariant(variantName) {
        if (!this[$variantData].has(variantName)) {
            // Adds the name if it's not already in the list.
            this[$variantData].set(variantName, {
                name: variantName,
                index: this[$variantData].size
            });
        } else {
            console.warn(`Variant '${variantName}'' already exists`);
        }
    }
    hasVariant(variantName) {
        return this[$variantData].has(variantName);
    }
    setMaterialToVariant(materialIndex, targetVariantName) {
        if (this[$availableVariants]().find((name)=>name === targetVariantName) == null) {
            console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);
            return;
        }
        if (materialIndex < 0 || materialIndex >= this.materials.length) {
            console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);
            return;
        }
        for (const primitive of this[$primitivesList]){
            const material = primitive.getMaterial(materialIndex);
            // Ensures the material exists on the primitive before setting it to a
            // variant.
            if (material != null) {
                primitive.addVariant(material, targetVariantName);
            }
        }
    }
    updateVariantName(currentName, newName) {
        const variantData = this[$variantData].get(currentName);
        if (variantData == null) {
            return;
        }
        variantData.name = newName;
        this[$variantData].set(newName, variantData);
        this[$variantData].delete(currentName);
    }
    deleteVariant(variantName) {
        const variant = this[$variantData].get(variantName);
        if (variant == null) {
            return;
        }
        for (const material of this.materials){
            if (material.hasVariant(variantName)) {
                material[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$material$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$variantSet"]].delete(variant.index);
            }
        }
        for (const primitive of this[$primitivesList]){
            primitive.deleteVariant(variant.index);
        }
        this[$variantData].delete(variantName);
    }
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/scene-graph.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$currentGLTF": (()=>$currentGLTF),
    "$model": (()=>$model),
    "$originalGltfJson": (()=>$originalGltfJson),
    "SceneGraphMixin": (()=>SceneGraphMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$exporters$2f$GLTFExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/exporters/GLTFExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$VariantMaterialExporterPlugin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/gltf-instance/VariantMaterialExporterPlugin.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/model.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph/texture.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
;
;
;
;
const $currentGLTF = Symbol('currentGLTF');
const $originalGltfJson = Symbol('originalGltfJson');
const $model = Symbol('model');
const $getOnUpdateMethod = Symbol('getOnUpdateMethod');
const $textureLoader = Symbol('textureLoader');
const SceneGraphMixin = (ModelViewerElement)=>{
    var _a, _b, _c, _d;
    class SceneGraphModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this[_a] = undefined;
            this[_b] = null;
            this[_c] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TextureLoader"]();
            this[_d] = null;
            this.variantName = null;
            this.orientation = '0 0 0';
            this.scale = '1 1 1';
        }
        // Scene-graph API:
        /** @export */ get model() {
            return this[$model];
        }
        get availableVariants() {
            return this.model ? this.model[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$availableVariants"]]() : [];
        }
        /**
         * Returns a deep copy of the gltf JSON as loaded. It will not reflect
         * changes to the scene-graph, nor will editing it have any effect.
         */ get originalGltfJson() {
            return this[$originalGltfJson];
        }
        [(_a = $model, _b = $currentGLTF, _c = $textureLoader, _d = $originalGltfJson, $getOnUpdateMethod)]() {
            return ()=>{
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            };
        }
        async createTexture(uri, type = 'image/png') {
            const currentGLTF = this[$currentGLTF];
            const texture = await new Promise((resolve)=>this[$textureLoader].load(uri, resolve));
            if (!currentGLTF || !texture) {
                return null;
            }
            // Applies default settings.
            texture.encoding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sRGBEncoding"];
            texture.wrapS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            texture.wrapT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RepeatWrapping"];
            texture.flipY = false;
            texture.userData.mimeType = type;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$texture$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Texture"](this[$getOnUpdateMethod](), texture);
        }
        async updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('variantName')) {
                const updateVariantProgress = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$progressTracker"]].beginActivity();
                updateVariantProgress(0.1);
                const model = this[$model];
                const { variantName } = this;
                if (model != null) {
                    await model[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$switchVariant"]](variantName);
                    this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
                    this.dispatchEvent(new CustomEvent('variant-applied'));
                }
                updateVariantProgress(1.0);
            }
            if (changedProperties.has('orientation') || changedProperties.has('scale')) {
                if (!this.loaded) {
                    return;
                }
                const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
                scene.applyTransform();
                scene.updateBoundingBox();
                scene.updateShadow();
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.onUpdateScene();
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"]]() {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"]]();
            const { currentGLTF } = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            if (currentGLTF != null) {
                const { correlatedSceneGraph } = currentGLTF;
                if (correlatedSceneGraph != null && currentGLTF !== this[$currentGLTF]) {
                    this[$model] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Model"](correlatedSceneGraph, this[$getOnUpdateMethod]());
                    this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf));
                }
                // KHR_materials_variants extension spec:
                // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants
                if ('variants' in currentGLTF.userData) {
                    this.requestUpdate('variantName');
                }
            }
            this[$currentGLTF] = currentGLTF;
        }
        /** @export */ async exportScene(options) {
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            return new Promise(async (resolve, reject)=>{
                // Defaults
                const opts = {
                    binary: true,
                    onlyVisible: true,
                    maxTextureSize: Infinity,
                    includeCustomExtensions: false,
                    forceIndices: false
                };
                Object.assign(opts, options);
                // Not configurable
                opts.animations = scene.animations;
                opts.truncateDrawRange = true;
                const shadow = scene.shadow;
                let visible = false;
                // Remove shadow from export
                if (shadow != null) {
                    visible = shadow.visible;
                    shadow.visible = false;
                }
                await this[$model][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$prepareVariantsForExport"]]();
                const exporter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$exporters$2f$GLTFExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["GLTFExporter"]().register((writer)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$gltf$2d$instance$2f$VariantMaterialExporterPlugin$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"](writer));
                exporter.parse(scene.model, (gltf)=>{
                    return resolve(new Blob([
                        opts.binary ? gltf : JSON.stringify(gltf)
                    ], {
                        type: opts.binary ? 'application/octet-stream' : 'application/json'
                    }));
                }, ()=>{
                    return reject('glTF export failed');
                }, opts);
                if (shadow != null) {
                    shadow.visible = visible;
                }
            });
        }
        materialFromPoint(pixelX, pixelY) {
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const ndcCoords = scene.getNDC(pixelX, pixelY);
            scene.raycaster.setFromCamera(ndcCoords, scene.getCamera());
            return this[$model][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2f$model$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$materialFromPoint"]](scene.raycaster);
        }
    }
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'variant-name'
        })
    ], SceneGraphModelViewerElement.prototype, "variantName", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'orientation'
        })
    ], SceneGraphModelViewerElement.prototype, "orientation", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'scale'
        })
    ], SceneGraphModelViewerElement.prototype, "scale", void 0);
    return SceneGraphModelViewerElement;
}; //# sourceMappingURL=scene-graph.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ASTWalker": (()=>ASTWalker),
    "ZERO": (()=>ZERO),
    "numberNode": (()=>numberNode),
    "parseExpressions": (()=>parseExpressions)
});
const numberNode = (value, unit)=>({
        type: 'number',
        number: value,
        unit
    });
const parseExpressions = (()=>{
    const cache = {};
    const MAX_PARSE_ITERATIONS = 1000; // Arbitrarily large
    return (inputString)=>{
        const cacheKey = inputString;
        if (cacheKey in cache) {
            return cache[cacheKey];
        }
        const expressions = [];
        let parseIterations = 0;
        while(inputString){
            if (++parseIterations > MAX_PARSE_ITERATIONS) {
                // Avoid a potentially infinite loop due to typos:
                inputString = '';
                break;
            }
            const expressionParseResult = parseExpression(inputString);
            const expression = expressionParseResult.nodes[0];
            if (expression == null || expression.terms.length === 0) {
                break;
            }
            expressions.push(expression);
            inputString = expressionParseResult.remainingInput;
        }
        return cache[cacheKey] = expressions;
    };
})();
/**
 * Parse a single expression. For the purposes of our supported syntax, an
 * expression is the set of semantically meaningful terms that appear before the
 * next comma, or between the parens of a function invocation.
 */ const parseExpression = (()=>{
    const IS_IDENT_RE = /^(\-\-|[a-z\u0240-\uffff])/i;
    const IS_OPERATOR_RE = /^([\*\+\/]|[\-]\s)/i;
    const IS_EXPRESSION_END_RE = /^[\),]/;
    const FUNCTION_ARGUMENTS_FIRST_TOKEN = '(';
    const HEX_FIRST_TOKEN = '#';
    return (inputString)=>{
        const terms = [];
        while(inputString.length){
            inputString = inputString.trim();
            if (IS_EXPRESSION_END_RE.test(inputString)) {
                break;
            } else if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {
                const { nodes, remainingInput } = parseFunctionArguments(inputString);
                inputString = remainingInput;
                terms.push({
                    type: 'function',
                    name: {
                        type: 'ident',
                        value: 'calc'
                    },
                    arguments: nodes
                });
            } else if (IS_IDENT_RE.test(inputString)) {
                const identParseResult = parseIdent(inputString);
                const identNode = identParseResult.nodes[0];
                inputString = identParseResult.remainingInput;
                if (inputString[0] === FUNCTION_ARGUMENTS_FIRST_TOKEN) {
                    const { nodes, remainingInput } = parseFunctionArguments(inputString);
                    terms.push({
                        type: 'function',
                        name: identNode,
                        arguments: nodes
                    });
                    inputString = remainingInput;
                } else {
                    terms.push(identNode);
                }
            } else if (IS_OPERATOR_RE.test(inputString)) {
                // Operators are always a single character, so just pluck them out:
                terms.push({
                    type: 'operator',
                    value: inputString[0]
                });
                inputString = inputString.slice(1);
            } else {
                const { nodes, remainingInput } = inputString[0] === HEX_FIRST_TOKEN ? parseHex(inputString) : parseNumber(inputString);
                // The remaining string may not have had any meaningful content. Exit
                // early if this is the case:
                if (nodes.length === 0) {
                    break;
                }
                terms.push(nodes[0]);
                inputString = remainingInput;
            }
        }
        return {
            nodes: [
                {
                    type: 'expression',
                    terms
                }
            ],
            remainingInput: inputString
        };
    };
})();
/**
 * An ident is something like a function name or the keyword "auto".
 */ const parseIdent = (()=>{
    const NOT_IDENT_RE = /[^a-z0-9_\-\u0240-\uffff]/i;
    return (inputString)=>{
        const match = inputString.match(NOT_IDENT_RE);
        const ident = match == null ? inputString : inputString.substr(0, match.index);
        const remainingInput = match == null ? '' : inputString.substr(match.index);
        return {
            nodes: [
                {
                    type: 'ident',
                    value: ident
                }
            ],
            remainingInput
        };
    };
})();
/**
 * Parses a number. A number value can be expressed with an integer or
 * non-integer syntax, and usually includes a unit (but does not strictly
 * require one for our purposes).
 */ const parseNumber = (()=>{
    // @see https://www.w3.org/TR/css-syntax/#number-token-diagram
    const VALUE_RE = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/;
    const UNIT_RE = /^[a-z%]+/i;
    const ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;
    return (inputString)=>{
        const valueMatch = inputString.match(VALUE_RE);
        const value = valueMatch == null ? '0' : valueMatch[0];
        inputString = value == null ? inputString : inputString.slice(value.length);
        const unitMatch = inputString.match(UNIT_RE);
        let unit = unitMatch != null && unitMatch[0] !== '' ? unitMatch[0] : null;
        const remainingInput = unitMatch == null ? inputString : inputString.slice(unit.length);
        if (unit != null && !ALLOWED_UNITS.test(unit)) {
            unit = null;
        }
        return {
            nodes: [
                {
                    type: 'number',
                    number: parseFloat(value) || 0,
                    unit: unit
                }
            ],
            remainingInput
        };
    };
})();
/**
 * Parses a hexadecimal-encoded color in 3, 6 or 8 digit form.
 */ const parseHex = (()=>{
    // TODO(cdata): right now we don't actually enforce the number of digits
    const HEX_RE = /^[a-f0-9]*/i;
    return (inputString)=>{
        inputString = inputString.slice(1).trim();
        const hexMatch = inputString.match(HEX_RE);
        const nodes = hexMatch == null ? [] : [
            {
                type: 'hex',
                value: hexMatch[0]
            }
        ];
        return {
            nodes,
            remainingInput: hexMatch == null ? inputString : inputString.slice(hexMatch[0].length)
        };
    };
})();
/**
 * Parses arguments passed to a function invocation (e.g., the expressions
 * within a matched set of parens).
 */ const parseFunctionArguments = (inputString)=>{
    const expressionNodes = [];
    // Consume the opening paren
    inputString = inputString.slice(1).trim();
    while(inputString.length){
        const expressionParseResult = parseExpression(inputString);
        expressionNodes.push(expressionParseResult.nodes[0]);
        inputString = expressionParseResult.remainingInput.trim();
        if (inputString[0] === ',') {
            inputString = inputString.slice(1).trim();
        } else if (inputString[0] === ')') {
            // Consume the closing paren and stop parsing
            inputString = inputString.slice(1);
            break;
        }
    }
    return {
        nodes: expressionNodes,
        remainingInput: inputString
    };
};
const $visitedTypes = Symbol('visitedTypes');
class ASTWalker {
    constructor(visitedTypes){
        this[$visitedTypes] = visitedTypes;
    }
    /**
     * Walk the given set of ASTs, and invoke the provided callback for nodes that
     * match the filtered set that the ASTWalker was constructed with.
     */ walk(ast, callback) {
        const remaining = ast.slice();
        while(remaining.length){
            const next = remaining.shift();
            if (this[$visitedTypes].indexOf(next.type) > -1) {
                callback(next);
            }
            switch(next.type){
                case 'expression':
                    remaining.unshift(...next.terms);
                    break;
                case 'function':
                    remaining.unshift(next.name, ...next.arguments);
                    break;
            }
        }
    }
}
const ZERO = Object.freeze({
    type: 'number',
    number: 0,
    unit: null
}); //# sourceMappingURL=parsers.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "degreesToRadians": (()=>degreesToRadians),
    "lengthToBaseMeters": (()=>lengthToBaseMeters),
    "normalizeUnit": (()=>normalizeUnit),
    "radiansToDegrees": (()=>radiansToDegrees)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
;
const degreesToRadians = (numberNode, fallbackRadianValue = 0)=>{
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackRadianValue;
        unit = 'rad';
    } else if (numberNode.unit === 'rad' || numberNode.unit == null) {
        return numberNode;
    }
    const valueIsDegrees = unit === 'deg' && number != null;
    const value = valueIsDegrees ? number : 0;
    const radians = value * Math.PI / 180;
    return {
        type: 'number',
        number: radians,
        unit: 'rad'
    };
};
const radiansToDegrees = (numberNode, fallbackDegreeValue = 0)=>{
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackDegreeValue;
        unit = 'deg';
    } else if (numberNode.unit === 'deg') {
        return numberNode;
    }
    const valueIsRadians = (unit === null || unit === 'rad') && number != null;
    const value = valueIsRadians ? number : 0;
    const degrees = value * 180 / Math.PI;
    return {
        type: 'number',
        number: degrees,
        unit: 'deg'
    };
};
const lengthToBaseMeters = (numberNode, fallbackMeterValue = 0)=>{
    let { number, unit } = numberNode;
    if (!isFinite(number)) {
        number = fallbackMeterValue;
        unit = 'm';
    } else if (numberNode.unit === 'm') {
        return numberNode;
    }
    let scale;
    switch(unit){
        default:
            scale = 1;
            break;
        case 'cm':
            scale = 1 / 100;
            break;
        case 'mm':
            scale = 1 / 1000;
            break;
    }
    const value = scale * number;
    return {
        type: 'number',
        number: value,
        unit: 'm'
    };
};
const normalizeUnit = (()=>{
    const identity = (node)=>node;
    const unitNormalizers = {
        'rad': identity,
        'deg': degreesToRadians,
        'm': identity,
        'mm': lengthToBaseMeters,
        'cm': lengthToBaseMeters
    };
    return (node, fallback = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"])=>{
        if (!isFinite(node.number)) {
            node.number = fallback.number;
            node.unit = fallback.unit;
        }
        const { unit } = node;
        if (unit == null) {
            return node;
        }
        const normalize = unitNormalizers[unit];
        if (normalize == null) {
            return fallback;
        }
        return normalize(node);
    };
})(); //# sourceMappingURL=conversions.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/Hotspot.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "Hotspot": (()=>Hotspot)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$renderers$2f$CSS2DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/renderers/CSS2DRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
;
;
;
;
class Hotspot extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$renderers$2f$CSS2DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSS2DObject"] {
    constructor(config){
        super(document.createElement('div'));
        this.normal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](0, 1, 0);
        this.initialized = false;
        this.referenceCount = 1;
        this.pivot = document.createElement('div');
        this.slot = document.createElement('slot');
        this.element.classList.add('annotation-wrapper');
        this.slot.name = config.name;
        this.element.appendChild(this.pivot);
        this.pivot.appendChild(this.slot);
        this.updatePosition(config.position);
        this.updateNormal(config.normal);
    }
    get facingCamera() {
        return !this.element.classList.contains('hide');
    }
    /**
     * Sets the hotspot to be in the highly visible foreground state.
     */ show() {
        if (!this.facingCamera || !this.initialized) {
            this.updateVisibility(true);
        }
    }
    /**
     * Sets the hotspot to be in the diminished background state.
     */ hide() {
        if (this.facingCamera || !this.initialized) {
            this.updateVisibility(false);
        }
    }
    /**
     * Call this when adding elements to the same slot to keep track.
     */ increment() {
        this.referenceCount++;
    }
    /**
     * Call this when removing elements from the slot; returns true when the slot
     * is unused.
     */ decrement() {
        if (this.referenceCount > 0) {
            --this.referenceCount;
        }
        return this.referenceCount === 0;
    }
    /**
     * Change the position of the hotspot to the input string, in the same format
     * as the data-position attribute.
     */ updatePosition(position) {
        if (position == null) return;
        const positionNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(position)[0].terms;
        for(let i = 0; i < 3; ++i){
            this.position.setComponent(i, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(positionNodes[i]).number);
        }
        this.updateMatrixWorld();
    }
    /**
     * Change the hotspot's normal to the input string, in the same format as the
     * data-normal attribute.
     */ updateNormal(normal) {
        if (normal == null) return;
        const normalNodes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(normal)[0].terms;
        for(let i = 0; i < 3; ++i){
            this.normal.setComponent(i, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(normalNodes[i]).number);
        }
    }
    orient(radians) {
        this.pivot.style.transform = `rotate(${radians}rad)`;
    }
    updateVisibility(show) {
        // NOTE: IE11 doesn't support a second arg for classList.toggle
        if (show) {
            this.element.classList.remove('hide');
        } else {
            this.element.classList.add('hide');
        }
        // NOTE: ShadyDOM doesn't support slot.assignedElements, otherwise we could
        // use that here.
        this.slot.assignedNodes().forEach((node)=>{
            if (node.nodeType !== Node.ELEMENT_NODE) {
                return;
            }
            const element = node;
            // Visibility attribute can be configured per-node in the hotspot:
            const visibilityAttribute = element.dataset.visibilityAttribute;
            if (visibilityAttribute != null) {
                const attributeName = `data-${visibilityAttribute}`;
                // NOTE: IE11 doesn't support toggleAttribute
                if (show) {
                    element.setAttribute(attributeName, '');
                } else {
                    element.removeAttribute(attributeName);
                }
            }
            element.dispatchEvent(new CustomEvent('hotspot-visibility', {
                detail: {
                    visible: show
                }
            }));
        });
        this.initialized = true;
    }
} //# sourceMappingURL=Hotspot.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/ModelUtils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "moveChildren": (()=>moveChildren),
    "reduceVertices": (()=>reduceVertices)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
;
const moveChildren = (from, to)=>{
    while(from.children.length){
        to.add(from.children.shift());
    }
};
const reduceVertices = (model, func, initialValue)=>{
    let value = initialValue;
    const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
    model.traverseVisible((object)=>{
        let i, l;
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== undefined) {
            if (geometry.isGeometry) {
                const vertices = geometry.vertices;
                for(i = 0, l = vertices.length; i < l; i++){
                    vertex.copy(vertices[i]);
                    if (object.isSkinnedMesh) {
                        object.boneTransform(i, vertex);
                    } else {
                        vertex.applyMatrix4(object.matrixWorld);
                    }
                    value = func(value, vertex);
                }
            } else if (geometry.isBufferGeometry) {
                const { position } = geometry.attributes;
                if (position !== undefined) {
                    for(i = 0, l = position.count; i < l; i++){
                        vertex.fromBufferAttribute(position, i);
                        if (object.isSkinnedMesh) {
                            object.boneTransform(i, vertex);
                        } else {
                            vertex.applyMatrix4(object.matrixWorld);
                        }
                        value = func(value, vertex);
                    }
                }
            }
        }
    });
    return value;
}; //# sourceMappingURL=ModelUtils.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/Shadow.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "Shadow": (()=>Shadow)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$HorizontalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$VerticalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/shaders/VerticalBlurShader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$src$2f$math$2f$MathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/src/math/MathUtils.js [app-client] (ecmascript)");
;
;
;
;
// The softness [0, 1] of the shadow is mapped to a resolution between
// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.
const LOG_MAX_RESOLUTION = 9;
const LOG_MIN_RESOLUTION = 6;
// Animated models are not in general contained in their bounding box, as this
// is calculated only for their resting pose. We create a cubic shadow volume
// for animated models sized to their largest bounding box dimension multiplied
// by this scale factor.
const ANIMATION_SCALING = 2;
// Since hard shadows are not lightened by blurring and depth, set a lower
// default intensity to make them more perceptually similar to the intensity of
// the soft shadows.
const DEFAULT_HARD_INTENSITY = 0.3;
class Shadow extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"] {
    constructor(scene, softness, side){
        super();
        this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OrthographicCamera"]();
        // private cameraHelper = new CameraHelper(this.camera);
        this.renderTarget = null;
        this.renderTargetBlur = null;
        this.depthMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshDepthMaterial"]();
        this.horizontalBlurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$HorizontalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HorizontalBlurShader"]);
        this.verticalBlurMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ShaderMaterial"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$shaders$2f$VerticalBlurShader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VerticalBlurShader"]);
        this.intensity = 0;
        this.softness = 1;
        this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"];
        this.size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"];
        this.maxDimension = 0;
        this.isAnimated = false;
        this.needsUpdate = false;
        const { camera } = this;
        camera.rotation.x = Math.PI / 2;
        camera.left = -0.5;
        camera.right = 0.5;
        camera.bottom = -0.5;
        camera.top = 0.5;
        this.add(camera);
        // this.add(this.cameraHelper);
        // this.cameraHelper.updateMatrixWorld = function() {
        //   this.matrixWorld = this.camera.matrixWorld;
        // };
        const plane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PlaneGeometry"]();
        const shadowMaterial = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MeshBasicMaterial"]({
            // color: new Color(1, 0, 0),
            opacity: 1,
            transparent: true,
            side: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BackSide"]
        });
        this.floor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](plane, shadowMaterial);
        this.floor.userData.shadow = true;
        camera.add(this.floor);
        // the plane onto which to blur the texture
        this.blurPlane = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Mesh"](plane);
        this.blurPlane.visible = false;
        camera.add(this.blurPlane);
        scene.target.add(this);
        // like MeshDepthMaterial, but goes from black to transparent
        this.depthMaterial.onBeforeCompile = function(shader) {
            shader.fragmentShader = shader.fragmentShader.replace('gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );', 'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );');
        };
        this.horizontalBlurMaterial.depthTest = false;
        this.verticalBlurMaterial.depthTest = false;
        this.setScene(scene, softness, side);
    }
    /**
     * Update the shadow's size and position for a new scene. Softness is also
     * needed, as this controls the shadow's resolution.
     */ setScene(scene, softness, side) {
        const { boundingBox, size, rotation, position } = this;
        this.isAnimated = scene.animationNames.length > 0;
        this.boundingBox.copy(scene.boundingBox);
        this.size.copy(scene.size);
        this.maxDimension = Math.max(size.x, size.y, size.z) * (this.isAnimated ? ANIMATION_SCALING : 1);
        this.boundingBox.getCenter(position);
        if (side === 'back') {
            const { min, max } = boundingBox;
            [min.y, min.z] = [
                min.z,
                min.y
            ];
            [max.y, max.z] = [
                max.z,
                max.y
            ];
            [size.y, size.z] = [
                size.z,
                size.y
            ];
            rotation.x = Math.PI / 2;
            rotation.y = Math.PI;
        } else {
            rotation.x = 0;
            rotation.y = 0;
        }
        if (this.isAnimated) {
            const minY = boundingBox.min.y;
            const maxY = boundingBox.max.y;
            size.y = this.maxDimension;
            boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-0.5));
            boundingBox.min.y = minY;
            boundingBox.max.y = maxY;
            size.set(this.maxDimension, maxY - minY, this.maxDimension);
        }
        if (side === 'bottom') {
            position.y = boundingBox.min.y;
        } else {
            position.z = boundingBox.min.y;
        }
        this.setSoftness(softness);
    }
    /**
     * Update the shadow's resolution based on softness (between 0 and 1). Should
     * not be called frequently, as this results in reallocation.
     */ setSoftness(softness) {
        this.softness = softness;
        const { size, camera } = this;
        const scaleY = this.isAnimated ? ANIMATION_SCALING : 1;
        const resolution = scaleY * Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));
        this.setMapSize(resolution);
        const softFar = size.y / 2;
        const hardFar = size.y * scaleY;
        camera.near = 0;
        camera.far = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$src$2f$math$2f$MathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lerp"])(hardFar, softFar, softness);
        // we have co-opted opacity to scale the depth to clip
        this.depthMaterial.opacity = 1.0 / softness;
        camera.updateProjectionMatrix();
        // this.cameraHelper.update();
        this.setIntensity(this.intensity);
        this.setOffset(0);
    }
    /**
     * Lower-level version of the above function.
     */ setMapSize(maxMapSize) {
        const { size } = this;
        if (this.isAnimated) {
            maxMapSize *= ANIMATION_SCALING;
        }
        const baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);
        const baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);
        // width of blur filter in pixels (not adjustable)
        const TAP_WIDTH = 10;
        const width = TAP_WIDTH + baseWidth;
        const height = TAP_WIDTH + baseHeight;
        if (this.renderTarget != null && (this.renderTarget.width !== width || this.renderTarget.height !== height)) {
            this.renderTarget.dispose();
            this.renderTarget = null;
            this.renderTargetBlur.dispose();
            this.renderTargetBlur = null;
        }
        if (this.renderTarget == null) {
            const params = {
                format: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RGBAFormat"]
            };
            this.renderTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, params);
            this.renderTargetBlur = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebGLRenderTarget"](width, height, params);
            this.floor.material.map = this.renderTarget.texture;
        }
        // These pads account for the softening radius around the shadow.
        this.camera.scale.set(size.x * (1 + TAP_WIDTH / baseWidth), size.z * (1 + TAP_WIDTH / baseHeight), 1);
        this.needsUpdate = true;
    }
    /**
     * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off
     * shadow rendering if zero.
     */ setIntensity(intensity) {
        this.intensity = intensity;
        if (intensity > 0) {
            this.visible = true;
            this.floor.visible = true;
            this.floor.material.opacity = intensity * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$src$2f$math$2f$MathUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lerp"])(DEFAULT_HARD_INTENSITY, 1, this.softness * this.softness);
        } else {
            this.visible = false;
            this.floor.visible = false;
        }
    }
    getIntensity() {
        return this.intensity;
    }
    /**
     * An offset can be specified to move the
     * shadow vertically relative to the bottom of the scene. Positive is up, so
     * values are generally negative. A small offset keeps our shadow from
     * z-fighting with any baked-in shadow plane.
     */ setOffset(offset) {
        this.floor.position.z = -offset + 0.001 * this.maxDimension;
    }
    render(renderer, scene) {
        // this.cameraHelper.visible = false;
        // force the depthMaterial to everything
        scene.overrideMaterial = this.depthMaterial;
        // set renderer clear alpha
        const initialClearAlpha = renderer.getClearAlpha();
        renderer.setClearAlpha(0);
        this.floor.visible = false;
        // disable XR for offscreen rendering
        const xrEnabled = renderer.xr.enabled;
        renderer.xr.enabled = false;
        // render to the render target to get the depths
        const oldRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.renderTarget);
        renderer.render(scene, this.camera);
        // and reset the override material
        scene.overrideMaterial = null;
        this.floor.visible = true;
        this.blurShadow(renderer);
        // reset and render the normal scene
        renderer.xr.enabled = xrEnabled;
        renderer.setRenderTarget(oldRenderTarget);
        renderer.setClearAlpha(initialClearAlpha);
    // this.cameraHelper.visible = true;
    }
    blurShadow(renderer) {
        const { camera, horizontalBlurMaterial, verticalBlurMaterial, renderTarget, renderTargetBlur, blurPlane } = this;
        blurPlane.visible = true;
        // blur horizontally and draw in the renderTargetBlur
        blurPlane.material = horizontalBlurMaterial;
        horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width;
        horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture;
        renderer.setRenderTarget(renderTargetBlur);
        renderer.render(blurPlane, camera);
        // blur vertically and draw in the main renderTarget
        blurPlane.material = verticalBlurMaterial;
        verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height;
        verticalBlurMaterial.uniforms.tDiffuse.value = this.renderTargetBlur.texture;
        renderer.setRenderTarget(renderTarget);
        renderer.render(blurPlane, camera);
        blurPlane.visible = false;
    }
    dispose() {
        if (this.renderTarget != null) {
            this.renderTarget.dispose();
        }
        if (this.renderTargetBlur != null) {
            this.renderTargetBlur.dispose();
        }
        this.depthMaterial.dispose();
        this.horizontalBlurMaterial.dispose();
        this.verticalBlurMaterial.dispose();
        this.floor.material.dispose();
        this.floor.geometry.dispose();
        this.blurPlane.geometry.dispose();
        this.removeFromParent();
    }
} //# sourceMappingURL=Shadow.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/ModelScene.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "IlluminationRole": (()=>IlluminationRole),
    "ModelScene": (()=>ModelScene)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$renderers$2f$CSS2DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/renderers/CSS2DRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Hotspot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Hotspot.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/ModelUtils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Shadow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Shadow.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
const MIN_SHADOW_RATIO = 100;
const IlluminationRole = {
    Primary: 'primary',
    Secondary: 'secondary'
};
const view = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const normalWorld = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const raycaster = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Raycaster"]();
const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const ndc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
class ModelScene extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Scene"] {
    constructor({ canvas, element, width, height }){
        super();
        this.annotationRenderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$renderers$2f$CSS2DRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CSS2DRenderer"]();
        this.schemaElement = document.createElement('script');
        this.width = 1;
        this.height = 1;
        this.aspect = 1;
        this.scaleStep = 0;
        this.renderCount = 0;
        this.externalRenderer = null;
        // These default camera values are never used, as they are reset once the
        // model is loaded and framing is computed.
        this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](45, 1, 0.1, 100);
        this.xrCamera = null;
        this.url = null;
        this.target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Object3D"]();
        this.animationNames = [];
        this.boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
        this.boundingSphere = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Sphere"]();
        this.size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.idealAspect = 0;
        this.framedFoVDeg = 0;
        this.shadow = null;
        this.shadowIntensity = 0;
        this.shadowSoftness = 1;
        this.bakedShadows = new Set();
        this.exposure = 1;
        this.canScale = true;
        this.isDirty = false;
        this.goalTarget = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
        this.targetDamperX = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.targetDamperY = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.targetDamperZ = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this._currentGLTF = null;
        this._model = null;
        this.cancelPendingSourceChange = null;
        this.animationsByName = new Map();
        this.currentAnimationAction = null;
        this.name = 'ModelScene';
        this.element = element;
        this.canvas = canvas;
        // These default camera values are never used, as they are reset once the
        // model is loaded and framing is computed.
        this.camera = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PerspectiveCamera"](45, 1, 0.1, 100);
        this.camera.name = 'MainCamera';
        this.add(this.target);
        this.setSize(width, height);
        this.target.name = 'Target';
        this.mixer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixer"](this.target);
        const { domElement } = this.annotationRenderer;
        const { style } = domElement;
        style.display = 'none';
        style.pointerEvents = 'none';
        style.position = 'absolute';
        style.top = '0';
        this.element.shadowRoot.querySelector('.default').appendChild(domElement);
        this.schemaElement.setAttribute('type', 'application/ld+json');
    }
    /**
     * Function to create the context lazily, as when there is only one
     * <model-viewer> element, the renderer's 3D context can be displayed
     * directly. This extra context is necessary to copy the renderings into when
     * there are more than one.
     */ get context() {
        return this.canvas.getContext('2d');
    }
    getCamera() {
        return this.xrCamera != null ? this.xrCamera : this.camera;
    }
    queueRender() {
        this.isDirty = true;
    }
    shouldRender() {
        return this.isDirty;
    }
    hasRendered() {
        this.isDirty = false;
    }
    forceRescale() {
        this.scaleStep = -1;
        this.queueRender();
    }
    /**
     * Pass in a THREE.Object3D to be controlled
     * by this model.
     */ async setObject(model) {
        this.reset();
        this._model = model;
        this.target.add(model);
        await this.setupScene();
    }
    /**
     * Sets the model via URL.
     */ async setSource(url, progressCallback = ()=>{}) {
        if (!url || url === this.url) {
            progressCallback(1);
            return;
        }
        this.reset();
        this.url = url;
        if (this.externalRenderer != null) {
            const framingInfo = await this.externalRenderer.load(progressCallback);
            this.boundingSphere.radius = framingInfo.framedRadius;
            this.idealAspect = framingInfo.fieldOfViewAspect;
            return;
        }
        // If we have pending work due to a previous source change in progress,
        // cancel it so that we do not incur a race condition:
        if (this.cancelPendingSourceChange != null) {
            this.cancelPendingSourceChange();
            this.cancelPendingSourceChange = null;
        }
        let gltf;
        try {
            gltf = await new Promise(async (resolve, reject)=>{
                this.cancelPendingSourceChange = ()=>reject();
                try {
                    const result = await this.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].loader.load(url, this.element, progressCallback);
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            });
        } catch (error) {
            if (error == null) {
                // Loading was cancelled, so silently return
                return;
            }
            throw error;
        }
        this.cancelPendingSourceChange = null;
        this.reset();
        this.url = url;
        this._currentGLTF = gltf;
        if (gltf != null) {
            this._model = gltf.scene;
            this.target.add(gltf.scene);
        }
        const { animations } = gltf;
        const animationsByName = new Map();
        const animationNames = [];
        for (const animation of animations){
            animationsByName.set(animation.name, animation);
            animationNames.push(animation.name);
        }
        this.animations = animations;
        this.animationsByName = animationsByName;
        this.animationNames = animationNames;
        await this.setupScene();
    }
    async setupScene() {
        this.applyTransform();
        this.updateBoundingBox();
        await this.updateFraming();
        this.updateShadow();
        this.setShadowIntensity(this.shadowIntensity);
    }
    reset() {
        this.url = null;
        this.queueRender();
        if (this.shadow != null) {
            this.shadow.setIntensity(0);
        }
        this.bakedShadows.clear();
        const { _model } = this;
        if (_model != null) {
            _model.removeFromParent();
            this._model = null;
        }
        const gltf = this._currentGLTF;
        if (gltf != null) {
            gltf.dispose();
            this._currentGLTF = null;
        }
        if (this.currentAnimationAction != null) {
            this.currentAnimationAction.stop();
            this.currentAnimationAction = null;
        }
        this.mixer.stopAllAction();
        this.mixer.uncacheRoot(this);
    }
    dispose() {
        this.reset();
        if (this.shadow != null) {
            this.shadow.dispose();
            this.shadow = null;
        }
        this.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$currentGLTF"]] = null;
        this.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$originalGltfJson"]] = null;
        this.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$model"]] = null;
    }
    get currentGLTF() {
        return this._currentGLTF;
    }
    /**
     * Updates the ModelScene for a new container size in CSS pixels.
     */ setSize(width, height) {
        if (this.width === width && this.height === height) {
            return;
        }
        this.width = Math.max(width, 1);
        this.height = Math.max(height, 1);
        this.annotationRenderer.setSize(width, height);
        this.aspect = this.width / this.height;
        if (this.externalRenderer != null) {
            const dpr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveDpr"])();
            this.externalRenderer.resize(width * dpr, height * dpr);
        }
        this.queueRender();
    }
    markBakedShadow(mesh) {
        mesh.userData.shadow = true;
        this.bakedShadows.add(mesh);
    }
    unmarkBakedShadow(mesh) {
        mesh.userData.shadow = false;
        mesh.visible = true;
        this.bakedShadows.delete(mesh);
        this.boundingBox.expandByObject(mesh);
    }
    findBakedShadows(group) {
        const boundingBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
        group.traverse((object)=>{
            const mesh = object;
            if (!mesh.isMesh) {
                return;
            }
            const material = mesh.material;
            if (!material.transparent) {
                return;
            }
            boundingBox.setFromObject(mesh);
            const size = boundingBox.getSize(vector3);
            const minDim = Math.min(size.x, size.y, size.z);
            const maxDim = Math.max(size.x, size.y, size.z);
            if (maxDim < MIN_SHADOW_RATIO * minDim) {
                return;
            }
            this.markBakedShadow(mesh);
        });
    }
    checkBakedShadows() {
        const { min, max } = this.boundingBox;
        const shadowBox = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]();
        this.boundingBox.getSize(this.size);
        for (const mesh of this.bakedShadows){
            shadowBox.setFromObject(mesh);
            if (shadowBox.min.y < min.y + this.size.y / MIN_SHADOW_RATIO && shadowBox.min.x <= min.x && shadowBox.max.x >= max.x && shadowBox.min.z <= min.z && shadowBox.max.z >= max.z) {
                continue;
            }
            if (shadowBox.min.z < min.z + this.size.z / MIN_SHADOW_RATIO && shadowBox.min.x <= min.x && shadowBox.max.x >= max.x && shadowBox.min.y <= min.y && shadowBox.max.y >= max.y) {
                continue;
            }
            this.unmarkBakedShadow(mesh);
        }
    }
    applyTransform() {
        const { model } = this;
        if (model == null) {
            return;
        }
        const orientation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(this.element.orientation)[0].terms;
        const roll = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(orientation[0]).number;
        const pitch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(orientation[1]).number;
        const yaw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(orientation[2]).number;
        model.quaternion.setFromEuler(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"](pitch, yaw, roll, 'YXZ'));
        const scale = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(this.element.scale)[0].terms;
        model.scale.set(scale[0].number, scale[1].number, scale[2].number);
    }
    updateBoundingBox() {
        const { model } = this;
        if (model == null) {
            return;
        }
        this.target.remove(model);
        this.findBakedShadows(model);
        const bound = (box, vertex)=>{
            return box.expandByPoint(vertex);
        };
        this.setBakedShadowVisibility(false);
        this.boundingBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reduceVertices"])(model, bound, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]());
        // If there's nothing but the baked shadow, then it's not a baked shadow.
        if (this.boundingBox.isEmpty()) {
            this.setBakedShadowVisibility(true);
            this.bakedShadows.forEach((mesh)=>this.unmarkBakedShadow(mesh));
            this.boundingBox = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reduceVertices"])(model, bound, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Box3"]());
        }
        this.checkBakedShadows();
        this.setBakedShadowVisibility();
        this.boundingBox.getSize(this.size);
        this.target.add(model);
    }
    /**
     * Calculates the boundingSphere and idealAspect that allows the 3D
     * object to be framed tightly in a 2D window of any aspect ratio without
     * clipping at any camera orbit. The camera's center target point can be
     * optionally specified. If no center is specified, it defaults to the center
     * of the bounding box, which means asymmetric models will tend to be tight on
     * one side instead of both. Proper choice of center can correct this.
     */ async updateFraming() {
        const { model } = this;
        if (model == null) {
            return;
        }
        this.target.remove(model);
        this.setBakedShadowVisibility(false);
        const { center } = this.boundingSphere;
        this.element.requestUpdate('cameraTarget');
        await this.element.updateComplete;
        center.copy(this.getTarget());
        const radiusSquared = (value, vertex)=>{
            return Math.max(value, center.distanceToSquared(vertex));
        };
        this.boundingSphere.radius = Math.sqrt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reduceVertices"])(model, radiusSquared, 0));
        const horizontalTanFov = (value, vertex)=>{
            vertex.sub(center);
            const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);
            return Math.max(value, radiusXZ / (this.idealCameraDistance() - Math.abs(vertex.y)));
        };
        this.idealAspect = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelUtils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["reduceVertices"])(model, horizontalTanFov, 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180);
        this.setBakedShadowVisibility();
        this.target.add(model);
    }
    setBakedShadowVisibility(visible = this.shadowIntensity <= 0) {
        for (const shadow of this.bakedShadows){
            shadow.visible = visible;
        }
    }
    idealCameraDistance() {
        const halfFovRad = this.framedFoVDeg / 2 * Math.PI / 180;
        return this.boundingSphere.radius / Math.sin(halfFovRad);
    }
    /**
     * Set's the framedFieldOfView based on the aspect ratio of the window in
     * order to keep the model fully visible at any camera orientation.
     */ adjustedFoV(fovDeg) {
        const vertical = Math.tan(fovDeg / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect);
        return 2 * Math.atan(vertical) * 180 / Math.PI;
    }
    getNDC(clientX, clientY) {
        if (this.xrCamera != null) {
            ndc.set(clientX / window.screen.width, clientY / window.screen.height);
        } else {
            const rect = this.element.getBoundingClientRect();
            ndc.set((clientX - rect.x) / this.width, (clientY - rect.y) / this.height);
        }
        ndc.multiplyScalar(2).subScalar(1);
        ndc.y *= -1;
        return ndc;
    }
    /**
     * Returns the size of the corresponding canvas element.
     */ getSize() {
        return {
            width: this.width,
            height: this.height
        };
    }
    setEnvironmentAndSkybox(environment, skybox) {
        if (this.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.presentedScene === this) {
            return;
        }
        this.environment = environment;
        this.background = skybox;
        this.queueRender();
    }
    /**
     * Sets the point in model coordinates the model should orbit/pivot around.
     */ setTarget(modelX, modelY, modelZ) {
        this.goalTarget.set(-modelX, -modelY, -modelZ);
    }
    /**
     * Set the decay time of, affects the speed of target transitions.
     */ setTargetDamperDecayTime(decayMilliseconds) {
        this.targetDamperX.setDecayTime(decayMilliseconds);
        this.targetDamperY.setDecayTime(decayMilliseconds);
        this.targetDamperZ.setDecayTime(decayMilliseconds);
    }
    /**
     * Gets the point in model coordinates the model should orbit/pivot around.
     */ getTarget() {
        return this.goalTarget.clone().multiplyScalar(-1);
    }
    /**
     * Shifts the model to the target point immediately instead of easing in.
     */ jumpToGoal() {
        this.updateTarget(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SETTLING_TIME"]);
    }
    /**
     * This should be called every frame with the frame delta to cause the target
     * to transition to its set point.
     */ updateTarget(delta) {
        const goal = this.goalTarget;
        const target = this.target.position;
        if (!goal.equals(target)) {
            const normalization = this.boundingSphere.radius / 10;
            let { x, y, z } = target;
            x = this.targetDamperX.update(x, goal.x, delta, normalization);
            y = this.targetDamperY.update(y, goal.y, delta, normalization);
            z = this.targetDamperZ.update(z, goal.z, delta, normalization);
            this.target.position.set(x, y, z);
            this.target.updateMatrixWorld();
            this.queueRender();
            return true;
        } else {
            return false;
        }
    }
    /**
     * Yaw the +z (front) of the model toward the indicated world coordinates.
     */ pointTowards(worldX, worldZ) {
        const { x, z } = this.position;
        this.yaw = Math.atan2(worldX - x, worldZ - z);
    }
    get model() {
        return this._model;
    }
    /**
     * Yaw is the scene's orientation about the y-axis, around the rotation
     * center.
     */ set yaw(radiansY) {
        this.rotation.y = radiansY;
        this.queueRender();
    }
    get yaw() {
        return this.rotation.y;
    }
    set animationTime(value) {
        this.mixer.setTime(value);
        this.queueShadowRender();
    }
    get animationTime() {
        if (this.currentAnimationAction != null) {
            const loopCount = Math.max(this.currentAnimationAction._loopCount, 0);
            if (this.currentAnimationAction.loop === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoopPingPong"] && (loopCount & 1) === 1) {
                return this.duration - this.currentAnimationAction.time;
            } else {
                return this.currentAnimationAction.time;
            }
        }
        return 0;
    }
    set animationTimeScale(value) {
        this.mixer.timeScale = value;
    }
    get animationTimeScale() {
        return this.mixer.timeScale;
    }
    get duration() {
        if (this.currentAnimationAction != null && this.currentAnimationAction.getClip()) {
            return this.currentAnimationAction.getClip().duration;
        }
        return 0;
    }
    get hasActiveAnimation() {
        return this.currentAnimationAction != null;
    }
    /**
     * Plays an animation if there are any associated with the current model.
     * Accepts an optional string name of an animation to play. If no name is
     * provided, or if no animation is found by the given name, always falls back
     * to playing the first animation.
     */ playAnimation(name = null, crossfadeTime = 0, loopMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoopRepeat"], repetitionCount = Infinity) {
        if (this._currentGLTF == null) {
            return;
        }
        const { animations } = this;
        if (animations == null || animations.length === 0) {
            console.warn(`Cannot play animation (model does not have any animations)`);
            return;
        }
        let animationClip = null;
        if (name != null) {
            animationClip = this.animationsByName.get(name);
            if (animationClip == null) {
                const parsedAnimationIndex = parseInt(name);
                if (!isNaN(parsedAnimationIndex) && parsedAnimationIndex >= 0 && parsedAnimationIndex < animations.length) {
                    animationClip = animations[parsedAnimationIndex];
                }
            }
        }
        if (animationClip == null) {
            animationClip = animations[0];
        }
        try {
            const { currentAnimationAction: lastAnimationAction } = this;
            const action = this.mixer.clipAction(animationClip, this);
            this.currentAnimationAction = action;
            if (this.element.paused) {
                this.mixer.stopAllAction();
            } else {
                action.paused = false;
                if (lastAnimationAction != null && action !== lastAnimationAction) {
                    action.crossFadeFrom(lastAnimationAction, crossfadeTime, false);
                } else if (this.animationTimeScale > 0 && this.animationTime == this.duration) {
                    // This is a workaround for what I believe is a three.js bug.
                    this.animationTime = 0;
                }
            }
            action.setLoop(loopMode, repetitionCount);
            action.enabled = true;
            action.clampWhenFinished = true;
            action.play();
        } catch (error) {
            console.error(error);
        }
    }
    stopAnimation() {
        this.currentAnimationAction = null;
        this.mixer.stopAllAction();
    }
    updateAnimation(step) {
        this.mixer.update(step);
        this.queueShadowRender();
    }
    subscribeMixerEvent(event, callback) {
        this.mixer.addEventListener(event, callback);
    }
    /**
     * Call if the object has been changed in such a way that the shadow's shape
     * has changed (not a rotation about the Y axis).
     */ updateShadow() {
        const shadow = this.shadow;
        if (shadow != null) {
            const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';
            shadow.setScene(this, this.shadowSoftness, side);
            shadow.needsUpdate = true;
        }
    }
    renderShadow(renderer) {
        const shadow = this.shadow;
        if (shadow != null && shadow.needsUpdate == true) {
            shadow.render(renderer, this);
            shadow.needsUpdate = false;
        }
    }
    queueShadowRender() {
        if (this.shadow != null) {
            this.shadow.needsUpdate = true;
        }
    }
    /**
     * Sets the shadow's intensity, lazily creating the shadow as necessary.
     */ setShadowIntensity(shadowIntensity) {
        this.shadowIntensity = shadowIntensity;
        if (this._currentGLTF == null) {
            return;
        }
        this.setBakedShadowVisibility();
        if (shadowIntensity <= 0 && this.shadow == null) {
            return;
        }
        if (this.shadow == null) {
            const side = this.element.arPlacement === 'wall' ? 'back' : 'bottom';
            this.shadow = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Shadow$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Shadow"](this, this.shadowSoftness, side);
        }
        this.shadow.setIntensity(shadowIntensity);
    }
    /**
     * Sets the shadow's softness by mapping a [0, 1] softness parameter to the
     * shadow's resolution. This involves reallocation, so it should not be
     * changed frequently. Softer shadows are cheaper to render.
     */ setShadowSoftness(softness) {
        this.shadowSoftness = softness;
        const shadow = this.shadow;
        if (shadow != null) {
            shadow.setSoftness(softness);
        }
    }
    /**
     * Shift the floor vertically from the bottom of the model's bounding box by
     * offset (should generally be negative).
     */ setShadowOffset(offset) {
        const shadow = this.shadow;
        if (shadow != null) {
            shadow.setOffset(offset);
        }
    }
    get raycaster() {
        return raycaster;
    }
    /**
     * This method returns the world position, model-space normal and texture
     * coordinate of the point on the mesh corresponding to the input pixel
     * coordinates given relative to the model-viewer element. If the mesh
     * is not hit, the result is null.
     */ positionAndNormalFromPoint(ndcPosition, object = this) {
        this.raycaster.setFromCamera(ndcPosition, this.getCamera());
        const hits = this.raycaster.intersectObject(object, true);
        const hit = hits.find((hit)=>hit.object.visible && !hit.object.userData.shadow);
        if (hit == null || hit.face == null) {
            return null;
        }
        if (hit.uv == null) {
            return {
                position: hit.point,
                normal: hit.face.normal,
                uv: null
            };
        }
        hit.face.normal.applyNormalMatrix(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]().getNormalMatrix(hit.object.matrixWorld));
        return {
            position: hit.point,
            normal: hit.face.normal,
            uv: hit.uv
        };
    }
    /**
     * The following methods are for operating on the set of Hotspot objects
     * attached to the scene. These come from DOM elements, provided to slots by
     * the Annotation Mixin.
     */ addHotspot(hotspot) {
        this.target.add(hotspot);
        // This happens automatically in render(), but we do it early so that
        // the slots appear in the shadow DOM and the elements get attached,
        // allowing us to dispatch events on them.
        this.annotationRenderer.domElement.appendChild(hotspot.element);
    }
    removeHotspot(hotspot) {
        this.target.remove(hotspot);
    }
    /**
     * Helper method to apply a function to all hotspots.
     */ forHotspots(func) {
        const { children } = this.target;
        for(let i = 0, l = children.length; i < l; i++){
            const hotspot = children[i];
            if (hotspot instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Hotspot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotspot"]) {
                func(hotspot);
            }
        }
    }
    /**
     * Update the CSS visibility of the hotspots based on whether their normals
     * point toward the camera.
     */ updateHotspots(viewerPosition) {
        this.forHotspots((hotspot)=>{
            view.copy(viewerPosition);
            target.setFromMatrixPosition(hotspot.matrixWorld);
            view.sub(target);
            normalWorld.copy(hotspot.normal).transformDirection(this.target.matrixWorld);
            if (view.dot(normalWorld) < 0) {
                hotspot.hide();
            } else {
                hotspot.show();
            }
        });
    }
    /**
     * Rotate all hotspots to an absolute orientation given by the input number of
     * radians. Zero returns them to upright.
     */ orientHotspots(radians) {
        this.forHotspots((hotspot)=>{
            hotspot.orient(radians);
        });
    }
    /**
     * Set the rendering visibility of all hotspots. This is used to hide them
     * during transitions and such.
     */ setHotspotsVisibility(visible) {
        this.forHotspots((hotspot)=>{
            hotspot.visible = visible;
        });
    }
    updateSchema(src) {
        var _a;
        const { schemaElement, element } = this;
        const { alt, poster, iosSrc } = element;
        if (src != null) {
            const encoding = [
                {
                    '@type': 'MediaObject',
                    contentUrl: src,
                    encodingFormat: ((_a = src.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'gltf' ? 'model/gltf+json' : 'model/gltf-binary'
                }
            ];
            if (iosSrc) {
                encoding.push({
                    '@type': 'MediaObject',
                    contentUrl: iosSrc,
                    encodingFormat: 'model/vnd.usdz+zip'
                });
            }
            const structuredData = {
                '@context': 'http://schema.org/',
                '@type': '3DModel',
                image: poster !== null && poster !== void 0 ? poster : undefined,
                name: alt !== null && alt !== void 0 ? alt : undefined,
                encoding
            };
            schemaElement.textContent = JSON.stringify(structuredData);
            document.head.appendChild(schemaElement);
        } else if (schemaElement.parentElement != null) {
            schemaElement.parentElement.removeChild(schemaElement);
        }
    }
} //# sourceMappingURL=ModelScene.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities/data-conversion.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ /**
 * Converts a base64 string which represents a data url
 * into a Blob of the same contents.
 */ __turbopack_context__.s({
    "dataUrlToBlob": (()=>dataUrlToBlob)
});
const dataUrlToBlob = async (base64DataUrl)=>{
    return new Promise((resolve, reject)=>{
        const sliceSize = 512;
        const typeMatch = base64DataUrl.match(/data:(.*);/);
        if (!typeMatch) {
            return reject(new Error(`${base64DataUrl} is not a valid data Url`));
        }
        const type = typeMatch[1];
        const base64 = base64DataUrl.replace(/data:image\/\w+;base64,/, '');
        const byteCharacters = atob(base64);
        const byteArrays = [];
        for(let offset = 0; offset < byteCharacters.length; offset += sliceSize){
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for(let i = 0; i < slice.length; i++){
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        resolve(new Blob(byteArrays, {
            type
        }));
    });
}; //# sourceMappingURL=data-conversion.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities/progress-tracker.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ProgressTracker": (()=>ProgressTracker)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
;
class ProgressTracker extends EventTarget {
    constructor(){
        super(...arguments);
        this.ongoingActivities = new Set();
        this.totalProgress = 0;
    }
    /**
     * The total number of activities currently being tracked.
     */ get ongoingActivityCount() {
        return this.ongoingActivities.size;
    }
    /**
     * Registers a new activity to be tracked by the progress tracker. The method
     * returns a special callback that should be invoked whenever new progress is
     * ready to be reported. The progress should be reported as a value between 0
     * and 1, where 0 would represent the beginning of the action and 1 would
     * represent its completion.
     *
     * There is no built-in notion of a time-out for ongoing activities, so once
     * an ongoing activity is begun, it is up to the consumer of this API to
     * update the progress until that activity is no longer ongoing.
     *
     * Progress is only allowed to move forward for any given activity. If a lower
     * progress is reported than the previously reported progress, it will be
     * ignored.
     */ beginActivity() {
        const activity = {
            progress: 0,
            completed: false
        };
        this.ongoingActivities.add(activity);
        if (this.ongoingActivityCount === 1) {
            // Announce the first progress event (which should always be 0 / 1
            // total progress):
            this.announceTotalProgress(activity, 0);
        }
        return (progress)=>{
            let nextProgress;
            nextProgress = Math.max((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(progress, 0, 1), activity.progress);
            if (nextProgress !== activity.progress) {
                this.announceTotalProgress(activity, nextProgress);
            }
            return activity.progress;
        };
    }
    announceTotalProgress(updatedActivity, nextProgress) {
        let progressLeft = 0;
        let completedActivities = 0;
        if (nextProgress == 1.0) updatedActivity.completed = true;
        for (const activity of this.ongoingActivities){
            const { progress } = activity;
            progressLeft += 1.0 - progress;
            if (activity.completed === true) {
                completedActivities++;
            }
        }
        const lastProgress = updatedActivity.progress;
        updatedActivity.progress = nextProgress;
        // Advance the total progress by the fraction of total remaining progress
        // due to this activity.
        this.totalProgress += (nextProgress - lastProgress) * (1.0 - this.totalProgress) / progressLeft;
        const totalProgress = completedActivities === this.ongoingActivityCount ? 1.0 : this.totalProgress;
        this.dispatchEvent(new CustomEvent('progress', {
            detail: {
                totalProgress
            }
        }));
        if (completedActivities === this.ongoingActivityCount) {
            this.totalProgress = 0.0;
            this.ongoingActivities.clear();
        }
    }
} //# sourceMappingURL=progress-tracker.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$altDefaulted": (()=>$altDefaulted),
    "$announceModelVisibility": (()=>$announceModelVisibility),
    "$ariaLabel": (()=>$ariaLabel),
    "$canvas": (()=>$canvas),
    "$container": (()=>$container),
    "$getLoaded": (()=>$getLoaded),
    "$getModelIsVisible": (()=>$getModelIsVisible),
    "$intersectionObserver": (()=>$intersectionObserver),
    "$isElementInViewport": (()=>$isElementInViewport),
    "$loadedTime": (()=>$loadedTime),
    "$markLoaded": (()=>$markLoaded),
    "$needsRender": (()=>$needsRender),
    "$onModelLoad": (()=>$onModelLoad),
    "$onResize": (()=>$onResize),
    "$progressTracker": (()=>$progressTracker),
    "$renderer": (()=>$renderer),
    "$scene": (()=>$scene),
    "$shouldAttemptPreload": (()=>$shouldAttemptPreload),
    "$statusElement": (()=>$statusElement),
    "$tick": (()=>$tick),
    "$updateSize": (()=>$updateSize),
    "$updateSource": (()=>$updateSource),
    "$updateStatus": (()=>$updateStatus),
    "$userInputElement": (()=>$userInputElement),
    "blobCanvas": (()=>blobCanvas),
    "default": (()=>ModelViewerElementBase),
    "toVector2D": (()=>toVector2D),
    "toVector3D": (()=>toVector3D)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$reactive$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/reactive-element.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$template$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/template.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelScene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/ModelScene.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Renderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$data$2d$conversion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities/data-conversion.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$progress$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities/progress-tracker.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
;
;
;
;
;
;
;
;
;
;
;
const CLEAR_MODEL_TIMEOUT_MS = 1000;
const FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;
const ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;
const UNSIZED_MEDIA_WIDTH = 300;
const UNSIZED_MEDIA_HEIGHT = 150;
const blobCanvas = document.createElement('canvas');
const $fallbackResizeHandler = Symbol('fallbackResizeHandler');
const $defaultAriaLabel = Symbol('defaultAriaLabel');
const $resizeObserver = Symbol('resizeObserver');
const $clearModelTimeout = Symbol('clearModelTimeout');
const $onContextLost = Symbol('onContextLost');
const $loaded = Symbol('loaded');
const $status = Symbol('status');
const $onFocus = Symbol('onFocus');
const $onBlur = Symbol('onBlur');
const $updateSize = Symbol('updateSize');
const $intersectionObserver = Symbol('intersectionObserver');
const $isElementInViewport = Symbol('isElementInViewport');
const $announceModelVisibility = Symbol('announceModelVisibility');
const $ariaLabel = Symbol('ariaLabel');
const $altDefaulted = Symbol('altDefaulted');
const $statusElement = Symbol('statusElement');
const $updateStatus = Symbol('updateStatus');
const $loadedTime = Symbol('loadedTime');
const $updateSource = Symbol('updateSource');
const $markLoaded = Symbol('markLoaded');
const $container = Symbol('container');
const $userInputElement = Symbol('input');
const $canvas = Symbol('canvas');
const $scene = Symbol('scene');
const $needsRender = Symbol('needsRender');
const $tick = Symbol('tick');
const $onModelLoad = Symbol('onModelLoad');
const $onResize = Symbol('onResize');
const $renderer = Symbol('renderer');
const $progressTracker = Symbol('progressTracker');
const $getLoaded = Symbol('getLoaded');
const $getModelIsVisible = Symbol('getModelIsVisible');
const $shouldAttemptPreload = Symbol('shouldAttemptPreload');
const toVector3D = (v)=>{
    return {
        x: v.x,
        y: v.y,
        z: v.z,
        toString () {
            return `${this.x}m ${this.y}m ${this.z}m`;
        }
    };
};
const toVector2D = (v)=>{
    return {
        u: v.x,
        v: v.y,
        toString () {
            return `${this.u} ${this.v}`;
        }
    };
};
class ModelViewerElementBase extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$reactive$2d$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ReactiveElement"] {
    /**
     * Creates a new ModelViewerElement.
     */ constructor(){
        super();
        this.alt = null;
        this.src = null;
        this.withCredentials = false;
        /**
         * Generates a 3D model schema https://schema.org/3DModel associated with
         * the loaded src and inserts it into the header of the page for search
         * engines to crawl.
         */ this.generateSchema = false;
        this[_a] = false;
        this[_b] = false;
        this[_c] = 0;
        this[_d] = '';
        this[_e] = null;
        this[_f] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debounce"])(()=>{
            const boundingRect = this.getBoundingClientRect();
            this[$updateSize](boundingRect);
        }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);
        this[_g] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["debounce"])((oldVisibility)=>{
            const newVisibility = this.modelIsVisible;
            if (newVisibility !== oldVisibility) {
                this.dispatchEvent(new CustomEvent('model-visibility', {
                    detail: {
                        visible: newVisibility
                    }
                }));
            }
        }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);
        this[_h] = null;
        this[_j] = null;
        this[_k] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$progress$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ProgressTracker"]();
        this[_l] = ()=>{
            this[$statusElement].textContent = this[$status];
        };
        this[_m] = ()=>{
            this[$statusElement].textContent = '';
        };
        this[_o] = (event)=>{
            this.dispatchEvent(new CustomEvent('error', {
                detail: {
                    type: 'webglcontextlost',
                    sourceError: event.sourceEvent
                }
            }));
        };
        this.attachShadow({
            mode: 'open'
        });
        const shadowRoot = this.shadowRoot;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$template$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeTemplate"])(shadowRoot);
        this[$container] = shadowRoot.querySelector('.container');
        this[$userInputElement] = shadowRoot.querySelector('.userInput');
        this[$canvas] = shadowRoot.querySelector('canvas');
        this[$statusElement] = shadowRoot.querySelector('#status');
        this[$defaultAriaLabel] = this[$userInputElement].getAttribute('aria-label');
        // Because of potential race conditions related to invoking the constructor
        // we only use the bounding rect to set the initial size if the element is
        // already connected to the document:
        let width, height;
        if (this.isConnected) {
            const rect = this.getBoundingClientRect();
            width = rect.width;
            height = rect.height;
        } else {
            width = UNSIZED_MEDIA_WIDTH;
            height = UNSIZED_MEDIA_HEIGHT;
        }
        // Create the underlying ModelScene.
        this[$scene] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ModelScene$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ModelScene"]({
            canvas: this[$canvas],
            element: this,
            width,
            height
        });
        // Update initial size on microtask timing so that subclasses have a
        // chance to initialize
        Promise.resolve().then(()=>{
            this[$updateSize](this.getBoundingClientRect());
        });
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_RESIZE_OBSERVER"]) {
            // Set up a resize observer so we can scale our canvas
            // if our <model-viewer> changes
            this[$resizeObserver] = new ResizeObserver((entries)=>{
                // Don't resize anything if in AR mode; otherwise the canvas
                // scaling to fullscreen on entering AR will clobber the flat/2d
                // dimensions of the element.
                if (this[$renderer].isPresenting) {
                    return;
                }
                for (let entry of entries){
                    if (entry.target === this) {
                        this[$updateSize](entry.contentRect);
                    }
                }
            });
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_INTERSECTION_OBSERVER"]) {
            this[$intersectionObserver] = new IntersectionObserver((entries)=>{
                for (let entry of entries){
                    if (entry.target === this) {
                        const oldVisibility = this.modelIsVisible;
                        this[$isElementInViewport] = entry.isIntersecting;
                        this[$announceModelVisibility](oldVisibility);
                        if (this[$isElementInViewport] && !this.loaded) {
                            this[$updateSource]();
                        }
                    }
                }
            }, {
                root: null,
                // We used to have margin here, but it was causing animated models below
                // the fold to steal the frame budget. Weirder still, it would also
                // cause input events to be swallowed, sometimes for seconds on the
                // model above the fold, but only when the animated model was completely
                // below. Setting this margin to zero fixed it.
                rootMargin: '0px',
                // With zero threshold, an element adjacent to but not intersecting the
                // viewport will be reported as intersecting, which will cause
                // unnecessary rendering. Any slight positive threshold alleviates this.
                threshold: 0.00001
            });
        } else {
            // If there is no intersection observer, then all models should be visible
            // at all times:
            this[$isElementInViewport] = true;
        }
    }
    static get is() {
        return 'model-viewer';
    }
    /** @export */ static set modelCacheSize(value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$evictionPolicy"]].evictionThreshold = value;
    }
    /** @export */ static get modelCacheSize() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"][__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$evictionPolicy"]].evictionThreshold;
    }
    /** @export */ static set minimumRenderScale(value) {
        if (value > 1) {
            console.warn('<model-viewer> minimumRenderScale has been clamped to a maximum value of 1.');
        }
        if (value <= 0) {
            console.warn('<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25.');
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"].singleton.minScale = value;
    }
    /** @export */ static get minimumRenderScale() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"].singleton.minScale;
    }
    /** @export */ get loaded() {
        return this[$getLoaded]();
    }
    get [(_a = $isElementInViewport, _b = $loaded, _c = $loadedTime, _d = $status, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, $renderer)]() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"].singleton;
    }
    /** @export */ get modelIsVisible() {
        return this[$getModelIsVisible]();
    }
    connectedCallback() {
        super.connectedCallback && super.connectedCallback();
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_RESIZE_OBSERVER"]) {
            this[$resizeObserver].observe(this);
        } else {
            self.addEventListener('resize', this[$fallbackResizeHandler]);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_INTERSECTION_OBSERVER"]) {
            this[$intersectionObserver].observe(this);
        }
        this.addEventListener('focus', this[$onFocus]);
        this.addEventListener('blur', this[$onBlur]);
        const renderer = this[$renderer];
        renderer.addEventListener('contextlost', this[$onContextLost]);
        renderer.registerScene(this[$scene]);
        if (this[$clearModelTimeout] != null) {
            self.clearTimeout(this[$clearModelTimeout]);
            this[$clearModelTimeout] = null;
            // Force an update in case the model has been evicted from our GLTF cache
            // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate
            this.requestUpdate('src', null);
        }
    }
    disconnectedCallback() {
        super.disconnectedCallback && super.disconnectedCallback();
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_RESIZE_OBSERVER"]) {
            this[$resizeObserver].unobserve(this);
        } else {
            self.removeEventListener('resize', this[$fallbackResizeHandler]);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HAS_INTERSECTION_OBSERVER"]) {
            this[$intersectionObserver].unobserve(this);
        }
        this.removeEventListener('focus', this[$onFocus]);
        this.removeEventListener('blur', this[$onBlur]);
        const renderer = this[$renderer];
        renderer.removeEventListener('contextlost', this[$onContextLost]);
        renderer.unregisterScene(this[$scene]);
        this[$clearModelTimeout] = self.setTimeout(()=>{
            this[$scene].dispose();
            this[$clearModelTimeout] = null;
        }, CLEAR_MODEL_TIMEOUT_MS);
    }
    updated(changedProperties) {
        super.updated(changedProperties);
        // NOTE(cdata): If a property changes from values A -> B -> A in the space
        // of a microtask, LitElement/UpdatingElement will notify of a change even
        // though the value has effectively not changed, so we need to check to make
        // sure that the value has actually changed before changing the loaded flag.
        if (changedProperties.has('src')) {
            if (this.src == null) {
                this[$loaded] = false;
                this[$loadedTime] = 0;
                this[$scene].reset();
            } else if (this.src !== this[$scene].url) {
                this[$loaded] = false;
                this[$loadedTime] = 0;
                this[$updateSource]();
            }
        }
        if (changedProperties.has('alt')) {
            this[$userInputElement].setAttribute('aria-label', this[$ariaLabel]);
        }
        if (changedProperties.has('withCredentials')) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].withCredentials = this.withCredentials;
        }
        if (changedProperties.has('generateSchema')) {
            if (this.generateSchema) {
                this[$scene].updateSchema(this.src);
            } else {
                this[$scene].updateSchema(null);
            }
        }
    }
    /** @export */ toDataURL(type, encoderOptions) {
        return this[$renderer].displayCanvas(this[$scene]).toDataURL(type, encoderOptions);
    }
    /** @export */ async toBlob(options) {
        const mimeType = options ? options.mimeType : undefined;
        const qualityArgument = options ? options.qualityArgument : undefined;
        const useIdealAspect = options ? options.idealAspect : undefined;
        const { width, height, idealAspect, aspect } = this[$scene];
        const { dpr, scaleFactor } = this[$renderer];
        let outputWidth = width * scaleFactor * dpr;
        let outputHeight = height * scaleFactor * dpr;
        let offsetX = 0;
        let offsetY = 0;
        if (useIdealAspect === true) {
            if (idealAspect > aspect) {
                const oldHeight = outputHeight;
                outputHeight = Math.round(outputWidth / idealAspect);
                offsetY = (oldHeight - outputHeight) / 2;
            } else {
                const oldWidth = outputWidth;
                outputWidth = Math.round(outputHeight * idealAspect);
                offsetX = (oldWidth - outputWidth) / 2;
            }
        }
        blobCanvas.width = outputWidth;
        blobCanvas.height = outputHeight;
        try {
            return new Promise(async (resolve, reject)=>{
                blobCanvas.getContext('2d').drawImage(this[$renderer].displayCanvas(this[$scene]), offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);
                if (blobCanvas.msToBlob) {
                    // NOTE: msToBlob only returns image/png
                    // so ensure mimeType is not specified (defaults to image/png)
                    // or is image/png, otherwise fallback to using toDataURL on IE.
                    if (!mimeType || mimeType === 'image/png') {
                        return resolve(blobCanvas.msToBlob());
                    }
                }
                if (!blobCanvas.toBlob) {
                    return resolve(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$data$2d$conversion$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dataUrlToBlob"])(blobCanvas.toDataURL(mimeType, qualityArgument)));
                }
                blobCanvas.toBlob((blob)=>{
                    if (!blob) {
                        return reject(new Error('Unable to retrieve canvas blob'));
                    }
                    resolve(blob);
                }, mimeType, qualityArgument);
            });
        } finally{
            this[$updateSize]({
                width,
                height
            });
        }
        ;
    }
    registerRenderer(renderer) {
        this[$scene].externalRenderer = renderer;
    }
    unregisterRenderer() {
        this[$scene].externalRenderer = null;
    }
    get [$ariaLabel]() {
        return this[$altDefaulted];
    }
    get [$altDefaulted]() {
        return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;
    }
    // NOTE(cdata): Although this may seem extremely redundant, it is required in
    // order to support overloading when TypeScript is compiled to ES5
    // @see https://github.com/Polymer/lit-element/pull/745
    // @see https://github.com/microsoft/TypeScript/issues/338
    [$getLoaded]() {
        return this[$loaded];
    }
    // @see [$getLoaded]
    [$getModelIsVisible]() {
        return this.loaded && this[$isElementInViewport];
    }
    [$shouldAttemptPreload]() {
        return !!this.src && this[$isElementInViewport];
    }
    /**
     * Called on initialization and when the resize observer fires.
     */ [$updateSize]({ width, height }) {
        this[$container].style.width = `${width}px`;
        this[$container].style.height = `${height}px`;
        this[$onResize]({
            width: parseFloat(width),
            height: parseFloat(height)
        });
    }
    [$tick](_time, _delta) {}
    [$markLoaded]() {
        if (this[$loaded]) {
            return;
        }
        this[$loaded] = true;
        this[$loadedTime] = performance.now();
    }
    [$needsRender]() {
        this[$scene].queueRender();
    }
    [$onModelLoad]() {}
    [$updateStatus](status) {
        this[$status] = status;
        const rootNode = this.getRootNode();
        // Only change the aria-label if <model-viewer> is currently focused:
        if (rootNode != null && rootNode.activeElement === this && this[$statusElement].textContent != status) {
            this[$statusElement].textContent = status;
        }
    }
    [(_l = $onFocus, _m = $onBlur, $onResize)](e) {
        this[$scene].setSize(e.width, e.height);
    }
    /**
     * Parses the element for an appropriate source URL and
     * sets the views to use the new model based.
     */ async [(_o = $onContextLost, $updateSource)]() {
        const scene = this[$scene];
        if (this.loaded || !this[$shouldAttemptPreload]() || this.src === scene.url) {
            return;
        }
        if (this.generateSchema) {
            scene.updateSchema(this.src);
        }
        this[$updateStatus]('Loading');
        // If we are loading a new model, we need to stop the animation of
        // the current one (if any is playing). Otherwise, we might lose
        // the reference to the scene root and running actions start to
        // throw exceptions and/or behave in unexpected ways:
        scene.stopAnimation();
        const updateSourceProgress = this[$progressTracker].beginActivity();
        const source = this.src;
        try {
            const srcUpdated = scene.setSource(source, (progress)=>updateSourceProgress((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(progress, 0, 1) * 0.95));
            const envUpdated = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateEnvironment"]]();
            await Promise.all([
                srcUpdated,
                envUpdated
            ]);
            this[$markLoaded]();
            this[$onModelLoad]();
            // Wait for shaders to compile and pixels to be drawn.
            await new Promise((resolve)=>{
                requestAnimationFrame(()=>{
                    requestAnimationFrame(()=>{
                        this.dispatchEvent(new CustomEvent('load', {
                            detail: {
                                url: source
                            }
                        }));
                        resolve();
                    });
                });
            });
        } catch (error) {
            this.dispatchEvent(new CustomEvent('error', {
                detail: {
                    type: 'loadfailure',
                    sourceError: error
                }
            }));
        } finally{
            updateSourceProgress(1.0);
        }
    }
}
__decorate([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
        type: String
    })
], ModelViewerElementBase.prototype, "alt", void 0);
__decorate([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
        type: String
    })
], ModelViewerElementBase.prototype, "src", void 0);
__decorate([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
        type: Boolean,
        attribute: 'with-credentials'
    })
], ModelViewerElementBase.prototype, "withCredentials", void 0);
__decorate([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
        type: Boolean,
        attribute: 'generate-schema'
    })
], ModelViewerElementBase.prototype, "generateSchema", void 0); //# sourceMappingURL=model-viewer-base.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/animation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "AnimationMixin": (()=>AnimationMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
const MILLISECONDS_PER_SECOND = 1000.0;
const $changeAnimation = Symbol('changeAnimation');
const $paused = Symbol('paused');
const DEFAULT_PLAY_OPTIONS = {
    repetitions: Infinity,
    pingpong: false
};
const AnimationMixin = (ModelViewerElement)=>{
    var _a;
    class AnimationModelViewerElement extends ModelViewerElement {
        constructor(...args){
            super(args);
            this.autoplay = false;
            this.animationName = undefined;
            this.animationCrossfadeDuration = 300;
            this[_a] = true;
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].subscribeMixerEvent('loop', (e)=>{
                const count = e.action._loopCount;
                this.dispatchEvent(new CustomEvent('loop', {
                    detail: {
                        count
                    }
                }));
            });
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].subscribeMixerEvent('finished', ()=>{
                this[$paused] = true;
                this.dispatchEvent(new CustomEvent('finished'));
            });
        }
        /**
         * Returns an array
         */ get availableAnimations() {
            if (this.loaded) {
                return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].animationNames;
            }
            return [];
        }
        get duration() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].duration;
        }
        get paused() {
            return this[$paused];
        }
        get currentTime() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].animationTime;
        }
        set currentTime(value) {
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].animationTime = value;
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
        }
        get timeScale() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].animationTimeScale;
        }
        set timeScale(value) {
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].animationTimeScale = value;
        }
        pause() {
            if (this[$paused]) {
                return;
            }
            this[$paused] = true;
            this.dispatchEvent(new CustomEvent('pause'));
        }
        play(options) {
            if (this.availableAnimations.length > 0) {
                this[$paused] = false;
                this[$changeAnimation](options);
                this.dispatchEvent(new CustomEvent('play'));
            }
        }
        [(_a = $paused, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"])]() {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"]]();
            this[$paused] = true;
            if (this.autoplay) {
                this.play();
            }
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](_time, delta) {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](_time, delta);
            if (this[$paused] || !this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getModelIsVisible"]]() && !this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].isPresenting) {
                return;
            }
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].updateAnimation(delta / MILLISECONDS_PER_SECOND);
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('autoplay') && this.autoplay) {
                this.play();
            }
            if (changedProperties.has('animationName')) {
                this[$changeAnimation]();
            }
        }
        [$changeAnimation](options = DEFAULT_PLAY_OPTIONS) {
            var _b;
            const repetitions = (_b = options.repetitions) !== null && _b !== void 0 ? _b : Infinity;
            const mode = options.pingpong ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoopPingPong"] : repetitions === 1 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoopOnce"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoopRepeat"];
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND, mode, repetitions);
            // If we are currently paused, we need to force a render so that
            // the scene updates to the first frame of the new animation
            if (this[$paused]) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].updateAnimation(0);
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
        }
    }
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean
        })
    ], AnimationModelViewerElement.prototype, "autoplay", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'animation-name'
        })
    ], AnimationModelViewerElement.prototype, "animationName", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'animation-crossfade-duration'
        })
    ], AnimationModelViewerElement.prototype, "animationCrossfadeDuration", void 0);
    return AnimationModelViewerElement;
}; //# sourceMappingURL=animation.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/annotation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "AnnotationMixin": (()=>AnnotationMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Hotspot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Hotspot.js [app-client] (ecmascript)");
;
;
;
const $hotspotMap = Symbol('hotspotMap');
const $mutationCallback = Symbol('mutationCallback');
const $observer = Symbol('observer');
const $addHotspot = Symbol('addHotspot');
const $removeHotspot = Symbol('removeHotspot');
const worldToModel = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix4"]();
const worldToModelNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]();
const AnnotationMixin = (ModelViewerElement)=>{
    var _a, _b, _c;
    class AnnotationModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this[_a] = new Map();
            this[_b] = (mutations)=>{
                mutations.forEach((mutation)=>{
                    // NOTE: Be wary that in ShadyDOM cases, the MutationRecord
                    // only has addedNodes and removedNodes (and no other details).
                    if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {
                        mutation.addedNodes.forEach((node)=>{
                            this[$addHotspot](node);
                        });
                        mutation.removedNodes.forEach((node)=>{
                            this[$removeHotspot](node);
                        });
                        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
                    }
                });
            };
            this[_c] = new MutationObserver(this[$mutationCallback]);
        }
        connectedCallback() {
            super.connectedCallback();
            for(let i = 0; i < this.children.length; ++i){
                this[$addHotspot](this.children[i]);
            }
            const { ShadyDOM } = self;
            if (ShadyDOM == null) {
                this[$observer].observe(this, {
                    childList: true
                });
            } else {
                this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            const { ShadyDOM } = self;
            if (ShadyDOM == null) {
                this[$observer].disconnect();
            } else {
                ShadyDOM.unobserveChildren(this[$observer]);
            }
        }
        [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"])](time, delta) {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](time, delta);
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const { annotationRenderer } = scene;
            const camera = scene.getCamera();
            if (scene.shouldRender()) {
                scene.updateHotspots(camera.position);
                annotationRenderer.domElement.style.display = '';
                annotationRenderer.render(scene, camera);
            }
        }
        /**
         * Since the data-position and data-normal attributes are not observed, use
         * this method to move a hotspot. Keep in mind that all hotspots with the
         * same slot name use a single location and the first definition takes
         * precedence, until updated with this method.
         */ updateHotspot(config) {
            const hotspot = this[$hotspotMap].get(config.name);
            if (hotspot == null) {
                return;
            }
            hotspot.updatePosition(config.position);
            hotspot.updateNormal(config.normal);
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
        }
        /**
         * This method returns in-scene data about a requested hotspot including
         * its position in screen (canvas) space and its current visibility.
         */ queryHotspot(name) {
            const hotspot = this[$hotspotMap].get(name);
            if (hotspot == null) {
                return null;
            }
            const position = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(hotspot.position);
            const normal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(hotspot.normal);
            const facingCamera = hotspot.facingCamera;
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const camera = scene.getCamera();
            const vector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
            vector.setFromMatrixPosition(hotspot.matrixWorld);
            vector.project(camera);
            const widthHalf = scene.width / 2;
            const heightHalf = scene.height / 2;
            vector.x = vector.x * widthHalf + widthHalf;
            vector.y = -(vector.y * heightHalf) + heightHalf;
            const canvasPosition = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"](vector.x, vector.y, vector.z));
            if (!Number.isFinite(canvasPosition.x) || !Number.isFinite(canvasPosition.y)) {
                return null;
            }
            return {
                position,
                normal,
                canvasPosition,
                facingCamera
            };
        }
        /**
         * This method returns the model position, normal and texture coordinate
         * of the point on the mesh corresponding to the input pixel coordinates
         * given relative to the model-viewer element. The position and normal
         * are returned as strings in the format suitable for putting in a
         * hotspot's data-position and data-normal attributes. If the mesh is
         * not hit, the result is null.
         */ positionAndNormalFromPoint(pixelX, pixelY) {
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const ndcPosition = scene.getNDC(pixelX, pixelY);
            const hit = scene.positionAndNormalFromPoint(ndcPosition);
            if (hit == null) {
                return null;
            }
            worldToModel.copy(scene.target.matrixWorld).invert();
            const position = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(hit.position.applyMatrix4(worldToModel));
            worldToModelNormal.getNormalMatrix(worldToModel);
            const normal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(hit.normal.applyNormalMatrix(worldToModelNormal));
            let uv = null;
            if (hit.uv != null) {
                uv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector2D"])(hit.uv);
            }
            return {
                position: position,
                normal: normal,
                uv: uv
            };
        }
        [$addHotspot](node) {
            if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {
                return;
            }
            let hotspot = this[$hotspotMap].get(node.slot);
            if (hotspot != null) {
                hotspot.increment();
            } else {
                hotspot = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Hotspot$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hotspot"]({
                    name: node.slot,
                    position: node.dataset.position,
                    normal: node.dataset.normal
                });
                this[$hotspotMap].set(node.slot, hotspot);
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].addHotspot(hotspot);
            }
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].queueRender();
        }
        [$removeHotspot](node) {
            if (!(node instanceof HTMLElement)) {
                return;
            }
            const hotspot = this[$hotspotMap].get(node.slot);
            if (!hotspot) {
                return;
            }
            if (hotspot.decrement()) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].removeHotspot(hotspot);
                this[$hotspotMap].delete(node.slot);
            }
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].queueRender();
        }
    }
    return AnnotationModelViewerElement;
}; //# sourceMappingURL=annotation.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/styles/deserializers.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "enumerationDeserializer": (()=>enumerationDeserializer)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
;
const enumerationDeserializer = (allowedNames)=>(valueString)=>{
        try {
            const expressions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(valueString);
            const names = (expressions.length ? expressions[0].terms : []).filter((valueNode)=>valueNode && valueNode.type === 'ident').map((valueNode)=>valueNode.value).filter((name)=>allowedNames.indexOf(name) > -1);
            // NOTE(cdata): IE11 does not support constructing a Set directly from
            // an iterable, so we need to manually add all the items:
            const result = new Set();
            for (const name of names){
                result.add(name);
            }
            return result;
        } catch (_error) {}
        return new Set();
    }; //# sourceMappingURL=deserializers.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/ar.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$openIOSARQuickLook": (()=>$openIOSARQuickLook),
    "$openSceneViewer": (()=>$openSceneViewer),
    "ARMixin": (()=>ARMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$exporters$2f$USDZExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/examples/jsm/exporters/USDZExporter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/constants.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$deserializers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/deserializers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/ARRenderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
;
;
;
;
let isWebXRBlocked = false;
let isSceneViewerBlocked = false;
const noArViewerSigil = '#model-viewer-no-ar-fallback';
const deserializeARModes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$deserializers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enumerationDeserializer"])([
    'quick-look',
    'scene-viewer',
    'webxr',
    'none'
]);
const DEFAULT_AR_MODES = 'webxr scene-viewer quick-look';
const ARMode = {
    QUICK_LOOK: 'quick-look',
    SCENE_VIEWER: 'scene-viewer',
    WEBXR: 'webxr',
    NONE: 'none'
};
const $arButtonContainer = Symbol('arButtonContainer');
const $enterARWithWebXR = Symbol('enterARWithWebXR');
const $openSceneViewer = Symbol('openSceneViewer');
const $openIOSARQuickLook = Symbol('openIOSARQuickLook');
const $canActivateAR = Symbol('canActivateAR');
const $arMode = Symbol('arMode');
const $arModes = Symbol('arModes');
const $arAnchor = Symbol('arAnchor');
const $preload = Symbol('preload');
const $onARButtonContainerClick = Symbol('onARButtonContainerClick');
const $onARStatus = Symbol('onARStatus');
const $onARTracking = Symbol('onARTracking');
const $onARTap = Symbol('onARTap');
const $selectARMode = Symbol('selectARMode');
const $triggerLoad = Symbol('triggerLoad');
const ARMixin = (ModelViewerElement)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    class ARModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this.ar = false;
            this.arScale = 'auto';
            this.arPlacement = 'floor';
            this.arModes = DEFAULT_AR_MODES;
            this.iosSrc = null;
            this.xrEnvironment = false;
            this[_a] = false;
            // TODO: Add this to the shadow root as part of this mixin's
            // implementation:
            this[_b] = this.shadowRoot.querySelector('.ar-button');
            this[_c] = document.createElement('a');
            this[_d] = new Set();
            this[_e] = ARMode.NONE;
            this[_f] = false;
            this[_g] = (event)=>{
                event.preventDefault();
                this.activateAR();
            };
            this[_h] = ({ status })=>{
                if (status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARStatus"].NOT_PRESENTING || this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.presentedScene === this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]]) {
                    this.setAttribute('ar-status', status);
                    this.dispatchEvent(new CustomEvent('ar-status', {
                        detail: {
                            status
                        }
                    }));
                    if (status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARStatus"].NOT_PRESENTING) {
                        this.removeAttribute('ar-tracking');
                    } else if (status === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARStatus"].SESSION_STARTED) {
                        this.setAttribute('ar-tracking', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARTracking"].TRACKING);
                    }
                }
            };
            this[_j] = ({ status })=>{
                this.setAttribute('ar-tracking', status);
                this.dispatchEvent(new CustomEvent('ar-tracking', {
                    detail: {
                        status
                    }
                }));
            };
            this[_k] = (event)=>{
                if (event.data == '_apple_ar_quicklook_button_tapped') {
                    this.dispatchEvent(new CustomEvent('quick-look-button-tapped'));
                }
            };
        }
        get canActivateAR() {
            return this[$arMode] !== ARMode.NONE;
        }
        connectedCallback() {
            super.connectedCallback();
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.addEventListener('status', this[$onARStatus]);
            this.setAttribute('ar-status', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARStatus"].NOT_PRESENTING);
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.addEventListener('tracking', this[$onARTracking]);
            this[$arAnchor].addEventListener('message', this[$onARTap]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.removeEventListener('status', this[$onARStatus]);
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.removeEventListener('tracking', this[$onARTracking]);
            this[$arAnchor].removeEventListener('message', this[$onARTap]);
        }
        update(changedProperties) {
            super.update(changedProperties);
            if (changedProperties.has('arScale')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].canScale = this.arScale !== 'fixed';
            }
            if (changedProperties.has('arPlacement')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].updateShadow();
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
            }
            if (changedProperties.has('arModes')) {
                this[$arModes] = deserializeARModes(this.arModes);
            }
            if (changedProperties.has('ar') || changedProperties.has('arModes') || changedProperties.has('src') || changedProperties.has('iosSrc')) {
                this[$selectARMode]();
            }
        }
        /**
         * Activates AR. Note that for any mode that is not WebXR-based, this
         * method most likely has to be called synchronous from a user
         * interaction handler. Otherwise, attempts to activate modes that
         * require user interaction will most likely be ignored.
         */ async activateAR() {
            switch(this[$arMode]){
                case ARMode.QUICK_LOOK:
                    this[$openIOSARQuickLook]();
                    break;
                case ARMode.WEBXR:
                    await this[$enterARWithWebXR]();
                    break;
                case ARMode.SCENE_VIEWER:
                    this[$openSceneViewer]();
                    break;
                default:
                    console.warn('No AR Mode can be activated. This is probably due to missing \
configuration or device capabilities');
                    break;
            }
        }
        async [(_a = $canActivateAR, _b = $arButtonContainer, _c = $arAnchor, _d = $arModes, _e = $arMode, _f = $preload, _g = $onARButtonContainerClick, _h = $onARStatus, _j = $onARTracking, _k = $onARTap, $selectARMode)]() {
            let arMode = ARMode.NONE;
            if (this.ar) {
                if (this.src != null) {
                    for (const value of this[$arModes]){
                        if (value === 'webxr' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_WEBXR_AR_CANDIDATE"] && !isWebXRBlocked && await this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.supportsPresentation()) {
                            arMode = ARMode.WEBXR;
                            break;
                        }
                        if (value === 'scene-viewer' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_SCENEVIEWER_CANDIDATE"] && !isSceneViewerBlocked) {
                            arMode = ARMode.SCENE_VIEWER;
                            break;
                        }
                        if (value === 'quick-look' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_AR_QUICKLOOK_CANDIDATE"]) {
                            arMode = ARMode.QUICK_LOOK;
                            break;
                        }
                    }
                }
                // The presence of ios-src overrides the absence of quick-look
                // ar-mode.
                if (arMode === ARMode.NONE && this.iosSrc != null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_AR_QUICKLOOK_CANDIDATE"]) {
                    arMode = ARMode.QUICK_LOOK;
                }
            }
            if (arMode !== ARMode.NONE) {
                this[$arButtonContainer].classList.add('enabled');
                this[$arButtonContainer].addEventListener('click', this[$onARButtonContainerClick]);
            } else if (this[$arButtonContainer].classList.contains('enabled')) {
                this[$arButtonContainer].removeEventListener('click', this[$onARButtonContainerClick]);
                this[$arButtonContainer].classList.remove('enabled');
                // If AR went from working to not, notify the element.
                const status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$ARRenderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARStatus"].FAILED;
                this.setAttribute('ar-status', status);
                this.dispatchEvent(new CustomEvent('ar-status', {
                    detail: {
                        status
                    }
                }));
            }
            this[$arMode] = arMode;
        }
        async [$enterARWithWebXR]() {
            console.log('Attempting to present in AR with WebXR...');
            await this[$triggerLoad]();
            try {
                this[$arButtonContainer].removeEventListener('click', this[$onARButtonContainerClick]);
                const { arRenderer } = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]];
                arRenderer.placeOnWall = this.arPlacement === 'wall';
                await arRenderer.present(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]], this.xrEnvironment);
            } catch (error) {
                console.warn('Error while trying to present in AR with WebXR');
                console.error(error);
                await this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.stopPresenting();
                isWebXRBlocked = true;
                console.warn('Falling back to next ar-mode');
                await this[$selectARMode]();
                this.activateAR();
            } finally{
                this[$selectARMode]();
            }
        }
        async [$triggerLoad]() {
            if (!this.loaded) {
                this[$preload] = true;
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateSource"]]();
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["waitForEvent"])(this, 'load');
                this[$preload] = false;
            }
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$shouldAttemptPreload"]]() {
            return super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$shouldAttemptPreload"]]() || this[$preload];
        }
        /**
         * Takes a URL and a title string, and attempts to launch Scene Viewer on
         * the current device.
         */ [$openSceneViewer]() {
            const location = self.location.toString();
            const locationUrl = new URL(location);
            const modelUrl = new URL(this.src, location);
            const params = new URLSearchParams(modelUrl.search);
            locationUrl.hash = noArViewerSigil;
            // modelUrl can contain title/link/sound etc.
            params.set('mode', 'ar_preferred');
            if (!params.has('disable_occlusion')) {
                params.set('disable_occlusion', 'true');
            }
            if (this.arScale === 'fixed') {
                params.set('resizable', 'false');
            }
            if (this.arPlacement === 'wall') {
                params.set('enable_vertical_placement', 'true');
            }
            if (params.has('sound')) {
                const soundUrl = new URL(params.get('sound'), location);
                params.set('sound', soundUrl.toString());
            }
            if (params.has('link')) {
                const linkUrl = new URL(params.get('link'), location);
                params.set('link', linkUrl.toString());
            }
            const intent = `intent://arvr.google.com/scene-viewer/1.0?${params.toString() + '&file=' + encodeURIComponent(modelUrl.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(locationUrl.toString())};end;`;
            const undoHashChange = ()=>{
                if (self.location.hash === noArViewerSigil) {
                    isSceneViewerBlocked = true;
                    // The new history will be the current URL with a new hash.
                    // Go back one step so that we reset to the expected URL.
                    // NOTE(cdata): this should not invoke any browser-level navigation
                    // because hash-only changes modify the URL in-place without
                    // navigating:
                    self.history.back();
                    console.warn('Error while trying to present in AR with Scene Viewer');
                    console.warn('Falling back to next ar-mode');
                    this[$selectARMode]();
                // Would be nice to activateAR() here, but webXR fails due to not
                // seeing a user activation.
                }
            };
            self.addEventListener('hashchange', undoHashChange, {
                once: true
            });
            this[$arAnchor].setAttribute('href', intent);
            console.log('Attempting to present in AR with Scene Viewer...');
            this[$arAnchor].click();
        }
        /**
         * Takes a URL to a USDZ file and sets the appropriate fields so that
         * Safari iOS can intent to their AR Quick Look.
         */ async [$openIOSARQuickLook]() {
            const generateUsdz = !this.iosSrc;
            this[$arButtonContainer].classList.remove('enabled');
            const objectURL = generateUsdz ? await this.prepareUSDZ() : this.iosSrc;
            const modelUrl = new URL(objectURL, self.location.toString());
            if (generateUsdz) {
                const location = self.location.toString();
                const locationUrl = new URL(location);
                const srcUrl = new URL(this.src, locationUrl);
                if (srcUrl.hash) {
                    modelUrl.hash = srcUrl.hash;
                }
            }
            if (this.arScale === 'fixed') {
                if (modelUrl.hash) {
                    modelUrl.hash += '&';
                }
                modelUrl.hash += 'allowsContentScaling=0';
            }
            const anchor = this[$arAnchor];
            anchor.setAttribute('rel', 'ar');
            const img = document.createElement('img');
            anchor.appendChild(img);
            anchor.setAttribute('href', modelUrl.toString());
            if (generateUsdz) {
                anchor.setAttribute('download', 'model.usdz');
            }
            // attach anchor to shadow DOM to ensure iOS16 ARQL banner click message event propagation 
            anchor.style.display = 'none';
            if (!anchor.isConnected) this.shadowRoot.appendChild(anchor);
            console.log('Attempting to present in AR with Quick Look...');
            anchor.click();
            anchor.removeChild(img);
            if (generateUsdz) {
                URL.revokeObjectURL(objectURL);
            }
            this[$arButtonContainer].classList.add('enabled');
        }
        async prepareUSDZ() {
            const updateSourceProgress = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$progressTracker"]].beginActivity();
            await this[$triggerLoad]();
            const { model, shadow } = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            if (model == null) {
                return '';
            }
            let visible = false;
            // Remove shadow from export
            if (shadow != null) {
                visible = shadow.visible;
                shadow.visible = false;
            }
            updateSourceProgress(0.2);
            const exporter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$examples$2f$jsm$2f$exporters$2f$USDZExporter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["USDZExporter"]();
            const arraybuffer = await exporter.parse(model);
            const blob = new Blob([
                arraybuffer
            ], {
                type: 'model/vnd.usdz+zip'
            });
            const url = URL.createObjectURL(blob);
            updateSourceProgress(1);
            if (shadow != null) {
                shadow.visible = visible;
            }
            return url;
        }
    }
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'ar'
        })
    ], ARModelViewerElement.prototype, "ar", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'ar-scale'
        })
    ], ARModelViewerElement.prototype, "arScale", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'ar-placement'
        })
    ], ARModelViewerElement.prototype, "arPlacement", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'ar-modes'
        })
    ], ARModelViewerElement.prototype, "arModes", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'ios-src'
        })
    ], ARModelViewerElement.prototype, "iosSrc", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'xr-environment'
        })
    ], ARModelViewerElement.prototype, "xrEnvironment", void 0);
    return ARModelViewerElement;
}; //# sourceMappingURL=ar.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/styles/evaluators.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "CalcEvaluator": (()=>CalcEvaluator),
    "EnvEvaluator": (()=>EnvEvaluator),
    "Evaluator": (()=>Evaluator),
    "OperatorEvaluator": (()=>OperatorEvaluator),
    "PercentageEvaluator": (()=>PercentageEvaluator),
    "StyleEvaluator": (()=>StyleEvaluator)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var _a, _b, _c;
;
;
const $evaluate = Symbol('evaluate');
const $lastValue = Symbol('lastValue');
class Evaluator {
    constructor(){
        this[_a] = null;
    }
    /**
     * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode
     * as the result of invoking its evaluate method. This is mainly used to
     * ensure that CSS function nodes are cast to the corresponding Evaluators
     * that will resolve the result of the function, but is also used to ensure
     * that a percentage nested at arbitrary depth in the expression will always
     * be evaluated against the correct basis.
     */ static evaluatableFor(node, basis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"]) {
        if (node instanceof Evaluator) {
            return node;
        }
        if (node.type === 'number') {
            if (node.unit === '%') {
                return new PercentageEvaluator(node, basis);
            }
            return node;
        }
        switch(node.name.value){
            case 'calc':
                return new CalcEvaluator(node, basis);
            case 'env':
                return new EnvEvaluator(node);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"];
    }
    /**
     * If the input is an Evaluator, returns the result of evaluating it.
     * Otherwise, returns the input.
     *
     * This is a helper to aide in resolving a NumberNode without conditionally
     * checking if the Evaluatable is an Evaluator everywhere.
     */ static evaluate(evaluatable) {
        if (evaluatable instanceof Evaluator) {
            return evaluatable.evaluate();
        }
        return evaluatable;
    }
    /**
     * If the input is an Evaluator, returns the value of its isConstant property.
     * Returns true for all other input values.
     */ static isConstant(evaluatable) {
        if (evaluatable instanceof Evaluator) {
            return evaluatable.isConstant;
        }
        return true;
    }
    /**
     * This method applies a set of structured intrinsic metadata to an evaluated
     * result from a parsed CSS-like string of expressions. Intrinsics provide
     * sufficient metadata (e.g., basis values, analogs for keywords) such that
     * omitted values in the input string can be backfilled, and keywords can be
     * converted to concrete numbers.
     *
     * The result of applying intrinsics is a tuple of NumberNode values whose
     * units match the units used by the basis of the intrinsics.
     *
     * The following is a high-level description of how intrinsics are applied:
     *
     *  1. Determine the value of 'auto' for the current term
     *  2. If there is no corresponding input value for this term, substitute the
     *     'auto' value.
     *  3. If the term is an IdentNode, treat it as a keyword and perform the
     *     appropriate substitution.
     *  4. If the term is still null, fallback to the 'auto' value
     *  5. If the term is a percentage, apply it to the basis and return that
     *     value
     *  6. Normalize the unit of the term
     *  7. If the term's unit does not match the basis unit, return the basis
     *     value
     *  8. Return the term as is
     */ static applyIntrinsics(evaluated, intrinsics) {
        const { basis, keywords } = intrinsics;
        const { auto } = keywords;
        return basis.map((basisNode, index)=>{
            // Use an auto value if we have it, otherwise the auto value is the basis:
            const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];
            // If the evaluated nodes do not have a node at the current
            // index, fallback to the "auto" substitute right away:
            let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode;
            // Any ident node is considered a keyword:
            if (evaluatedNode.type === 'ident') {
                const keyword = evaluatedNode.value;
                // Substitute any keywords for concrete values first:
                if (keyword in keywords) {
                    evaluatedNode = keywords[keyword][index];
                }
            }
            // If we don't have a NumberNode at this point, fall back to whatever
            // is specified for auto:
            if (evaluatedNode == null || evaluatedNode.type === 'ident') {
                evaluatedNode = autoSubstituteNode;
            }
            // For percentages, we always apply the percentage to the basis value:
            if (evaluatedNode.unit === '%') {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);
            }
            // Otherwise, normalize whatever we have:
            evaluatedNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(evaluatedNode, basisNode);
            // If the normalized units do not match, return the basis as a fallback:
            if (evaluatedNode.unit !== basisNode.unit) {
                return basisNode;
            }
            // Finally, return the evaluated node with intrinsics applied:
            return evaluatedNode;
        });
    }
    /**
     * If true, the Evaluator will only evaluate its AST one time. If false, the
     * Evaluator will re-evaluate the AST each time that the public evaluate
     * method is invoked.
     */ get isConstant() {
        return false;
    }
    /**
     * Evaluate the Evaluator and return the result. If the Evaluator is constant,
     * the corresponding AST will only be evaluated once, and the result of
     * evaluating it the first time will be returned on all subsequent
     * evaluations.
     */ evaluate() {
        if (!this.isConstant || this[$lastValue] == null) {
            this[$lastValue] = this[$evaluate]();
        }
        return this[$lastValue];
    }
}
_a = $lastValue;
const $percentage = Symbol('percentage');
const $basis = Symbol('basis');
class PercentageEvaluator extends Evaluator {
    constructor(percentage, basis){
        super();
        this[$percentage] = percentage;
        this[$basis] = basis;
    }
    get isConstant() {
        return true;
    }
    [$evaluate]() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);
    }
}
const $identNode = Symbol('identNode');
class EnvEvaluator extends Evaluator {
    constructor(envFunction){
        super();
        this[_b] = null;
        const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;
        if (identNode != null && identNode.type === 'ident') {
            this[$identNode] = identNode;
        }
    }
    get isConstant() {
        return false;
    }
    [(_b = $identNode, $evaluate)]() {
        if (this[$identNode] != null) {
            switch(this[$identNode].value){
                case 'window-scroll-y':
                    const verticalScrollPosition = window.pageYOffset;
                    const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
                    const scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;
                    return {
                        type: 'number',
                        number: scrollY,
                        unit: null
                    };
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"];
    }
}
const IS_MULTIPLICATION_RE = /[\*\/]/;
const $evaluator = Symbol('evaluator');
class CalcEvaluator extends Evaluator {
    constructor(calcFunction, basis = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"]){
        super();
        this[_c] = null;
        if (calcFunction.arguments.length !== 1) {
            return;
        }
        const terms = calcFunction.arguments[0].terms.slice();
        const secondOrderTerms = [];
        while(terms.length){
            const term = terms.shift();
            if (secondOrderTerms.length > 0) {
                const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];
                if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {
                    const operator = secondOrderTerms.pop();
                    const leftValue = secondOrderTerms.pop();
                    if (leftValue == null) {
                        return;
                    }
                    secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));
                    continue;
                }
            }
            secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));
        }
        while(secondOrderTerms.length > 2){
            const [left, operator, right] = secondOrderTerms.splice(0, 3);
            if (operator.type !== 'operator') {
                return;
            }
            secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));
        }
        // There should only be one combined evaluator at this point:
        if (secondOrderTerms.length === 1) {
            this[$evaluator] = secondOrderTerms[0];
        }
    }
    get isConstant() {
        return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);
    }
    [(_c = $evaluator, $evaluate)]() {
        return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"];
    }
}
const $operator = Symbol('operator');
const $left = Symbol('left');
const $right = Symbol('right');
class OperatorEvaluator extends Evaluator {
    constructor(operator, left, right){
        super();
        this[$operator] = operator;
        this[$left] = left;
        this[$right] = right;
    }
    get isConstant() {
        return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);
    }
    [$evaluate]() {
        const leftNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(Evaluator.evaluate(this[$left]));
        const rightNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(Evaluator.evaluate(this[$right]));
        const { number: leftValue, unit: leftUnit } = leftNode;
        const { number: rightValue, unit: rightUnit } = rightNode;
        // Disallow operations for mismatched normalized units e.g., m and rad:
        if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"];
        }
        // NOTE(cdata): rules for calc type checking are defined here
        // https://drafts.csswg.org/css-values-3/#calc-type-checking
        // This is a simplification and may not hold up once we begin to support
        // additional unit types:
        const unit = leftUnit || rightUnit;
        let value;
        switch(this[$operator].value){
            case '+':
                value = leftValue + rightValue;
                break;
            case '-':
                value = leftValue - rightValue;
                break;
            case '/':
                value = leftValue / rightValue;
                break;
            case '*':
                value = leftValue * rightValue;
                break;
            default:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ZERO"];
        }
        return {
            type: 'number',
            number: value,
            unit
        };
    }
}
const $evaluatables = Symbol('evaluatables');
const $intrinsics = Symbol('intrinsics');
class StyleEvaluator extends Evaluator {
    constructor(expressions, intrinsics){
        super();
        this[$intrinsics] = intrinsics;
        const firstExpression = expressions[0];
        const terms = firstExpression != null ? firstExpression.terms : [];
        this[$evaluatables] = intrinsics.basis.map((basisNode, index)=>{
            const term = terms[index];
            if (term == null) {
                return {
                    type: 'ident',
                    value: 'auto'
                };
            }
            if (term.type === 'ident') {
                return term;
            }
            return Evaluator.evaluatableFor(term, basisNode);
        });
    }
    get isConstant() {
        for (const evaluatable of this[$evaluatables]){
            if (!Evaluator.isConstant(evaluatable)) {
                return false;
            }
        }
        return true;
    }
    [$evaluate]() {
        const evaluated = this[$evaluatables].map((evaluatable)=>Evaluator.evaluate(evaluatable));
        return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map((numberNode)=>numberNode.number);
    }
} //# sourceMappingURL=evaluators.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/styles/style-effector.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "StyleEffector": (()=>StyleEffector)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var _a, _b, _c, _d;
;
const $instances = Symbol('instances');
const $activateListener = Symbol('activateListener');
const $deactivateListener = Symbol('deactivateListener');
const $notifyInstances = Symbol('notifyInstances');
const $notify = Symbol('notify');
const $scrollCallback = Symbol('callback');
/**
 * This internal helper is intended to work as a reference-counting manager of
 * scroll event listeners. Only one scroll listener is ever registered for all
 * instances of the class, and when the last ScrollObserver "disconnects", that
 * event listener is removed. This spares us from thrashing
 * the {add,remove}EventListener API (the binding cost of these methods has been
 * known to show up in performance analyses) as well as potential memory leaks.
 */ class ScrollObserver {
    constructor(callback){
        this[$scrollCallback] = callback;
    }
    static [$notifyInstances]() {
        for (const instance of ScrollObserver[$instances]){
            instance[$notify]();
        }
    }
    static [(_a = $instances, $activateListener)]() {
        window.addEventListener('scroll', this[$notifyInstances], {
            passive: true
        });
    }
    static [$deactivateListener]() {
        window.removeEventListener('scroll', this[$notifyInstances]);
    }
    /**
     * Listen for scroll events. The configured callback (passed to the
     * constructor) will be invoked for subsequent global scroll events.
     */ observe() {
        if (ScrollObserver[$instances].size === 0) {
            ScrollObserver[$activateListener]();
        }
        ScrollObserver[$instances].add(this);
    }
    /**
     * Stop listening for scroll events.
     */ disconnect() {
        ScrollObserver[$instances].delete(this);
        if (ScrollObserver[$instances].size === 0) {
            ScrollObserver[$deactivateListener]();
        }
    }
    [$notify]() {
        this[$scrollCallback]();
    }
}
ScrollObserver[_a] = new Set();
const $computeStyleCallback = Symbol('computeStyleCallback');
const $astWalker = Symbol('astWalker');
const $dependencies = Symbol('dependencies');
const $onScroll = Symbol('onScroll');
class StyleEffector {
    constructor(callback){
        this[_b] = {};
        this[_c] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ASTWalker"]([
            'function'
        ]);
        this[_d] = ()=>{
            this[$computeStyleCallback]({
                relatedState: 'window-scroll'
            });
        };
        this[$computeStyleCallback] = callback;
    }
    /**
     * Sets the expressions that govern when the StyleEffector callback will be
     * invoked.
     */ observeEffectsFor(ast) {
        const newDependencies = {};
        const oldDependencies = this[$dependencies];
        this[$astWalker].walk(ast, (functionNode)=>{
            const { name } = functionNode;
            const firstArgument = functionNode.arguments[0];
            const firstTerm = firstArgument.terms[0];
            if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {
                return;
            }
            switch(firstTerm.value){
                case 'window-scroll-y':
                    if (newDependencies['window-scroll'] == null) {
                        const observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(this[$onScroll]);
                        observer.observe();
                        delete oldDependencies['window-scroll'];
                        newDependencies['window-scroll'] = observer;
                    }
                    break;
            }
        });
        for(const environmentState in oldDependencies){
            const observer = oldDependencies[environmentState];
            observer.disconnect();
        }
        this[$dependencies] = newDependencies;
    }
    /**
     * Disposes of the StyleEffector by disconnecting all observers of external
     * effects.
     */ dispose() {
        for(const environmentState in this[$dependencies]){
            const observer = this[$dependencies][environmentState];
            observer.disconnect();
        }
    }
}
_b = $dependencies, _c = $astWalker, _d = $onScroll; //# sourceMappingURL=style-effector.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/decorators.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "style": (()=>style)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$evaluators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/evaluators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$style$2d$effector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/style-effector.js [app-client] (ecmascript)");
;
;
;
const style = (config)=>{
    const observeEffects = config.observeEffects || false;
    const getIntrinsics = config.intrinsics instanceof Function ? config.intrinsics : ()=>config.intrinsics;
    return (proto, propertyName)=>{
        const originalUpdated = proto.updated;
        const originalConnectedCallback = proto.connectedCallback;
        const originalDisconnectedCallback = proto.disconnectedCallback;
        const $styleEffector = Symbol(`${propertyName}StyleEffector`);
        const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);
        const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);
        const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);
        Object.defineProperties(proto, {
            [$styleEffector]: {
                value: null,
                writable: true
            },
            [$styleEvaluator]: {
                value: null,
                writable: true
            },
            [$updateEvaluator]: {
                value: function() {
                    const ast = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(this[propertyName]);
                    this[$styleEvaluator] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$evaluators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleEvaluator"](ast, getIntrinsics(this));
                    if (this[$styleEffector] == null && observeEffects) {
                        this[$styleEffector] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$style$2d$effector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleEffector"](()=>this[$evaluateAndSync]());
                    }
                    if (this[$styleEffector] != null) {
                        this[$styleEffector].observeEffectsFor(ast);
                    }
                }
            },
            [$evaluateAndSync]: {
                value: function() {
                    if (this[$styleEvaluator] == null) {
                        return;
                    }
                    const result = this[$styleEvaluator].evaluate();
                    // @see https://github.com/microsoft/TypeScript/pull/30769
                    // @see https://github.com/Microsoft/TypeScript/issues/1863
                    this[config.updateHandler](result);
                }
            },
            updated: {
                value: function(changedProperties) {
                    // Always invoke updates to styles first. This gives a class that
                    // uses this decorator the opportunity to override the effect, or
                    // respond to it, in its own implementation of `updated`.
                    if (changedProperties.has(propertyName)) {
                        this[$updateEvaluator]();
                        this[$evaluateAndSync]();
                    }
                    originalUpdated.call(this, changedProperties);
                }
            },
            connectedCallback: {
                value: function() {
                    originalConnectedCallback.call(this);
                    this.requestUpdate(propertyName, this[propertyName]);
                }
            },
            disconnectedCallback: {
                value: function() {
                    originalDisconnectedCallback.call(this);
                    if (this[$styleEffector] != null) {
                        this[$styleEffector].dispose();
                        this[$styleEffector] = null;
                    }
                }
            }
        });
    };
}; //# sourceMappingURL=decorators.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/three-components/SmoothControls.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ChangeSource": (()=>ChangeSource),
    "DEFAULT_OPTIONS": (()=>DEFAULT_OPTIONS),
    "KeyCode": (()=>KeyCode),
    "SmoothControls": (()=>SmoothControls)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/controls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)");
;
;
;
;
const PAN_SENSITIVITY = 0.018;
const TAP_DISTANCE = 2;
const TAP_MS = 300;
const vector2 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector2"]();
const vector3 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]();
const DEFAULT_OPTIONS = Object.freeze({
    minimumRadius: 0,
    maximumRadius: Infinity,
    minimumPolarAngle: Math.PI / 8,
    maximumPolarAngle: Math.PI - Math.PI / 8,
    minimumAzimuthalAngle: -Infinity,
    maximumAzimuthalAngle: Infinity,
    minimumFieldOfView: 10,
    maximumFieldOfView: 45,
    touchAction: 'none'
});
// Constants
const KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;
const ZOOM_SENSITIVITY = 0.04;
// The move size on pan key event
const PAN_KEY_INCREMENT = 10;
const KeyCode = {
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40
};
const ChangeSource = {
    USER_INTERACTION: 'user-interaction',
    NONE: 'none',
    AUTOMATIC: 'automatic'
};
class SmoothControls extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EventDispatcher"] {
    constructor(camera, element, scene){
        super();
        this.camera = camera;
        this.element = element;
        this.scene = scene;
        this.orbitSensitivity = 1;
        this.inputSensitivity = 1;
        this.changeSource = ChangeSource.NONE;
        this._interactionEnabled = false;
        this._disableZoom = false;
        this.isUserPointing = false;
        // Pan state
        this.enablePan = true;
        this.enableTap = true;
        this.panProjection = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix3"]();
        this.panPerPixel = 0;
        // Internal orbital position state
        this.spherical = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]();
        this.goalSpherical = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]();
        this.thetaDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.phiDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.radiusDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);
        this.goalLogFov = this.logFov;
        this.fovDamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Damper"]();
        // Pointer state
        this.touchMode = null;
        this.pointers = [];
        this.startTime = 0;
        this.startPointerPosition = {
            clientX: 0,
            clientY: 0
        };
        this.lastSeparation = 0;
        this.touchDecided = false;
        this.onContext = (event)=>{
            if (this.enablePan) {
                event.preventDefault();
            } else {
                for (const pointer of this.pointers){
                    // Required because of a common browser bug where the context menu never
                    // fires a pointercancel event.
                    this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), {
                        pointerId: pointer.id
                    })));
                }
            }
        };
        this.touchModeZoom = (dx, dy)=>{
            if (!this._disableZoom) {
                const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);
                const deltaZoom = ZOOM_SENSITIVITY * (this.lastSeparation - touchDistance) * 50 / this.scene.height;
                this.lastSeparation = touchDistance;
                this.userAdjustOrbit(0, 0, deltaZoom);
            }
            if (this.panPerPixel > 0) {
                this.movePan(dx, dy);
            }
        };
        // We implement our own version of the browser's CSS touch-action, enforced by
        // this function, because the iOS implementation of pan-y is bad and doesn't
        // match Android. Specifically, even if a touch gesture begins by panning X,
        // iOS will switch to scrolling as soon as the gesture moves in the Y, rather
        // than staying in the same mode until the end of the gesture.
        this.disableScroll = (event)=>{
            event.preventDefault();
        };
        this.touchModeRotate = (dx, dy)=>{
            const { touchAction } = this._options;
            if (!this.touchDecided && touchAction !== 'none') {
                this.touchDecided = true;
                const dxMag = Math.abs(dx);
                const dyMag = Math.abs(dy);
                // If motion is mostly vertical, assume scrolling is the intent.
                if (this.changeSource === ChangeSource.USER_INTERACTION && (touchAction === 'pan-y' && dyMag > dxMag || touchAction === 'pan-x' && dxMag > dyMag)) {
                    this.touchMode = null;
                    return;
                } else {
                    this.element.addEventListener('touchmove', this.disableScroll, {
                        passive: false
                    });
                }
            }
            this.handleSinglePointerMove(dx, dy);
        };
        this.onPointerDown = (event)=>{
            if (this.pointers.length > 2) {
                return;
            }
            const { element } = this;
            if (this.pointers.length === 0) {
                element.addEventListener('pointermove', this.onPointerMove);
                element.addEventListener('pointerup', this.onPointerUp);
                this.touchMode = null;
                this.touchDecided = false;
                this.startPointerPosition.clientX = event.clientX;
                this.startPointerPosition.clientY = event.clientY;
                this.startTime = performance.now();
            }
            try {
                element.setPointerCapture(event.pointerId);
            } catch (_a) {}
            this.pointers.push({
                clientX: event.clientX,
                clientY: event.clientY,
                id: event.pointerId
            });
            this.isUserPointing = false;
            if (event.pointerType === 'touch') {
                this.changeSource = event.altKey ? ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;
                this.onTouchChange(event);
            } else {
                this.changeSource = ChangeSource.USER_INTERACTION;
                this.onMouseDown(event);
            }
        };
        this.onPointerMove = (event)=>{
            const pointer = this.pointers.find((pointer)=>pointer.id === event.pointerId);
            if (pointer == null) {
                return;
            }
            const numTouches = this.pointers.length;
            const dx = (event.clientX - pointer.clientX) / numTouches;
            const dy = (event.clientY - pointer.clientY) / numTouches;
            if (dx === 0 && dy === 0) {
                return;
            }
            pointer.clientX = event.clientX;
            pointer.clientY = event.clientY;
            if (event.pointerType === 'touch') {
                this.changeSource = event.altKey ? ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;
                if (this.touchMode !== null) {
                    this.touchMode(dx, dy);
                }
            } else {
                this.changeSource = ChangeSource.USER_INTERACTION;
                if (this.panPerPixel > 0) {
                    this.movePan(dx, dy);
                } else {
                    this.handleSinglePointerMove(dx, dy);
                }
            }
        };
        this.onPointerUp = (event)=>{
            const { element } = this;
            const index = this.pointers.findIndex((pointer)=>pointer.id === event.pointerId);
            if (index !== -1) {
                this.pointers.splice(index, 1);
            }
            // altKey indicates an interaction prompt; don't reset radius in this case
            // as it will cause the camera to drift.
            if (this.panPerPixel > 0 && !event.altKey) {
                this.resetRadius();
            }
            if (this.pointers.length === 0) {
                element.removeEventListener('pointermove', this.onPointerMove);
                element.removeEventListener('pointerup', this.onPointerUp);
                element.removeEventListener('touchmove', this.disableScroll);
                if (this.enablePan && this.enableTap) {
                    this.recenter(event);
                }
            } else if (this.touchMode !== null) {
                this.onTouchChange(event);
            }
            this.scene.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$panElement"]].style.opacity = 0;
            element.style.cursor = 'grab';
            this.panPerPixel = 0;
            if (this.isUserPointing) {
                this.dispatchEvent({
                    type: 'pointer-change-end'
                });
            }
        };
        this.onWheel = (event)=>{
            this.changeSource = ChangeSource.USER_INTERACTION;
            const deltaZoom = event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY / 30;
            this.userAdjustOrbit(0, 0, deltaZoom);
            event.preventDefault();
        };
        this.onKeyDown = (event)=>{
            // We track if the key is actually one we respond to, so as not to
            // accidentally clobber unrelated key inputs when the <model-viewer> has
            // focus.
            const { changeSource } = this;
            this.changeSource = ChangeSource.USER_INTERACTION;
            const relevantKey = event.shiftKey && this.enablePan ? this.panKeyCodeHandler(event) : this.orbitZoomKeyCodeHandler(event);
            if (relevantKey) {
                event.preventDefault();
            } else {
                this.changeSource = changeSource;
            }
        };
        this._options = Object.assign({}, DEFAULT_OPTIONS);
        this.setOrbit(0, Math.PI / 2, 1);
        this.setFieldOfView(100);
        this.jumpToGoal();
    }
    get interactionEnabled() {
        return this._interactionEnabled;
    }
    enableInteraction() {
        if (this._interactionEnabled === false) {
            const { element } = this;
            element.addEventListener('pointerdown', this.onPointerDown);
            element.addEventListener('pointercancel', this.onPointerUp);
            if (!this._disableZoom) {
                element.addEventListener('wheel', this.onWheel);
            }
            element.addEventListener('keydown', this.onKeyDown);
            // This little beauty is to work around a WebKit bug that otherwise makes
            // touch events randomly not cancelable.
            element.addEventListener('touchmove', ()=>{}, {
                passive: false
            });
            element.addEventListener('contextmenu', this.onContext);
            this.element.style.cursor = 'grab';
            this._interactionEnabled = true;
            this.updateTouchActionStyle();
        }
    }
    disableInteraction() {
        if (this._interactionEnabled === true) {
            const { element } = this;
            element.removeEventListener('pointerdown', this.onPointerDown);
            element.removeEventListener('pointermove', this.onPointerMove);
            element.removeEventListener('pointerup', this.onPointerUp);
            element.removeEventListener('pointercancel', this.onPointerUp);
            element.removeEventListener('wheel', this.onWheel);
            element.removeEventListener('keydown', this.onKeyDown);
            element.removeEventListener('contextmenu', this.onContext);
            element.style.cursor = '';
            this.touchMode = null;
            this._interactionEnabled = false;
            this.updateTouchActionStyle();
        }
    }
    /**
     * The options that are currently configured for the controls instance.
     */ get options() {
        return this._options;
    }
    set disableZoom(disable) {
        if (this._disableZoom != disable) {
            this._disableZoom = disable;
            if (disable === true) {
                this.element.removeEventListener('wheel', this.onWheel);
            } else {
                this.element.addEventListener('wheel', this.onWheel);
            }
            this.updateTouchActionStyle();
        }
    }
    /**
     * Copy the spherical values that represent the current camera orbital
     * position relative to the configured target into a provided Spherical
     * instance. If no Spherical is provided, a new Spherical will be allocated
     * to copy the values into. The Spherical that values are copied into is
     * returned.
     */ getCameraSpherical(target = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]()) {
        return target.copy(this.spherical);
    }
    /**
     * Returns the camera's current vertical field of view in degrees.
     */ getFieldOfView() {
        return this.camera.fov;
    }
    /**
     * Configure the _options of the controls. Configured _options will be
     * merged with whatever _options have already been configured for this
     * controls instance.
     */ applyOptions(_options) {
        Object.assign(this._options, _options);
        // Re-evaluates clamping based on potentially new values for min/max
        // polar, azimuth and radius:
        this.setOrbit();
        this.setFieldOfView(Math.exp(this.goalLogFov));
    }
    /**
     * Sets the near and far planes of the camera.
     */ updateNearFar(nearPlane, farPlane) {
        this.camera.near = Math.max(nearPlane, farPlane / 1000);
        this.camera.far = farPlane;
        this.camera.updateProjectionMatrix();
    }
    /**
     * Sets the aspect ratio of the camera
     */ updateAspect(aspect) {
        this.camera.aspect = aspect;
        this.camera.updateProjectionMatrix();
    }
    /**
     * Set the absolute orbital goal of the camera. The change will be
     * applied over a number of frames depending on configured acceleration and
     * dampening _options.
     *
     * Returns true if invoking the method will result in the camera changing
     * position and/or rotation, otherwise false.
     */ setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {
        const { minimumAzimuthalAngle, maximumAzimuthalAngle, minimumPolarAngle, maximumPolarAngle, minimumRadius, maximumRadius } = this._options;
        const { theta, phi, radius } = this.goalSpherical;
        const nextTheta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);
        if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {
            this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;
        }
        const nextPhi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(goalPhi, minimumPolarAngle, maximumPolarAngle);
        const nextRadius = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(goalRadius, minimumRadius, maximumRadius);
        if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {
            return false;
        }
        this.goalSpherical.theta = nextTheta;
        this.goalSpherical.phi = nextPhi;
        this.goalSpherical.radius = nextRadius;
        this.goalSpherical.makeSafe();
        return true;
    }
    /**
     * Subset of setOrbit() above, which only sets the camera's radius.
     */ setRadius(radius) {
        this.goalSpherical.radius = radius;
        this.setOrbit();
    }
    /**
     * Sets the goal field of view for the camera
     */ setFieldOfView(fov) {
        const { minimumFieldOfView, maximumFieldOfView } = this._options;
        fov = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(fov, minimumFieldOfView, maximumFieldOfView);
        this.goalLogFov = Math.log(fov);
    }
    /**
     * Sets the smoothing decay time.
     */ setDamperDecayTime(decayMilliseconds) {
        this.thetaDamper.setDecayTime(decayMilliseconds);
        this.phiDamper.setDecayTime(decayMilliseconds);
        this.radiusDamper.setDecayTime(decayMilliseconds);
        this.fovDamper.setDecayTime(decayMilliseconds);
    }
    /**
     * Adjust the orbital position of the camera relative to its current orbital
     * position. Does not let the theta goal get more than pi ahead of the current
     * theta, which ensures interpolation continues in the direction of the delta.
     * The deltaZoom parameter adjusts both the field of view and the orbit radius
     * such that they progress across their allowed ranges in sync.
     */ adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
        const { theta, phi, radius } = this.goalSpherical;
        const { minimumRadius, maximumRadius, minimumFieldOfView, maximumFieldOfView } = this._options;
        const dTheta = this.spherical.theta - theta;
        const dThetaLimit = Math.PI - 0.001;
        const goalTheta = theta - (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);
        const goalPhi = phi - deltaPhi;
        const deltaRatio = deltaZoom === 0 ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov);
        const goalRadius = radius + deltaZoom * (isFinite(deltaRatio) ? deltaRatio : (maximumRadius - minimumRadius) * 2);
        this.setOrbit(goalTheta, goalPhi, goalRadius);
        if (deltaZoom !== 0) {
            const goalLogFov = this.goalLogFov + deltaZoom;
            this.setFieldOfView(Math.exp(goalLogFov));
        }
    }
    /**
     * Move the camera instantly instead of accelerating toward the goal
     * parameters.
     */ jumpToGoal() {
        this.update(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SETTLING_TIME"]);
    }
    /**
     * Update controls. In most cases, this will result in the camera
     * interpolating its position and rotation until it lines up with the
     * designated goal orbital position.
     *
     * Time and delta are measured in milliseconds.
     */ update(_time, delta) {
        if (this.isStationary()) {
            return;
        }
        const { maximumPolarAngle, maximumRadius } = this._options;
        const dTheta = this.spherical.theta - this.goalSpherical.theta;
        if (Math.abs(dTheta) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle)) {
            this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;
        }
        this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);
        this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);
        this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);
        this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);
        this.moveCamera();
    }
    updateTouchActionStyle() {
        const { style } = this.element;
        if (this._interactionEnabled) {
            const { touchAction } = this._options;
            if (this._disableZoom && touchAction !== 'none') {
                style.touchAction = 'manipulation';
            } else {
                style.touchAction = touchAction;
            }
        } else {
            style.touchAction = '';
        }
    }
    isStationary() {
        return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
    }
    dispatchChange() {
        this.dispatchEvent({
            type: 'change',
            source: this.changeSource
        });
    }
    moveCamera() {
        // Derive the new camera position from the updated spherical:
        this.spherical.makeSafe();
        this.camera.position.setFromSpherical(this.spherical);
        this.camera.setRotationFromEuler(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Euler"](this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));
        if (this.camera.fov !== Math.exp(this.logFov)) {
            this.camera.fov = Math.exp(this.logFov);
            this.camera.updateProjectionMatrix();
        }
        this.dispatchChange();
    }
    userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
        this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);
        // Always make sure that an initial event is triggered in case there is
        // contention between user interaction and imperative changes. This initial
        // event will give external observers that chance to observe that
        // interaction occurred at all:
        this.dispatchChange();
    }
    // Wraps to between -pi and pi
    wrapAngle(radians) {
        const normalized = (radians + Math.PI) / (2 * Math.PI);
        const wrapped = normalized - Math.floor(normalized);
        return wrapped * 2 * Math.PI - Math.PI;
    }
    pixelLengthToSphericalAngle(pixelLength) {
        return 2 * Math.PI * pixelLength / this.element.clientHeight;
    }
    twoTouchDistance(touchOne, touchTwo) {
        const { clientX: xOne, clientY: yOne } = touchOne;
        const { clientX: xTwo, clientY: yTwo } = touchTwo;
        const xDelta = xTwo - xOne;
        const yDelta = yTwo - yOne;
        return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
    }
    handleSinglePointerMove(dx, dy) {
        const deltaTheta = this.pixelLengthToSphericalAngle(dx);
        const deltaPhi = this.pixelLengthToSphericalAngle(dy);
        if (this.isUserPointing === false) {
            this.isUserPointing = true;
            this.dispatchEvent({
                type: 'pointer-change-start'
            });
        }
        this.userAdjustOrbit(deltaTheta, deltaPhi, 0);
    }
    initializePan() {
        const { theta, phi } = this.spherical;
        const psi = theta - this.scene.yaw;
        this.panPerPixel = PAN_SENSITIVITY / this.scene.height;
        this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);
    }
    movePan(dx, dy) {
        const { scene } = this;
        const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);
        const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
        dxy.multiplyScalar(metersPerPixel);
        const target = scene.getTarget();
        target.add(dxy.applyMatrix3(this.panProjection));
        scene.boundingSphere.clampPoint(target, target);
        scene.setTarget(target.x, target.y, target.z);
        this.dispatchChange();
    }
    recenter(pointer) {
        if (performance.now() > this.startTime + TAP_MS || Math.abs(pointer.clientX - this.startPointerPosition.clientX) > TAP_DISTANCE || Math.abs(pointer.clientY - this.startPointerPosition.clientY) > TAP_DISTANCE) {
            return;
        }
        const { scene } = this;
        const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));
        if (hit == null) {
            const { cameraTarget } = scene.element;
            scene.element.cameraTarget = '';
            scene.element.cameraTarget = cameraTarget;
            // Zoom all the way out.
            this.userAdjustOrbit(0, 0, 1);
        } else {
            scene.target.worldToLocal(hit.position);
            scene.setTarget(hit.position.x, hit.position.y, hit.position.z);
        }
    }
    resetRadius() {
        const { scene } = this;
        const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));
        if (hit == null) {
            return;
        }
        scene.target.worldToLocal(hit.position);
        const goalTarget = scene.getTarget();
        const { theta, phi } = this.spherical;
        // Set target to surface hit point, except the target is still settling,
        // so offset the goal accordingly so the transition is smooth even though
        // this will drift the target slightly away from the hit point.
        const psi = theta - scene.yaw;
        const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));
        const dr = n.dot(hit.position.sub(goalTarget));
        goalTarget.add(n.multiplyScalar(dr));
        scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);
        // Change the camera radius to match the change in target so that the
        // camera itself does not move, unless it hits a radius bound.
        this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);
    }
    onTouchChange(event) {
        if (this.pointers.length === 1) {
            this.touchMode = this.touchModeRotate;
        } else {
            if (this._disableZoom) {
                this.touchMode = null;
                this.element.removeEventListener('touchmove', this.disableScroll);
                return;
            }
            this.touchMode = this.touchDecided && this.touchMode === null ? null : this.touchModeZoom;
            this.touchDecided = true;
            this.element.addEventListener('touchmove', this.disableScroll, {
                passive: false
            });
            this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]);
            if (this.enablePan && this.touchMode != null) {
                this.initializePan();
                if (!event.altKey) {
                    this.scene.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$panElement"]].style.opacity = 1;
                }
            }
        }
    }
    onMouseDown(event) {
        this.panPerPixel = 0;
        if (this.enablePan && (event.button === 2 || event.ctrlKey || event.metaKey || event.shiftKey)) {
            this.initializePan();
            this.scene.element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$panElement"]].style.opacity = 1;
        }
        this.element.style.cursor = 'grabbing';
    }
    /**
     * Handles the orbit and Zoom key presses
     * Uses constants for the increment.
     * @param event The keyboard event for the .key value
     * @returns boolean to indicate if the key event has been handled
     */ orbitZoomKeyCodeHandler(event) {
        let relevantKey = true;
        switch(event.key){
            case 'PageUp':
                this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY);
                break;
            case 'PageDown':
                this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY);
                break;
            case 'ArrowUp':
                this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);
                break;
            case 'ArrowDown':
                this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);
                break;
            case 'ArrowLeft':
                this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);
                break;
            case 'ArrowRight':
                this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);
                break;
            default:
                relevantKey = false;
                break;
        }
        return relevantKey;
    }
    /**
     * Handles the Pan key presses
     * Uses constants for the increment.
     * @param event The keyboard event for the .key value
     * @returns boolean to indicate if the key event has been handled
     */ panKeyCodeHandler(event) {
        this.initializePan();
        let relevantKey = true;
        switch(event.key){
            case 'ArrowUp':
                this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the
                break;
            case 'ArrowDown':
                this.movePan(0, PAN_KEY_INCREMENT);
                break;
            case 'ArrowLeft':
                this.movePan(-1 * PAN_KEY_INCREMENT, 0);
                break;
            case 'ArrowRight':
                this.movePan(PAN_KEY_INCREMENT, 0);
                break;
            default:
                relevantKey = false;
                break;
        }
        return relevantKey;
    }
} //# sourceMappingURL=SmoothControls.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities/animation.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "easeInOutQuad": (()=>easeInOutQuad),
    "interpolate": (()=>interpolate),
    "sequence": (()=>sequence),
    "timeline": (()=>timeline)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
;
const easeInOutQuad = (t)=>t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
const interpolate = (start, end, ease = easeInOutQuad)=>(time)=>start + (end - start) * ease(time);
const sequence = (tracks, weights)=>{
    const cumulativeSum = (sum)=>(value)=>sum += value;
    const times = weights.map(cumulativeSum(0));
    return (time)=>{
        time = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clamp"])(time, 0, 1);
        time *= times[times.length - 1];
        const i = times.findIndex((val)=>val >= time);
        const start = i < 1 ? 0 : times[i - 1];
        const end = times[i];
        return tracks[i]((time - start) / (end - start));
    };
};
const timeline = (path)=>{
    const tracks = [];
    const weights = [];
    let lastValue = path.initialValue;
    for(let i = 0; i < path.keyframes.length; ++i){
        const keyframe = path.keyframes[i];
        const { value, frames } = keyframe;
        const ease = keyframe.ease || easeInOutQuad;
        const track = interpolate(lastValue, value, ease);
        tracks.push(track);
        weights.push(frames);
        lastValue = value;
    }
    return sequence(tracks, weights);
}; //# sourceMappingURL=animation.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/controls.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$controls": (()=>$controls),
    "$fingerAnimatedContainers": (()=>$fingerAnimatedContainers),
    "$panElement": (()=>$panElement),
    "$promptAnimatedContainer": (()=>$promptAnimatedContainer),
    "$promptElement": (()=>$promptElement),
    "ControlsMixin": (()=>ControlsMixin),
    "DEFAULT_CAMERA_ORBIT": (()=>DEFAULT_CAMERA_ORBIT),
    "DEFAULT_FOV_DEG": (()=>DEFAULT_FOV_DEG),
    "DEFAULT_INTERACTION_PROMPT_THRESHOLD": (()=>DEFAULT_INTERACTION_PROMPT_THRESHOLD),
    "DEFAULT_MIN_FOV_DEG": (()=>DEFAULT_MIN_FOV_DEG),
    "INTERACTION_PROMPT": (()=>INTERACTION_PROMPT),
    "InteractionPromptStrategy": (()=>InteractionPromptStrategy),
    "InteractionPromptStyle": (()=>InteractionPromptStyle),
    "TouchAction": (()=>TouchAction),
    "cameraOrbitIntrinsics": (()=>cameraOrbitIntrinsics),
    "cameraTargetIntrinsics": (()=>cameraTargetIntrinsics),
    "fieldOfViewIntrinsics": (()=>fieldOfViewIntrinsics)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/decorators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$evaluators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/evaluators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Damper.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/SmoothControls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities/animation.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
;
;
;
;
;
;
;
// NOTE(cdata): The following "animation" timing functions are deliberately
// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations
// would cause the interaction prompt to glitch unexpectedly
// @see https://github.com/google/model-viewer/issues/839
const PROMPT_ANIMATION_TIME = 5000;
// For timing purposes, a "frame" is a timing agnostic relative unit of time
// and a "value" is a target value for the Frame.
const wiggle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])({
    initialValue: 0,
    keyframes: [
        {
            frames: 5,
            value: -1
        },
        {
            frames: 1,
            value: -1
        },
        {
            frames: 8,
            value: 1
        },
        {
            frames: 1,
            value: 1
        },
        {
            frames: 5,
            value: 0
        },
        {
            frames: 18,
            value: 0
        }
    ]
});
const fade = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])({
    initialValue: 0,
    keyframes: [
        {
            frames: 1,
            value: 1
        },
        {
            frames: 5,
            value: 1
        },
        {
            frames: 1,
            value: 0
        },
        {
            frames: 6,
            value: 0
        }
    ]
});
const DEFAULT_FOV_DEG = 30;
const DEFAULT_MIN_FOV_DEG = 12;
const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';
const DEFAULT_CAMERA_TARGET = 'auto auto auto';
const DEFAULT_FIELD_OF_VIEW = 'auto';
const MINIMUM_RADIUS_RATIO = 2.2;
const AZIMUTHAL_QUADRANT_LABELS = [
    'front',
    'right',
    'back',
    'left'
];
const POLAR_TRIENT_LABELS = [
    'upper-',
    '',
    'lower-'
];
const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;
const INTERACTION_PROMPT = '. Use mouse, touch or arrow keys to move.';
const InteractionPromptStrategy = {
    AUTO: 'auto',
    NONE: 'none'
};
const InteractionPromptStyle = {
    BASIC: 'basic',
    WIGGLE: 'wiggle'
};
const TouchAction = {
    PAN_Y: 'pan-y',
    PAN_X: 'pan-x',
    NONE: 'none'
};
const fieldOfViewIntrinsics = ()=>{
    return {
        basis: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(DEFAULT_FOV_DEG, 'deg'))
        ],
        keywords: {
            auto: [
                null
            ]
        }
    };
};
const minFieldOfViewIntrinsics = ()=>{
    return {
        basis: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(DEFAULT_MIN_FOV_DEG, 'deg'))
        ],
        keywords: {
            auto: [
                null
            ]
        }
    };
};
const cameraOrbitIntrinsics = (()=>{
    const defaultTerms = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseExpressions"])(DEFAULT_CAMERA_ORBIT)[0].terms;
    const theta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(defaultTerms[0]);
    const phi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizeUnit"])(defaultTerms[1]);
    return (element)=>{
        const radius = element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].idealCameraDistance();
        return {
            basis: [
                theta,
                phi,
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(radius, 'm')
            ],
            keywords: {
                auto: [
                    null,
                    null,
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(105, '%')
                ]
            }
        };
    };
})();
const minCameraOrbitIntrinsics = (element)=>{
    const radius = MINIMUM_RADIUS_RATIO * element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].boundingSphere.radius;
    return {
        basis: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(-Infinity, 'rad'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(Math.PI / 8, 'rad'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(radius, 'm')
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
};
const maxCameraOrbitIntrinsics = (element)=>{
    const orbitIntrinsics = cameraOrbitIntrinsics(element);
    const evaluator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$evaluators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StyleEvaluator"]([], orbitIntrinsics);
    const defaultRadius = evaluator.evaluate()[2];
    return {
        basis: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(Infinity, 'rad'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(Math.PI - Math.PI / 8, 'rad'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(defaultRadius, 'm')
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
};
const cameraTargetIntrinsics = (element)=>{
    const center = element[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].boundingBox.getCenter(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]());
    return {
        basis: [
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(center.x, 'm'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(center.y, 'm'),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(center.z, 'm')
        ],
        keywords: {
            auto: [
                null,
                null,
                null
            ]
        }
    };
};
const HALF_PI = Math.PI / 2.0;
const THIRD_PI = Math.PI / 3.0;
const QUARTER_PI = HALF_PI / 2.0;
const TAU = 2.0 * Math.PI;
const $controls = Symbol('controls');
const $panElement = Symbol('panElement');
const $promptElement = Symbol('promptElement');
const $promptAnimatedContainer = Symbol('promptAnimatedContainer');
const $fingerAnimatedContainers = Symbol('fingerAnimatedContainers');
const $deferInteractionPrompt = Symbol('deferInteractionPrompt');
const $updateAria = Symbol('updateAria');
const $updateCameraForRadius = Symbol('updateCameraForRadius');
const $onChange = Symbol('onChange');
const $onPointerChange = Symbol('onPointerChange');
const $waitingToPromptUser = Symbol('waitingToPromptUser');
const $userHasInteracted = Symbol('userHasInteracted');
const $promptElementVisibleTime = Symbol('promptElementVisibleTime');
const $lastPromptOffset = Symbol('lastPromptOffset');
const $lastSpherical = Symbol('lastSpherical');
const $jumpCamera = Symbol('jumpCamera');
const $initialized = Symbol('initialized');
const $maintainThetaPhi = Symbol('maintainThetaPhi');
const $syncCameraOrbit = Symbol('syncCameraOrbit');
const $syncFieldOfView = Symbol('syncFieldOfView');
const $syncCameraTarget = Symbol('syncCameraTarget');
const $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');
const $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');
const $syncMinFieldOfView = Symbol('syncMinFieldOfView');
const $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');
const ControlsMixin = (ModelViewerElement)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    class ControlsModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this.cameraControls = false;
            this.cameraOrbit = DEFAULT_CAMERA_ORBIT;
            this.cameraTarget = DEFAULT_CAMERA_TARGET;
            this.fieldOfView = DEFAULT_FIELD_OF_VIEW;
            this.minCameraOrbit = 'auto';
            this.maxCameraOrbit = 'auto';
            this.minFieldOfView = 'auto';
            this.maxFieldOfView = 'auto';
            this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;
            this.interactionPrompt = InteractionPromptStrategy.AUTO;
            this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;
            this.orbitSensitivity = 1;
            this.touchAction = TouchAction.NONE;
            this.disableZoom = false;
            this.disablePan = false;
            this.disableTap = false;
            this.interpolationDecay = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Damper$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DECAY_MILLISECONDS"];
            this[_a] = this.shadowRoot.querySelector('.interaction-prompt');
            this[_b] = this.shadowRoot.querySelector('#prompt');
            this[_c] = [
                this.shadowRoot.querySelector('#finger0'),
                this.shadowRoot.querySelector('#finger1')
            ];
            this[_d] = this.shadowRoot.querySelector('.pan-target');
            this[_e] = 0;
            this[_f] = Infinity;
            this[_g] = false;
            this[_h] = false;
            this[_j] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SmoothControls"](this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].camera, this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]], this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]]);
            this[_k] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Spherical"]();
            this[_l] = false;
            this[_m] = false;
            this[_o] = false;
            this[_p] = ({ source })=>{
                this[$updateAria]();
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$needsRender"]]();
                if (source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChangeSource"].USER_INTERACTION) {
                    this[$userHasInteracted] = true;
                    this[$deferInteractionPrompt]();
                }
                this.dispatchEvent(new CustomEvent('camera-change', {
                    detail: {
                        source
                    }
                }));
            };
            this[_q] = (event)=>{
                if (event.type === 'pointer-change-start') {
                    this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$container"]].classList.add('pointer-tumbling');
                } else {
                    this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$container"]].classList.remove('pointer-tumbling');
                }
            };
        }
        get inputSensitivity() {
            return this[$controls].inputSensitivity;
        }
        set inputSensitivity(value) {
            this[$controls].inputSensitivity = value;
        }
        getCameraOrbit() {
            const { theta, phi, radius } = this[$lastSpherical];
            return {
                theta,
                phi,
                radius,
                toString () {
                    return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
                }
            };
        }
        getCameraTarget() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].isPresenting ? this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.target : this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].getTarget());
        }
        getFieldOfView() {
            return this[$controls].getFieldOfView();
        }
        // Provided so user code does not have to parse these from attributes.
        getMinimumFieldOfView() {
            return this[$controls].options.minimumFieldOfView;
        }
        getMaximumFieldOfView() {
            return this[$controls].options.maximumFieldOfView;
        }
        getIdealAspect() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].idealAspect;
        }
        jumpCameraToGoal() {
            this[$jumpCamera] = true;
            this.requestUpdate($jumpCamera, false);
        }
        resetInteractionPrompt() {
            this[$lastPromptOffset] = 0;
            this[$promptElementVisibleTime] = Infinity;
            this[$userHasInteracted] = false;
            this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;
        }
        zoom(keyPresses) {
            const event = new WheelEvent('wheel', {
                deltaY: -30 * keyPresses
            });
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]].dispatchEvent(event);
        }
        connectedCallback() {
            super.connectedCallback();
            this[$controls].addEventListener('change', this[$onChange]);
            this[$controls].addEventListener('pointer-change-start', this[$onPointerChange]);
            this[$controls].addEventListener('pointer-change-end', this[$onPointerChange]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[$controls].removeEventListener('change', this[$onChange]);
            this[$controls].removeEventListener('pointer-change-start', this[$onPointerChange]);
            this[$controls].removeEventListener('pointer-change-end', this[$onPointerChange]);
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            const controls = this[$controls];
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            if (changedProperties.has('cameraControls')) {
                if (this.cameraControls) {
                    controls.enableInteraction();
                    if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {
                        this[$waitingToPromptUser] = true;
                    }
                } else {
                    controls.disableInteraction();
                    this[$deferInteractionPrompt]();
                }
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]].setAttribute('aria-label', this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$ariaLabel"]]);
            }
            if (changedProperties.has('disableZoom')) {
                controls.disableZoom = this.disableZoom;
            }
            if (changedProperties.has('disablePan')) {
                controls.enablePan = !this.disablePan;
            }
            if (changedProperties.has('disableTap')) {
                controls.enableTap = !this.disableTap;
            }
            if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {
                if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls && !this[$userHasInteracted]) {
                    this[$waitingToPromptUser] = true;
                } else {
                    this[$deferInteractionPrompt]();
                }
            }
            if (changedProperties.has('interactionPromptStyle')) {
                this[$promptAnimatedContainer].style.opacity = this.interactionPromptStyle == InteractionPromptStyle.BASIC ? '1' : '0';
            }
            if (changedProperties.has('touchAction')) {
                const touchAction = this.touchAction;
                controls.applyOptions({
                    touchAction
                });
                controls.updateTouchActionStyle();
            }
            if (changedProperties.has('orbitSensitivity')) {
                controls.orbitSensitivity = this.orbitSensitivity;
            }
            if (changedProperties.has('interpolationDecay')) {
                controls.setDamperDecayTime(this.interpolationDecay);
                scene.setTargetDamperDecayTime(this.interpolationDecay);
            }
            if (this[$jumpCamera] === true) {
                Promise.resolve().then(()=>{
                    controls.jumpToGoal();
                    scene.jumpToGoal();
                    this[$jumpCamera] = false;
                });
            }
        }
        async updateFraming() {
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            await scene.updateFraming();
            const newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            const zoom = this[$controls].getFieldOfView() / oldFramedFoV;
            this[$controls].setFieldOfView(newFramedFoV * zoom);
            this[$maintainThetaPhi] = true;
            this.requestUpdate('maxFieldOfView');
            this.requestUpdate('fieldOfView');
            this.requestUpdate('minCameraOrbit');
            this.requestUpdate('maxCameraOrbit');
            this.requestUpdate('cameraOrbit');
            await this.updateComplete;
        }
        interact(duration, finger0, finger1) {
            const inputElement = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]];
            const fingerElements = this[$fingerAnimatedContainers];
            if (fingerElements[0].style.opacity === '1') {
                console.warn('interact() failed because an existing interaction is running.');
                return;
            }
            const xy = new Array();
            xy.push({
                x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])(finger0.x),
                y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])(finger0.y)
            });
            const positions = [
                {
                    x: xy[0].x(0),
                    y: xy[0].y(0)
                }
            ];
            if (finger1 != null) {
                xy.push({
                    x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])(finger1.x),
                    y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeline"])(finger1.y)
                });
                positions.push({
                    x: xy[1].x(0),
                    y: xy[1].y(0)
                });
            }
            let startTime = performance.now();
            const { width, height } = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const dispatchTouches = (type)=>{
                for (const [i, position] of positions.entries()){
                    const { style } = fingerElements[i];
                    style.transform = `translateX(${width * position.x}px) translateY(${height * position.y}px)`;
                    if (type === 'pointerdown') {
                        style.opacity = '1';
                    } else if (type === 'pointerup') {
                        style.opacity = '0';
                    }
                    const init = {
                        pointerId: i - 5678,
                        pointerType: 'touch',
                        target: inputElement,
                        clientX: width * position.x,
                        clientY: height * position.y,
                        altKey: true // flag that this is not a user interaction
                    };
                    inputElement.dispatchEvent(new PointerEvent(type, init));
                }
            };
            const moveTouches = ()=>{
                // Cancel interaction if something else moves the camera or input is
                // removed from the DOM.
                const { changeSource } = this[$controls];
                if (changeSource !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChangeSource"].AUTOMATIC || !inputElement.isConnected) {
                    for (const fingerElement of this[$fingerAnimatedContainers]){
                        fingerElement.style.opacity = '0';
                    }
                    dispatchTouches('pointercancel');
                    this.dispatchEvent(new CustomEvent('interact-stopped', {
                        detail: {
                            source: changeSource
                        }
                    }));
                    document.removeEventListener('visibilitychange', onVisibilityChange);
                    return;
                }
                const time = Math.min(1, (performance.now() - startTime) / duration);
                for (const [i, position] of positions.entries()){
                    position.x = xy[i].x(time);
                    position.y = xy[i].y(time);
                }
                dispatchTouches('pointermove');
                if (time < 1) {
                    requestAnimationFrame(moveTouches);
                } else {
                    dispatchTouches('pointerup');
                    this.dispatchEvent(new CustomEvent('interact-stopped', {
                        detail: {
                            source: changeSource
                        }
                    }));
                    document.removeEventListener('visibilitychange', onVisibilityChange);
                }
            };
            const onVisibilityChange = ()=>{
                let elapsed = 0;
                if (document.visibilityState === 'hidden') {
                    elapsed = performance.now() - startTime;
                } else {
                    startTime = performance.now() - elapsed;
                }
            };
            document.addEventListener('visibilitychange', onVisibilityChange);
            dispatchTouches('pointerdown');
            requestAnimationFrame(moveTouches);
        }
        [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $fingerAnimatedContainers, _d = $panElement, _e = $lastPromptOffset, _f = $promptElementVisibleTime, _g = $userHasInteracted, _h = $waitingToPromptUser, _j = $controls, _k = $lastSpherical, _l = $jumpCamera, _m = $initialized, _o = $maintainThetaPhi, $syncFieldOfView)](style) {
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            scene.framedFoVDeg = style[0] * 180 / Math.PI;
            this[$controls].setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg));
        }
        [$syncCameraOrbit](style) {
            const controls = this[$controls];
            if (this[$maintainThetaPhi]) {
                const { theta, phi } = this.getCameraOrbit();
                style[0] = theta;
                style[1] = phi;
                this[$maintainThetaPhi] = false;
            }
            controls.changeSource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChangeSource"].NONE;
            controls.setOrbit(style[0], style[1], style[2]);
        }
        [$syncMinCameraOrbit](style) {
            this[$controls].applyOptions({
                minimumAzimuthalAngle: style[0],
                minimumPolarAngle: style[1],
                minimumRadius: style[2]
            });
            this.jumpCameraToGoal();
        }
        [$syncMaxCameraOrbit](style) {
            this[$controls].applyOptions({
                maximumAzimuthalAngle: style[0],
                maximumPolarAngle: style[1],
                maximumRadius: style[2]
            });
            this[$updateCameraForRadius](style[2]);
            this.jumpCameraToGoal();
        }
        [$syncMinFieldOfView](style) {
            this[$controls].applyOptions({
                minimumFieldOfView: style[0] * 180 / Math.PI
            });
            this.jumpCameraToGoal();
        }
        [$syncMaxFieldOfView](style) {
            const fov = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].adjustedFoV(style[0] * 180 / Math.PI);
            this[$controls].applyOptions({
                maximumFieldOfView: fov
            });
            this.jumpCameraToGoal();
        }
        [$syncCameraTarget](style) {
            const [x, y, z] = style;
            if (!this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.isPresenting) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].setTarget(x, y, z);
            }
            this[$controls].changeSource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChangeSource"].NONE;
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].arRenderer.updateTarget();
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](time, delta) {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](time, delta);
            if (this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].isPresenting || !this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getModelIsVisible"]]()) {
                return;
            }
            const controls = this[$controls];
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const now = performance.now();
            if (this[$waitingToPromptUser]) {
                if (this.loaded && now > this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$loadedTime"]] + this.interactionPromptThreshold) {
                    this[$waitingToPromptUser] = false;
                    this[$promptElementVisibleTime] = now;
                    this[$promptElement].classList.add('visible');
                }
            }
            if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {
                const animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;
                const offset = wiggle(animationTime);
                const opacity = fade(animationTime);
                this[$promptAnimatedContainer].style.opacity = `${opacity}`;
                if (offset !== this[$lastPromptOffset]) {
                    const xOffset = offset * scene.width * 0.05;
                    const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;
                    this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`;
                    controls.changeSource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$SmoothControls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ChangeSource"].AUTOMATIC;
                    controls.adjustOrbit(deltaTheta, 0, 0);
                    this[$lastPromptOffset] = offset;
                }
            }
            controls.update(time, delta);
            if (scene.updateTarget(delta)) {
                this[$onChange]({
                    type: 'change',
                    source: controls.changeSource
                });
            }
        }
        [$deferInteractionPrompt]() {
            // Effectively cancel the timer waiting for user interaction:
            this[$waitingToPromptUser] = false;
            this[$promptElement].classList.remove('visible');
            this[$promptElementVisibleTime] = Infinity;
        }
        /**
         * Updates the camera's near and far planes to enclose the scene when
         * orbiting at the supplied radius.
         */ [$updateCameraForRadius](radius) {
            const maximumRadius = Math.max(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].boundingSphere.radius, radius);
            const near = 0;
            const far = 2 * maximumRadius;
            this[$controls].updateNearFar(near, far);
        }
        [$updateAria]() {
            const { theta, phi } = this[$controls].getCameraSpherical(this[$lastSpherical]);
            const azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;
            const polarTrient = Math.floor(phi / THIRD_PI);
            const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];
            const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateStatus"]](`View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`);
        }
        get [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$ariaLabel"]]() {
            return super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$ariaLabel"]] + (this.cameraControls ? INTERACTION_PROMPT : '');
        }
        async [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onResize"]](event) {
            const controls = this[$controls];
            const scene = this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]];
            const oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
            // The super of $onResize may update the scene's adjustedFoV, so we
            // compare the before and after to calculate the proper zoom.
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onResize"]](event);
            const fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV;
            const fov = controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);
            controls.updateAspect(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].aspect);
            this.requestUpdate('maxFieldOfView', this.maxFieldOfView);
            await this.updateComplete;
            this[$controls].setFieldOfView(fov);
            this.jumpCameraToGoal();
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"]]() {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$onModelLoad"]]();
            if (this[$initialized]) {
                this[$maintainThetaPhi] = true;
            } else {
                this[$initialized] = true;
            }
            this.requestUpdate('maxFieldOfView', this.maxFieldOfView);
            this.requestUpdate('fieldOfView', this.fieldOfView);
            this.requestUpdate('minCameraOrbit', this.minCameraOrbit);
            this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);
            this.requestUpdate('cameraOrbit', this.cameraOrbit);
            this.requestUpdate('cameraTarget', this.cameraTarget);
            this.jumpCameraToGoal();
        }
    }
    _p = $onChange, _q = $onPointerChange;
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'camera-controls'
        })
    ], ControlsModelViewerElement.prototype, "cameraControls", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: cameraOrbitIntrinsics,
            observeEffects: true,
            updateHandler: $syncCameraOrbit
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'camera-orbit',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "cameraOrbit", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: cameraTargetIntrinsics,
            observeEffects: true,
            updateHandler: $syncCameraTarget
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'camera-target',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "cameraTarget", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: fieldOfViewIntrinsics,
            observeEffects: true,
            updateHandler: $syncFieldOfView
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'field-of-view',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "fieldOfView", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: minCameraOrbitIntrinsics,
            updateHandler: $syncMinCameraOrbit
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'min-camera-orbit',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "minCameraOrbit", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: maxCameraOrbitIntrinsics,
            updateHandler: $syncMaxCameraOrbit
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'max-camera-orbit',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "maxCameraOrbit", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: minFieldOfViewIntrinsics,
            updateHandler: $syncMinFieldOfView
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'min-field-of-view',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "minFieldOfView", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: fieldOfViewIntrinsics,
            updateHandler: $syncMaxFieldOfView
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'max-field-of-view',
            hasChanged: ()=>true
        })
    ], ControlsModelViewerElement.prototype, "maxFieldOfView", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'interaction-prompt-threshold'
        })
    ], ControlsModelViewerElement.prototype, "interactionPromptThreshold", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'interaction-prompt'
        })
    ], ControlsModelViewerElement.prototype, "interactionPrompt", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'interaction-prompt-style'
        })
    ], ControlsModelViewerElement.prototype, "interactionPromptStyle", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'orbit-sensitivity'
        })
    ], ControlsModelViewerElement.prototype, "orbitSensitivity", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'touch-action'
        })
    ], ControlsModelViewerElement.prototype, "touchAction", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'disable-zoom'
        })
    ], ControlsModelViewerElement.prototype, "disableZoom", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'disable-pan'
        })
    ], ControlsModelViewerElement.prototype, "disablePan", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'disable-tap'
        })
    ], ControlsModelViewerElement.prototype, "disableTap", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'interpolation-decay'
        })
    ], ControlsModelViewerElement.prototype, "interpolationDecay", void 0);
    return ControlsModelViewerElement;
}; //# sourceMappingURL=controls.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/loading.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "$defaultPosterElement": (()=>$defaultPosterElement),
    "$defaultProgressBarElement": (()=>$defaultProgressBarElement),
    "$posterContainerElement": (()=>$posterContainerElement),
    "LoadingMixin": (()=>LoadingMixin),
    "POSTER_TRANSITION_TIME": (()=>POSTER_TRANSITION_TIME),
    "PROGRESS_BAR_UPDATE_THRESHOLD": (()=>PROGRESS_BAR_UPDATE_THRESHOLD)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/three/build/three.module.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/CachingGLTFLoader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/three-components/Renderer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
;
;
;
const POSTER_TRANSITION_TIME = 300;
const PROGRESS_BAR_UPDATE_THRESHOLD = 100;
const DEFAULT_DRACO_DECODER_LOCATION = 'https://www.gstatic.com/draco/versioned/decoders/1.4.1/';
const DEFAULT_KTX2_TRANSCODER_LOCATION = 'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';
const RevealStrategy = {
    AUTO: 'auto',
    MANUAL: 'manual'
};
const LoadingStrategy = {
    AUTO: 'auto',
    LAZY: 'lazy',
    EAGER: 'eager'
};
const $defaultProgressBarElement = Symbol('defaultProgressBarElement');
const $posterContainerElement = Symbol('posterContainerElement');
const $defaultPosterElement = Symbol('defaultPosterElement');
const $shouldDismissPoster = Symbol('shouldDismissPoster');
const $hidePoster = Symbol('hidePoster');
const $modelIsRevealed = Symbol('modelIsRevealed');
const $updateProgressBar = Symbol('updateProgressBar');
const $ariaLabelCallToAction = Symbol('ariaLabelCallToAction');
const $onProgress = Symbol('onProgress');
const LoadingMixin = (ModelViewerElement)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h;
    class LoadingModelViewerElement extends ModelViewerElement {
        constructor(...args){
            super(...args);
            /**
             * A URL pointing to the image to use as a poster in scenarios where the
             * <model-viewer> is not ready to reveal a rendered model to the viewer.
             */ this.poster = null;
            /**
             * An enumerable attribute describing under what conditions the
             * <model-viewer> should reveal a model to the viewer.
             *
             * The default value is "auto". The only supported alternative values is
             * "manual".
             */ this.reveal = RevealStrategy.AUTO;
            /**
             * An enumerable attribute describing under what conditions the
             * <model-viewer> should preload a model.
             *
             * The default value is "auto". The only supported alternative values are
             * "lazy" and "eager". Auto is equivalent to lazy, which loads the model
             * when it is near the viewport for reveal = "auto", and when interacted
             * with for reveal = "interaction". Eager loads the model immediately.
             */ this.loading = LoadingStrategy.AUTO;
            this[_a] = false;
            this[_b] = false;
            // TODO: Add this to the shadow root as part of this mixin's
            // implementation:
            this[_c] = this.shadowRoot.querySelector('.slot.poster');
            this[_d] = this.shadowRoot.querySelector('#default-poster');
            this[_e] = this.shadowRoot.querySelector('#default-progress-bar > .bar');
            this[_f] = this[$defaultPosterElement].getAttribute('aria-label');
            this[_g] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttle"])((progress)=>{
                const parentNode = this[$defaultProgressBarElement].parentNode;
                requestAnimationFrame(()=>{
                    this[$defaultProgressBarElement].style.transform = `scaleX(${progress})`;
                    if (progress === 0) {
                        // NOTE(cdata): We remove and re-append the progress bar in this
                        // condition so that the progress bar does not appear to
                        // transition backwards from the right when we reset to 0 (or
                        // otherwise <1) progress after having already reached 1 progress
                        // previously.
                        parentNode.removeChild(this[$defaultProgressBarElement]);
                        parentNode.appendChild(this[$defaultProgressBarElement]);
                    }
                    // NOTE(cdata): IE11 does not properly respect the second parameter
                    // of classList.toggle, which this implementation originally used.
                    // @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11865865/
                    if (progress === 1.0) {
                        this[$defaultProgressBarElement].classList.add('hide');
                    } else {
                        this[$defaultProgressBarElement].classList.remove('hide');
                    }
                });
            }, PROGRESS_BAR_UPDATE_THRESHOLD);
            this[_h] = (event)=>{
                const progress = event.detail.totalProgress;
                if (progress === 1.0) {
                    this[$updateProgressBar].flush();
                    if (this.loaded && (this[$shouldDismissPoster] || this.reveal === RevealStrategy.AUTO)) {
                        this[$hidePoster]();
                    }
                }
                this[$updateProgressBar](progress);
                this.dispatchEvent(new CustomEvent('progress', {
                    detail: {
                        totalProgress: progress
                    }
                }));
            };
            const ModelViewerElement = self.ModelViewerElement || {};
            const dracoDecoderLocation = ModelViewerElement.dracoDecoderLocation || DEFAULT_DRACO_DECODER_LOCATION;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setDRACODecoderLocation(dracoDecoderLocation);
            const ktx2TranscoderLocation = ModelViewerElement.ktx2TranscoderLocation || DEFAULT_KTX2_TRANSCODER_LOCATION;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setKTX2TranscoderLocation(ktx2TranscoderLocation);
            if (ModelViewerElement.meshoptDecoderLocation) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setMeshoptDecoderLocation(ModelViewerElement.meshoptDecoderLocation);
            }
        }
        static set dracoDecoderLocation(value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setDRACODecoderLocation(value);
        }
        static get dracoDecoderLocation() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].getDRACODecoderLocation();
        }
        static set ktx2TranscoderLocation(value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setKTX2TranscoderLocation(value);
        }
        static get ktx2TranscoderLocation() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].getKTX2TranscoderLocation();
        }
        static set meshoptDecoderLocation(value) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].setMeshoptDecoderLocation(value);
        }
        static get meshoptDecoderLocation() {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CachingGLTFLoader"].getMeshoptDecoderLocation();
        }
        /**
         * If provided, the callback will be passed each resource URL before a
         * request is sent. The callback may return the original URL, or a new URL
         * to override loading behavior. This behavior can be used to load assets
         * from .ZIP files, drag-and-drop APIs, and Data URIs.
         */ static mapURLs(callback) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$Renderer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Renderer"].singleton.loader[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$three$2d$components$2f$CachingGLTFLoader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$loader"]].manager.setURLModifier(callback);
        }
        /**
         * Dismisses the poster, causing the model to load and render if
         * necessary. This is currently effectively the same as interacting with
         * the poster via user input.
         */ dismissPoster() {
            if (this.loaded) {
                this[$hidePoster]();
            } else {
                this[$shouldDismissPoster] = true;
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateSource"]]();
            }
        }
        /**
         * Displays the poster, hiding the 3D model. If this is called after the 3D
         * model has been revealed, then it must be dismissed by a call to
         * dismissPoster().
         */ showPoster() {
            const posterContainerElement = this[$posterContainerElement];
            if (posterContainerElement.classList.contains('show')) {
                return;
            }
            posterContainerElement.classList.add('show');
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]].classList.remove('show');
            const defaultPosterElement = this[$defaultPosterElement];
            defaultPosterElement.removeAttribute('tabindex');
            defaultPosterElement.removeAttribute('aria-hidden');
            const oldVisibility = this.modelIsVisible;
            this[$modelIsRevealed] = false;
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$announceModelVisibility"]](oldVisibility);
        }
        /**
         * Returns the model's bounding box dimensions in meters, independent of
         * turntable rotation.
         */ getDimensions() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].size);
        }
        getBoundingBoxCenter() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toVector3D"])(this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].boundingBox.getCenter(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$three$2f$build$2f$three$2e$module$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector3"]()));
        }
        connectedCallback() {
            super.connectedCallback();
            this.showPoster();
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$progressTracker"]].addEventListener('progress', this[$onProgress]);
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$progressTracker"]].removeEventListener('progress', this[$onProgress]);
        }
        async updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('poster') && this.poster != null) {
                this[$defaultPosterElement].style.backgroundImage = `url(${this.poster})`;
            }
            if (changedProperties.has('alt')) {
                this[$defaultPosterElement].setAttribute('aria-label', this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$altDefaulted"]]);
            }
            if (changedProperties.has('reveal') || changedProperties.has('loading')) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$updateSource"]]();
            }
        }
        [(_a = $modelIsRevealed, _b = $shouldDismissPoster, _c = $posterContainerElement, _d = $defaultPosterElement, _e = $defaultProgressBarElement, _f = $ariaLabelCallToAction, _g = $updateProgressBar, _h = $onProgress, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$shouldAttemptPreload"])]() {
            return !!this.src && (this[$shouldDismissPoster] || this.loading === LoadingStrategy.EAGER || this.reveal === RevealStrategy.AUTO && this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$isElementInViewport"]]);
        }
        [$hidePoster]() {
            this[$shouldDismissPoster] = false;
            const posterContainerElement = this[$posterContainerElement];
            if (!posterContainerElement.classList.contains('show')) {
                return;
            }
            posterContainerElement.classList.remove('show');
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]].classList.add('show');
            const oldVisibility = this.modelIsVisible;
            this[$modelIsRevealed] = true;
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$announceModelVisibility"]](oldVisibility);
            const root = this.getRootNode();
            // If the <model-viewer> is still focused, forward the focus to
            // the canvas that has just been revealed
            if (root && root.activeElement === this) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$userInputElement"]].focus();
            }
            // Ensure that the poster is no longer focusable or visible to
            // screen readers
            const defaultPosterElement = this[$defaultPosterElement];
            defaultPosterElement.setAttribute('aria-hidden', 'true');
            defaultPosterElement.tabIndex = -1;
            this.dispatchEvent(new CustomEvent('poster-dismissed'));
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getModelIsVisible"]]() {
            return super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getModelIsVisible"]]() && this[$modelIsRevealed];
        }
    }
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String
        })
    ], LoadingModelViewerElement.prototype, "poster", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String
        })
    ], LoadingModelViewerElement.prototype, "reveal", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String
        })
    ], LoadingModelViewerElement.prototype, "loading", void 0);
    return LoadingModelViewerElement;
}; //# sourceMappingURL=loading.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/features/staging.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "AUTO_ROTATE_DELAY_DEFAULT": (()=>AUTO_ROTATE_DELAY_DEFAULT),
    "StagingMixin": (()=>StagingMixin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lit$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/lit/decorators.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@lit/reactive-element/development/decorators/property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/decorators.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/conversions.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/styles/parsers.js [app-client] (ecmascript)");
var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
;
;
;
;
;
// How much the model will rotate per
// second in radians:
const DEFAULT_ROTATION_SPEED = Math.PI / 32;
const AUTO_ROTATE_DELAY_DEFAULT = 3000;
const rotationRateIntrinsics = {
    basis: [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$conversions$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$styles$2f$parsers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["numberNode"])(DEFAULT_ROTATION_SPEED, 'rad'))
    ],
    keywords: {
        auto: [
            null
        ]
    }
};
const $autoRotateStartTime = Symbol('autoRotateStartTime');
const $radiansPerSecond = Symbol('radiansPerSecond');
const $syncRotationRate = Symbol('syncRotationRate');
const $onCameraChange = Symbol('onCameraChange');
const StagingMixin = (ModelViewerElement)=>{
    var _a, _b, _c;
    class StagingModelViewerElement extends ModelViewerElement {
        constructor(){
            super(...arguments);
            this.autoRotate = false;
            this.autoRotateDelay = AUTO_ROTATE_DELAY_DEFAULT;
            this.rotationPerSecond = 'auto';
            this[_a] = performance.now();
            this[_b] = 0;
            this[_c] = (event)=>{
                if (!this.autoRotate) {
                    return;
                }
                if (event.detail.source === 'user-interaction') {
                    this[$autoRotateStartTime] = performance.now();
                }
            };
        }
        connectedCallback() {
            super.connectedCallback();
            this.addEventListener('camera-change', this[$onCameraChange]);
            this[$autoRotateStartTime] = performance.now();
        }
        disconnectedCallback() {
            super.disconnectedCallback();
            this.removeEventListener('camera-change', this[$onCameraChange]);
            this[$autoRotateStartTime] = performance.now();
        }
        updated(changedProperties) {
            super.updated(changedProperties);
            if (changedProperties.has('autoRotate')) {
                this[$autoRotateStartTime] = performance.now();
            }
        }
        [(_a = $autoRotateStartTime, _b = $radiansPerSecond, $syncRotationRate)](style) {
            this[$radiansPerSecond] = style[0];
        }
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](time, delta) {
            super[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$tick"]](time, delta);
            if (!this.autoRotate || !this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$getModelIsVisible"]]() || this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$renderer"]].isPresenting) {
                return;
            }
            const rotationDelta = Math.min(delta, time - this[$autoRotateStartTime] - this.autoRotateDelay);
            if (rotationDelta > 0) {
                this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].yaw = this.turntableRotation + this[$radiansPerSecond] * rotationDelta * 0.001;
            }
        }
        get turntableRotation() {
            return this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].yaw;
        }
        resetTurntableRotation(theta = 0) {
            this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["$scene"]].yaw = theta;
        }
    }
    _c = $onCameraChange;
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Boolean,
            attribute: 'auto-rotate'
        })
    ], StagingModelViewerElement.prototype, "autoRotate", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: Number,
            attribute: 'auto-rotate-delay'
        })
    ], StagingModelViewerElement.prototype, "autoRotateDelay", void 0);
    __decorate([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$decorators$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["style"])({
            intrinsics: rotationRateIntrinsics,
            updateHandler: $syncRotationRate
        }),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$lit$2f$reactive$2d$element$2f$development$2f$decorators$2f$property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["property"])({
            type: String,
            attribute: 'rotation-per-second'
        })
    ], StagingModelViewerElement.prototype, "rotationPerSecond", void 0);
    return StagingModelViewerElement;
}; //# sourceMappingURL=staging.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/utilities/focus-visible.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * This mixin function is designed to be applied to a class that inherits
 * from HTMLElement. It makes it easy for a custom element to coordinate with
 * the :focus-visible polyfill.
 *
 * NOTE(cdata): The code here was adapted from an example proposed with the
 * introduction of ShadowDOM support in the :focus-visible polyfill.
 *
 * @see https://github.com/WICG/focus-visible/pull/196
 * @param {Function} SuperClass The base class implementation to decorate with
 * implementation that coordinates with the :focus-visible polyfill
 */ __turbopack_context__.s({
    "FocusVisiblePolyfillMixin": (()=>FocusVisiblePolyfillMixin)
});
const FocusVisiblePolyfillMixin = (SuperClass)=>{
    var _a;
    const coordinateWithPolyfill = (instance)=>{
        // If there is no shadow root, there is no need to coordinate with
        // the polyfill. If we already coordinated with the polyfill, we can
        // skip subsequent invocations:
        if (instance.shadowRoot == null || instance.hasAttribute('data-js-focus-visible')) {
            return ()=>{};
        }
        // The polyfill might already be loaded. If so, we can apply it to
        // the shadow root immediately:
        if (self.applyFocusVisiblePolyfill) {
            self.applyFocusVisiblePolyfill(instance.shadowRoot);
        } else {
            const coordinationHandler = ()=>{
                self.applyFocusVisiblePolyfill(instance.shadowRoot);
            };
            // Otherwise, wait for the polyfill to be loaded lazily. It might
            // never be loaded, but if it is then we can apply it to the
            // shadow root at the appropriate time by waiting for the ready
            // event:
            self.addEventListener('focus-visible-polyfill-ready', coordinationHandler, {
                once: true
            });
            return ()=>{
                self.removeEventListener('focus-visible-polyfill-ready', coordinationHandler);
            };
        }
        return ()=>{};
    };
    const $endPolyfillCoordination = Symbol('endPolyfillCoordination');
    // IE11 doesn't natively support custom elements or JavaScript class
    // syntax The mixin implementation assumes that the user will take the
    // appropriate steps to support both:
    class FocusVisibleCoordinator extends SuperClass {
        constructor(){
            super(...arguments);
            this[_a] = null;
        }
        // Attempt to coordinate with the polyfill when connected to the
        // document:
        connectedCallback() {
            super.connectedCallback && super.connectedCallback();
            if (this[$endPolyfillCoordination] == null) {
                this[$endPolyfillCoordination] = coordinateWithPolyfill(this);
            }
        }
        disconnectedCallback() {
            super.disconnectedCallback && super.disconnectedCallback();
            // It's important to remove the polyfill event listener when we
            // disconnect, otherwise we will leak the whole element via window:
            if (this[$endPolyfillCoordination] != null) {
                this[$endPolyfillCoordination]();
                this[$endPolyfillCoordination] = null;
            }
        }
    }
    _a = $endPolyfillCoordination;
    ;
    return FocusVisibleCoordinator;
}; //# sourceMappingURL=focus-visible.js.map
}}),
"[project]/node_modules/@google/model-viewer/lib/model-viewer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ __turbopack_context__.s({
    "ModelViewerElement": (()=>ModelViewerElement)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/animation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$annotation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/annotation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$ar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/ar.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/controls.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/environment.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$loading$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/loading.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/scene-graph.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$staging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/features/staging.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/model-viewer-base.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$focus$2d$visible$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@google/model-viewer/lib/utilities/focus-visible.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const ModelViewerElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$annotation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnnotationMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$scene$2d$graph$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SceneGraphMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$staging$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StagingMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$environment$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EnvironmentMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$controls$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ControlsMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$ar$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ARMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$loading$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LoadingMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$features$2f$animation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AnimationMixin"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$utilities$2f$focus$2d$visible$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FocusVisiblePolyfillMixin"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$google$2f$model$2d$viewer$2f$lib$2f$model$2d$viewer$2d$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])))))))));
customElements.define('model-viewer', ModelViewerElement); //# sourceMappingURL=model-viewer.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40google_model-viewer_lib_be9075b4._.js.map