(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "E": (()=>EndDateSchema),
    "R": (()=>RawDateSchema),
    "S": (()=>StartDateSchema),
    "a": (()=>assertEnabled)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
;
;
;
const RawDateSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].date().transform((i)=>{
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Math.floor(i.getTime() / 1000));
        }),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().transform((i)=>{
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(i);
        })
    ]))();
/**
 * Default to now
 */ const StartDateSchema = /* @__PURE__ */ (()=>RawDateSchema.default(new Date(0)))();
/**
 * Default to 10 years from now
 */ const EndDateSchema = /* @__PURE__ */ (()=>RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();
/**
 * Checks whether the given DetectableFeature is defined
 * @internal
 * @param namespace - The namespace to check
 * @param feature - The corresponding feature
 */ function assertEnabled(namespace, feature) {
    if (!namespace) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](feature);
    }
    return namespace;
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>ContractMetadata),
    "G": (()=>GasCostEstimator),
    "a": (()=>ContractEvents),
    "b": (()=>ContractAppURI),
    "d": (()=>detectContractFeature),
    "h": (()=>hasFunction),
    "t": (()=>toEther)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$storage$2f$dist$2f$thirdweb$2d$dev$2d$storage$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js [app-client] (ecmascript)");
;
;
;
;
/**
 * Type guard for contractWrappers depending on passed feature name
 * @internal
 * @param contractWrapper - The contract wrapper to check
 * @param featureName - The feature name to check
 */ function detectContractFeature(contractWrapper, featureName) {
    const b = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ai"])(contractWrapper.abi, featureName, contractWrapper.extensions);
    return b;
}
/**
 * @internal
 * @param contractWrapper - The contract wrapper to check
 * @param functionName - The function name to check
 */ function hasFunction(functionName, contractWrapper) {
    return functionName in contractWrapper.readContract.functions;
}
/**
 * @internal
 */ /**
 * Handles metadata for a Contract
 * @remarks Read and update metadata for this contract
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const metadata = await contract.metadata.get();
 * await contract.metadata.set({
 *   name: "My Contract",
 *   description: "My contract description"
 * })
 * ```
 * @contract
 * @public
 */ class ContractMetadata {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cJ"].name;
    constructor(contractWrapper, schema, storage){
        this.contractWrapper = contractWrapper;
        this.schema = schema;
        this.storage = storage;
    }
    /**
   * @internal
   */ parseOutputMetadata(metadata) {
        return this.schema.output.parseAsync(metadata);
    }
    /**
   * @internal
   */ parseInputMetadata(metadata) {
        return this.schema.input.parseAsync(metadata);
    }
    /**
   * Get the metadata of this contract
   * @remarks Get the metadata of a contract
   * @example
   * ```javascript
   * const metadata = await contract.metadata.get();
   * console.log(metadata);
   * ```
   * @public
   * @returns The metadata of the given contract
   * @twfeature ContractMetadata
   */ async get() {
        let data;
        if (this.supportsContractMetadata(this.contractWrapper)) {
            const uri = await this.contractWrapper.read("contractURI", []);
            if (uri && uri.includes("://")) {
                data = await this.storage.downloadJSON(uri);
            }
        }
        if (!data) {
            try {
                // try fetching metadata from bytecode and / or contract itself
                let contractName;
                try {
                    if (hasFunction("name", this.contractWrapper)) {
                        contractName = await this.contractWrapper.read("name", []);
                    }
                } catch (err) {
                // no-op
                }
                let contractSymbol;
                try {
                    if (hasFunction("symbol", this.contractWrapper)) {
                        contractSymbol = await this.contractWrapper.read("symbol", []);
                    }
                } catch (err) {
                // no-op
                }
                let publishedMetadata;
                try {
                    publishedMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
                } catch (err) {}
                data = {
                    name: contractName || publishedMetadata?.name,
                    symbol: contractSymbol,
                    description: publishedMetadata?.info.title
                };
            } catch (e) {
                throw new Error("Could not fetch contract metadata");
            }
        }
        return this.parseOutputMetadata(data);
    }
    /**
   * Set the metadata of this contract
   * @remarks OVERWRITE the metadata of a contract
   * @example
   * ```javascript
   * await contract.metadata.set({
   *   name: "My Contract",
   *   description: "My contract description"
   * })
   * ```
   * @public
   * @param metadata - the metadata to set
   * @twfeature ContractMetadata
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadata)=>{
        const uri = await this._parseAndUploadMetadata(metadata);
        const wrapper = this.contractWrapper;
        if (this.supportsContractMetadata(wrapper)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "setContractURI",
                args: [
                    uri
                ],
                parse: (receipt)=>{
                    return {
                        receipt,
                        data: this.get
                    };
                }
            });
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cJ"]);
        }
    });
    /**
   * Update the metadata of a contract
   * @remarks Update the metadata of a contract
   * @example
   * ```javascript
   * await contract.metadata.update({
   *   description: "My new contract description"
   * })
   * ```
   * @public
   * @param metadata - the metadata to update
   * @twfeature ContractMetadata
   * */ update = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadata)=>{
        return await this.set.prepare({
            ...await this.get(),
            ...metadata
        });
    });
    /**
   *
   * @internal
   * @param metadata - the metadata to set
   * @returns
   */ async _parseAndUploadMetadata(metadata) {
        const parsedMetadata = await this.parseInputMetadata(metadata);
        return this.storage.upload(parsedMetadata);
    }
    supportsContractMetadata(contractWrapper) {
        return detectContractFeature(contractWrapper, "ContractMetadata");
    }
}
/**
 * Listen to Contract events in real time
 * @contract
 * @public
 */ class ContractEvents {
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Subscribe to transactions in this contract.
   * @remarks Will emit an "event" object containing the transaction status ('submitted' and 'completed') and hash
   * @example
   * ```javascript
   * contract.events.addTransactionListener((event) => {
   *   console.log(event);
   * }
   * ```
   * @param listener - the callback function that will be called on every transaction
   * @public
   */ addTransactionListener(listener) {
        this.contractWrapper.addListener(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aZ"].Transaction, listener);
    }
    /**
   * Remove a transaction listener
   * @remarks Remove a listener that was added with addTransactionListener
   * @example
   * ```javascript
   * contract.events.removeTransactionListener((event) => {
   *  console.log(event);
   * }
   * ```
   * @param listener - the callback function to remove
   * @public
   */ removeTransactionListener(listener) {
        this.contractWrapper.off(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aZ"].Transaction, listener);
    }
    /**
   * Subscribe to contract events
   * @remarks You can add a listener for any contract event to run a function when
   * the event is emitted. For example, if you wanted to listen for a "TokensMinted" event,
   * you could do the following:
   * @example
   * ```javascript
   * contract.events.addEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the callback function that will be called on every new event
   * @returns A function to un-subscribe from the event
   */ addEventListener(// eslint-disable-next-line @typescript-eslint/ban-types
    eventName, listener) {
        // validates event, throws error if not found
        const event = this.contractWrapper.readContract.interface.getEvent(eventName);
        const address = this.contractWrapper.address;
        const filter = {
            address,
            topics: [
                this.contractWrapper.readContract.interface.getEventTopic(event)
            ]
        };
        const wrappedListener = (log)=>{
            const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
            listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
        };
        this.contractWrapper.getProvider().on(filter, wrappedListener);
        return ()=>{
            this.contractWrapper.getProvider().off(filter, wrappedListener);
        };
    }
    /**
   * Listen to all events emitted from this contract
   *
   * @example
   * ```javascript
   * contract.events.listenToAllEvents((event) => {
   *   console.log(event.eventName) // the name of the emitted event
   *   console.log(event.data) // event payload
   * }
   * ```
   * @public
   * @param listener - the callback function that will be called on every new event
   * @returns A function that can be called to stop listening to events
   */ listenToAllEvents(listener) {
        const address = this.contractWrapper.address;
        const filter = {
            address
        };
        const wrappedListener = (log)=>{
            try {
                const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);
                listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));
            } catch (e) {
                console.error("Could not parse event:", log, e);
            }
        };
        this.contractWrapper.getProvider().on(filter, wrappedListener);
        return ()=>{
            this.contractWrapper.getProvider().off(filter, wrappedListener);
        };
    }
    /**
   * Remove an event listener from this contract
   * @remarks Remove a listener that was added with addEventListener
   * @example
   * ```javascript
   * contract.events.removeEventListener("TokensMinted", (event) => {
   *   console.log(event);
   * });
   * ```
   * @public
   * @param eventName - the event name as defined in the contract
   * @param listener - the listener to unregister
   */ removeEventListener(// eslint-disable-next-line @typescript-eslint/ban-types
    eventName, listener) {
        // validates event, throws error if not found
        const event = this.contractWrapper.readContract.interface.getEvent(eventName);
        this.contractWrapper.readContract.off(event.name, listener);
    }
    /**
   * Remove all listeners on this contract
   * @remarks Remove all listeners from a contract
   * @example
   * ```javascript
   * contract.events.removeAllListeners();
   * ```
   * @public
   */ removeAllListeners() {
        this.contractWrapper.readContract.removeAllListeners();
        const address = this.contractWrapper.address;
        const filter = {
            address
        };
        this.contractWrapper.getProvider().removeAllListeners(filter);
    }
    /**
   * Get All Events
   * @remarks Get a list of all the events emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // Optionally pass in filters to limit the blocks from which events are retrieved
   * const filters = {
   *   fromBlock: 0,
   *   toBlock: 1000000,
   * }
   * const events = await contract.events.getAllEvents(filters);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks
   * @returns The event objects of the events emitted with event names and data for each event
   */ async getAllEvents() {
        let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
            fromBlock: 0,
            toBlock: "latest",
            order: "desc"
        };
        const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);
        const orderedEvents = events.sort((a, b)=>{
            return filters.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
        });
        return this.parseEvents(orderedEvents);
    }
    /**
   * Get Events
   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period
   * @example
   * ```javascript
   * // The name of the event to get logs for
   * const eventName = "Transfer";
   *
   * // Optionally pass in options to limit the blocks from which events are retrieved
   * const options = {
   *   fromBlock: 0,
   *   toBlock: 1000000, // can also pass "latest"
   *   order: "desc",
   *   // Configure event filters (filter on indexed event parameters)
   *   filters: {
   *     from: "0x...",
   *     to: "0x..."
   *   }
   * };
   *
   * const events = await contract.events.getEvents(eventName, options);
   * console.log(events[0].eventName);
   * console.log(events[0].data);
   * ```
   *
   * @param eventName - The name of the event to get logs for
   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions
   * @returns The requested event objects with event data
   */ async getEvents(eventName) {
        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            fromBlock: 0,
            toBlock: "latest",
            order: "desc"
        };
        const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);
        const args = options.filters ? eventInterface.inputs.map((e)=>options.filters[e.name]) : [];
        const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);
        const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);
        const orderedEvents = events.sort((a, b)=>{
            return options.order === "desc" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;
        });
        return this.parseEvents(orderedEvents);
    }
    parseEvents(events) {
        return events.map((e)=>{
            const transaction = Object.fromEntries(Object.entries(e).filter((a)=>typeof a[1] !== "function" && a[0] !== "args"));
            if (e.args) {
                const entries = Object.entries(e.args);
                const args = entries.slice(entries.length / 2, entries.length);
                const data = {};
                for (const [key, value] of args){
                    data[key] = value;
                }
                return {
                    eventName: e.event || "",
                    data: data,
                    transaction
                };
            }
            return {
                eventName: e.event || "",
                data: {},
                transaction
            };
        });
    }
    toContractEvent(event, args, rawLog) {
        const transaction = Object.fromEntries(Object.entries(rawLog).filter((a)=>typeof a[1] !== "function" && a[0] !== "args"));
        const results = {};
        event.inputs.forEach((param, index)=>{
            if (Array.isArray(args[index])) {
                const components = param.components;
                if (components) {
                    const arr = args[index];
                    if (param.type === "tuple[]") {
                        // tuple[]
                        const objArray = [];
                        for(let i = 0; i < arr.length; i++){
                            const tuple = arr[i];
                            const obj = {};
                            for(let j = 0; j < components.length; j++){
                                const name = components[j].name;
                                obj[name] = tuple[j];
                            }
                            objArray.push(obj);
                        }
                        results[param.name] = objArray;
                    } else {
                        // simple tuple
                        const obj = {};
                        for(let i = 0; i < components.length; i++){
                            const name = components[i].name;
                            obj[name] = arr[i];
                        }
                        results[param.name] = obj;
                    }
                }
            } else {
                results[param.name] = args[index];
            }
        });
        return {
            eventName: event.name,
            data: results,
            transaction
        };
    }
}
function toEther(amount) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatEther(amount);
}
/**
 * Estimates the gas cost of Contract calls
 * @public
 */ class GasCostEstimator {
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Estimates the cost of gas in native token of the current chain
   * Pass in the same parameters as the contract's function.
   * @remarks Estimate the cost of gas in native token of the current chain
   * @example
   * ```javascript
   * const costOfClaim = await nftDrop?.estimator.gasCostOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns The estimated price in native currency (ETH, MATIC, etc) of calling this function
   * @public
   */ async gasCostOf(// eslint-disable-next-line @typescript-eslint/ban-types
    fn, args) {
        const gasCost = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(this.contractWrapper.getProvider(), await this.contractWrapper.populateTransaction(fn, args));
        return toEther(gasCost);
    }
    /**
   * Estimates the gas limit of a transaction
   * Pass in the same parameters as the contract's function.
   * @remarks Estimates the gas limit of a transaction
   * @example
   * ```javascript
   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf("claim", [
   *   "0x...", // receiver
   *   1, // quantity
   *   "0x...", // currency
   *   1, // price per token
   *   [], // proofs
   *   1, // proof max quantity per transaction
   * ]);
   * ```
   * @returns The estimated gas limit of the transaction
   * @public
   */ async gasLimitOf(// eslint-disable-next-line @typescript-eslint/ban-types
    fn, args) {
        return this.contractWrapper.estimateGas(fn, args);
    }
    /**
   * Returns the current gas price in gwei
   * @remarks Get the current gas price in gwei
   * @example
   * ```javascript
   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();
   * ```
   * @returns The current gas price in gwei
   * @public
   */ async currentGasPriceInGwei() {
        const price = await this.contractWrapper.getProvider().getGasPrice();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatUnits(price, "gwei");
    }
}
/**
 * Have an official Application URI for this contract.
 * @remarks Configure an official Application URI for this contract.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const appURI = await contract.app.get();
 * appURI = "ipfs://some_ipfs_hash";
 *
 * await contract.app.set(appURI)
 * ```
 * @public
 */ class ContractAppURI {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cK"].name;
    constructor(contractWrapper, metadata, storage){
        this.contractWrapper = contractWrapper;
        this.metadata = metadata;
        this.storage = storage;
    }
    /**
   * Get App URI
   * @returns The appURI (typically an IPFS hash)
   * @example
   * ```javascript
   * const appURI = await contract.app.get();
   * console.log(appURI) // "ipfs://some_ipfs_hash";
   * ```
   * @twfeature AppURI
   */ async get() {
        if (detectContractFeature(this.contractWrapper, "AppURI")) {
            return await this.contractWrapper.read("appURI", []);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$storage$2f$dist$2f$thirdweb$2d$dev$2d$storage$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceGatewayUrlWithScheme"])((await this.metadata.get()).app_uri || "", this.storage.getGatewayUrls());
    }
    /**
   * Set App URI
   * @param appURI - the uri to set (typically an IPFS hash)
   * @example
   * ```javascript
   * const appURI = "ipfs://some_ipfs_hash";
   * await contract.app.set(appURI);
   * ```
   * @twfeature AppURI
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (appURI)=>{
        if (detectContractFeature(this.contractWrapper, "AppURI")) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "setAppURI",
                args: [
                    appURI
                ]
            });
        }
        return await this.metadata.update.prepare({
            app_uri: appURI
        });
    });
}
;
}}),
"[project]/node_modules/buffer-reverse/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
module.exports = function reverse(src) {
    var buffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](src.length);
    for(var i = 0, j = src.length - 1; i <= j; ++i, --j){
        buffer[i] = src[j];
        buffer[j] = src[i];
    }
    return buffer;
};
}}),
"[project]/node_modules/treeify/treeify.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
//     treeify.js
//     Luke Plaster <notatestuser@gmail.com>
//     https://github.com/notatestuser/treeify.js
// do the universal module definition dance
(function(root, factory) {
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = factory();
    } else {
        "TURBOPACK unreachable";
    }
})(this, function() {
    function makePrefix(key, last) {
        var str = last ? '└' : '├';
        if (key) {
            str += '─ ';
        } else {
            str += '──┐';
        }
        return str;
    }
    function filterKeys(obj, hideFunctions) {
        var keys = [];
        for(var branch in obj){
            // always exclude anything in the object's prototype
            if (!obj.hasOwnProperty(branch)) {
                continue;
            }
            // ... and hide any keys mapped to functions if we've been told to
            if (hideFunctions && typeof obj[branch] === "function") {
                continue;
            }
            keys.push(branch);
        }
        return keys;
    }
    function growBranch(key, root, last, lastStates, showValues, hideFunctions, callback) {
        var line = '', index = 0, lastKey, circular, lastStatesCopy = lastStates.slice(0);
        if (lastStatesCopy.push([
            root,
            last
        ]) && lastStates.length > 0) {
            // based on the "was last element" states of whatever we're nested within,
            // we need to append either blankness or a branch to our line
            lastStates.forEach(function(lastState, idx) {
                if (idx > 0) {
                    line += (lastState[1] ? ' ' : '│') + '  ';
                }
                if (!circular && lastState[0] === root) {
                    circular = true;
                }
            });
            // the prefix varies based on whether the key contains something to show and
            // whether we're dealing with the last element in this collection
            line += makePrefix(key, last) + key;
            // append values and the circular reference indicator
            showValues && (typeof root !== 'object' || root instanceof Date) && (line += ': ' + root);
            circular && (line += ' (circular ref.)');
            callback(line);
        }
        // can we descend into the next item?
        if (!circular && typeof root === 'object') {
            var keys = filterKeys(root, hideFunctions);
            keys.forEach(function(branch) {
                // the last key is always printed with a different prefix, so we'll need to know if we have it
                lastKey = ++index === keys.length;
                // hold your breath for recursive action
                growBranch(branch, root[branch], lastKey, lastStatesCopy, showValues, hideFunctions, callback);
            });
        }
    }
    ;
    // --------------------
    var Treeify = {};
    // Treeify.asLines
    // --------------------
    // Outputs the tree line-by-line, calling the lineCallback when each one is available.
    Treeify.asLines = function(obj, showValues, hideFunctions, lineCallback) {
        /* hideFunctions and lineCallback are curried, which means we don't break apps using the older form */ var hideFunctionsArg = typeof hideFunctions !== 'function' ? hideFunctions : false;
        growBranch('.', obj, false, [], showValues, hideFunctionsArg, lineCallback || hideFunctions);
    };
    // Treeify.asTree
    // --------------------
    // Outputs the entire tree, returning it as a string with line breaks.
    Treeify.asTree = function(obj, showValues, hideFunctions) {
        var tree = '';
        growBranch('.', obj, false, [], showValues, hideFunctions, function(line) {
            tree += line + '\n';
        });
        return tree;
    };
    // --------------------
    return Treeify;
});
}}),
"[project]/node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "MerkleTree": (()=>MerkleTree)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/buffer-reverse/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$treeify$2f$treeify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/treeify/treeify.js [app-client] (ecmascript)");
;
;
;
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
class Base {
    /**
   * print
   * @desc Prints out a visual representation of the merkle tree.
   * @example
   *```js
   *tree.print()
   *```
   */ print() {
        Base.print(this);
    }
    /**
   * bufferIndexOf
   * @desc Returns the first index of which given buffer is found in array.
   * @param {Buffer[]} haystack - Array of buffers.
   * @param {Buffer} needle - Buffer to find.
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.bufferIndexOf(haystack, needle)
   *```
   */ bufferIndexOf(array, element) {
        let isSorted = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (isSorted) {
            return this.binarySearch(array, element, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
        }
        const eqChecker = (buffer1, buffer2)=>buffer1.equals(buffer2);
        return this.linearSearch(array, element, eqChecker);
    }
    /**
   * binarySearch
   * @desc Returns the first index of which given item is found in array using binary search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} compareFunction
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = MerkleTree.binarySearch(array, element, Buffer.compare)
   *```
   */ static binarySearch(array, element, compareFunction) {
        let start = 0;
        let end = array.length - 1;
        // Iterate while start not meets end
        while(start <= end){
            // Find the mid index
            const mid = Math.floor((start + end) / 2);
            // Check if the mid value is greater than, equal to, or less than search element.
            const ordering = compareFunction(array[mid], element);
            // If element is present at mid, start iterating for searching first appearance.
            if (ordering === 0) {
                // Linear reverse iteration until the first matching item index is found.
                for(let i = mid - 1; i >= 0; i--){
                    if (compareFunction(array[i], element) === 0) {
                        continue;
                    }
                    return i + 1;
                }
                return 0;
            } else if (ordering < 0) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }
    /**
   * binarySearch
   * @desc Returns the first index of which given item is found in array using binary search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} compareFunction
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.binarySearch(array, element, Buffer.compare)
   *```
   */ binarySearch(array, element, compareFunction) {
        return Base.binarySearch(array, element, compareFunction);
    }
    /**
   * linearSearch
   * @desc Returns the first index of which given item is found in array using linear search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} eqChecker
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = MerkleTree.linearSearch(array, element, (a, b) => a === b)
   *```
   */ static linearSearch(array, element, eqChecker) {
        for(let i = 0; i < array.length; i++){
            if (eqChecker(array[i], element)) {
                return i;
            }
        }
        return -1;
    }
    /**
   * linearSearch
   * @desc Returns the first index of which given item is found in array using linear search.
   * @param {Buffer[]} array - Array of items.
   * @param {Buffer} element - Item to find.
   * @param {Function} eqChecker
   * @return {Number} - Index number
   *
   * @example
   * ```js
   *const index = tree.linearSearch(array, element, (a, b) => a === b)
   *```
   */ linearSearch(array, element, eqChecker) {
        return Base.linearSearch(array, element, eqChecker);
    }
    /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer|ArrayBuffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = MerkleTree.bufferify('0x1234')
   *```
   */ static bufferify(value) {
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(value)) {
            // crypto-js support
            if (typeof value === "object" && value.words) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.toString(convertWordsToBuffer), "hex");
            } else if (Base.isHexString(value)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.replace(/^0x/, ""), "hex");
            } else if (typeof value === "string") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value);
            } else if (typeof value === "bigint") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.toString(16), "hex");
            } else if (value instanceof Uint8Array) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.buffer);
            } else if (typeof value === "number") {
                let s = value.toString();
                if (s.length % 2) {
                    s = `0${s}`;
                }
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, "hex");
            } else if (ArrayBuffer.isView(value)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.buffer, value.byteOffset, value.byteLength);
            }
        }
        return value;
    }
    bigNumberify(value) {
        return Base.bigNumberify(value);
    }
    static bigNumberify(value) {
        if (typeof value === "bigint") {
            return value;
        }
        if (typeof value === "string") {
            if (value.startsWith("0x") && Base.isHexString(value)) {
                return BigInt("0x" + value.replace("0x", "").toString());
            }
            return BigInt(value);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(value)) {
            return BigInt("0x" + value.toString("hex"));
        }
        if (value instanceof Uint8Array) {
            return uint8ArrayToBigInt(value);
        }
        if (typeof value === "number") {
            return BigInt(value);
        }
        throw new Error("cannot bigNumberify");
    }
    /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */ static isHexString(v) {
        return typeof v === "string" && /^(0x)?[0-9A-Fa-f]*$/.test(v);
    }
    /**
   * print
   * @desc Prints out a visual representation of the given merkle tree.
   * @param {Object} tree - Merkle tree instance.
   * @return {String}
   * @example
   *```js
   *MerkleTree.print(tree)
   *```
   */ static print(tree) {
        console.log(tree.toString());
    }
    /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = tree.bufferToHex(Buffer.from('A'))
   *```
   */ bufferToHex(value) {
        let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return Base.bufferToHex(value, withPrefix);
    }
    /**
   * bufferToHex
   * @desc Returns a hex string with 0x prefix for given buffer.
   * @param {Buffer} value
   * @return {String}
   * @example
   *```js
   *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))
   *```
   */ static bufferToHex(value) {
        let withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return `${withPrefix ? "0x" : ""}${(value || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(0)).toString("hex")}`;
    }
    /**
   * bufferify
   * @desc Returns a buffer type for the given value.
   * @param {String|Number|Object|Buffer} value
   * @return {Buffer}
   *
   * @example
   * ```js
   *const buf = tree.bufferify('0x1234')
   *```
   */ bufferify(value) {
        return Base.bufferify(value);
    }
    /**
   * bufferifyFn
   * @desc Returns a function that will bufferify the return value.
   * @param {Function}
   * @return {Function}
   *
   * @example
   * ```js
   *const fn = tree.bufferifyFn((value) => sha256(value))
   *```
   */ bufferifyFn(f) {
        return (value)=>{
            const v = f(value);
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(v)) {
                return v;
            }
            if (this.isHexString(v)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(v.replace("0x", ""), "hex");
            }
            if (typeof v === "string") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(v);
            }
            if (typeof v === "bigint") {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(value.toString(16), "hex");
            }
            if (ArrayBuffer.isView(v)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(v.buffer, v.byteOffset, v.byteLength);
            }
            // crypto-js support
            const arrayBuffer = hexStringToArrayBuffer(value.toString("hex"));
            // Assuming f now works with ArrayBuffers
            const processedBuffer = f(arrayBuffer);
            const hexResult = arrayBufferToHexString(processedBuffer);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(hexResult, "hex");
        };
    }
    /**
   * isHexString
   * @desc Returns true if value is a hex string.
   * @param {String} value
   * @return {Boolean}
   *
   * @example
   * ```js
   *console.log(MerkleTree.isHexString('0x1234'))
   *```
   */ isHexString(value) {
        return Base.isHexString(value);
    }
    /**
   * log2
   * @desc Returns the log2 of number.
   * @param {Number} value
   * @return {Number}
   */ log2(n) {
        return n === 1 ? 0 : 1 + this.log2(n / 2 | 0);
    }
    /**
   * zip
   * @desc Returns true if value is a hex string.
   * @param {String[]|Number[]|Buffer[]} a - first array
   * @param {String[]|Number[]|Buffer[]} b -  second array
   * @return {String[][]|Number[][]|Buffer[][]}
   *
   * @example
   * ```js
   *const zipped = tree.zip(['a', 'b'],['A', 'B'])
   *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]
   *```
   */ zip(a, b) {
        return a.map((e, i)=>[
                e,
                b[i]
            ]);
    }
    static hexZeroPad(hexStr, length) {
        return "0x" + hexStr.replace("0x", "").padStart(length, "0");
    }
}
var Base$1 = Base;
// UTILS
// replaces CryptoJS.enc.Hex
function convertWordsToBuffer(value) {
    const wordArray = value.words;
    const arrayBuffer = new ArrayBuffer(wordArray.length * 4); // 4 bytes per word
    const uint8View = new Uint8Array(arrayBuffer);
    for(let i = 0; i < wordArray.length; i++){
        uint8View[i * 4] = wordArray[i] >> 24 & 0xff;
        uint8View[i * 4 + 1] = wordArray[i] >> 16 & 0xff;
        uint8View[i * 4 + 2] = wordArray[i] >> 8 & 0xff;
        uint8View[i * 4 + 3] = wordArray[i] & 0xff;
    }
    return arrayBuffer;
}
function hexStringToArrayBuffer(hexString) {
    const buffer = new Uint8Array(hexString.length / 2);
    for(let i = 0; i < hexString.length; i += 2){
        buffer[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
    }
    return buffer.buffer;
}
function arrayBufferToHexString(arrayBuffer) {
    const uint8View = new Uint8Array(arrayBuffer);
    return Array.from(uint8View).map((byte)=>byte.toString(16).padStart(2, "0")).join("");
}
function uint8ArrayToBigInt(u8a) {
    const hex = Array.from(u8a).map((byte)=>byte.toString(16).padStart(2, "0")).join("");
    return BigInt(`0x${hex}`);
}
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// TODO: Clean up and DRY up code
// Disclaimer: The multiproof code is unaudited and may possibly contain serious issues. It's in a hacky state as is and needs to be rewritten.
/**
 * Class reprensenting a Merkle Tree
 * @namespace MerkleTree
 */ class MerkleTree extends Base$1 {
    duplicateOdd = false;
    concatenator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat;
    hashLeaves = false;
    isBitcoinTree = false;
    leaves = [];
    layers = [];
    sortLeaves = false;
    sortPairs = false;
    sort = false;
    fillDefaultHash = null;
    complete = false;
    /**
   * @desc Constructs a Merkle Tree.
   * All nodes and leaves are stored as Buffers.
   * Lonely leaf nodes are promoted to the next level up without being hashed again.
   * @param {Buffer[]} leaves - Array of hashed leaves. Each leaf must be a Buffer.
   * @param {Function} hashFunction - Hash function to use for hashing leaves and nodes
   * @param {Object} options - Additional options
   * @example
   *```js
   *const MerkleTree = require('merkletreejs')
   *const crypto = require('crypto')
   *
   *function sha256(data) {
   *  // returns Buffer
   *  return crypto.createHash('sha256').update(data).digest()
   *}
   *
   *const leaves = ['a', 'b', 'c'].map(value => keccak(value))
   *
   *const tree = new MerkleTree(leaves, sha256)
   *```
   */ constructor(leaves, hashFn){
        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        super();
        if (options.complete) {
            if (options.isBitcoinTree) {
                throw new Error('option "complete" is incompatible with "isBitcoinTree"');
            }
            if (options.duplicateOdd) {
                throw new Error('option "complete" is incompatible with "duplicateOdd"');
            }
        }
        this.isBitcoinTree = !!options.isBitcoinTree;
        this.hashLeaves = !!options.hashLeaves;
        this.sortLeaves = !!options.sortLeaves;
        this.sortPairs = !!options.sortPairs;
        this.complete = !!options.complete;
        if (options.fillDefaultHash) {
            if (typeof options.fillDefaultHash === "function") {
                this.fillDefaultHash = options.fillDefaultHash;
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(options.fillDefaultHash) || typeof options.fillDefaultHash === "string") {
                this.fillDefaultHash = (idx, hashFn)=>options.fillDefaultHash;
            } else {
                throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');
            }
        }
        this.sort = !!options.sort;
        if (this.sort) {
            this.sortLeaves = true;
            this.sortPairs = true;
        }
        this.duplicateOdd = !!options.duplicateOdd;
        if (options.concatenator) {
            this.concatenator = options.concatenator;
        }
        this.hashFn = this.bufferifyFn(hashFn);
        this.processLeaves(leaves);
    }
    getOptions() {
        return {
            complete: this.complete,
            isBitcoinTree: this.isBitcoinTree,
            hashLeaves: this.hashLeaves,
            sortLeaves: this.sortLeaves,
            sortPairs: this.sortPairs,
            sort: this.sort,
            fillDefaultHash: this.fillDefaultHash?.toString() ?? null,
            duplicateOdd: this.duplicateOdd
        };
    }
    processLeaves(leaves) {
        if (this.hashLeaves) {
            leaves = leaves.map(this.hashFn);
        }
        this.leaves = leaves.map(this.bufferify);
        if (this.sortLeaves) {
            this.leaves = this.leaves.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
        }
        if (this.fillDefaultHash) {
            for(let i = this.leaves.length; i < Math.pow(2, Math.ceil(Math.log2(this.leaves.length))); i++){
                this.leaves.push(this.bufferify(this.fillDefaultHash(i, this.hashFn)));
            }
        }
        this.createHashes(this.leaves);
    }
    createHashes(nodes) {
        this.layers = [
            nodes
        ];
        while(nodes.length > 1){
            const layerIndex = this.layers.length;
            this.layers.push([]);
            const layerLimit = this.complete && layerIndex === 1 && !Number.isInteger(Math.log2(nodes.length)) ? 2 * nodes.length - 2 ** Math.ceil(Math.log2(nodes.length)) : nodes.length;
            for(let i = 0; i < nodes.length; i += 2){
                if (i >= layerLimit) {
                    this.layers[layerIndex].push(...nodes.slice(layerLimit));
                    break;
                } else if (i + 1 === nodes.length) {
                    if (nodes.length % 2 === 1) {
                        const data = nodes[nodes.length - 1];
                        let hash = data;
                        // is bitcoin tree
                        if (this.isBitcoinTree) {
                            // Bitcoin method of duplicating the odd ending nodes
                            hash = this.hashFn(this.concatenator([
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data),
                                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data)
                            ]));
                            hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.hashFn(hash));
                            this.layers[layerIndex].push(hash);
                            continue;
                        } else {
                            if (this.duplicateOdd) ;
                            else {
                                // push copy of hash and continue iteration
                                this.layers[layerIndex].push(nodes[i]);
                                continue;
                            }
                        }
                    }
                }
                const left = nodes[i];
                const right = i + 1 === nodes.length ? left : nodes[i + 1];
                let combined = null;
                if (this.isBitcoinTree) {
                    combined = [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(left),
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(right)
                    ];
                } else {
                    combined = [
                        left,
                        right
                    ];
                }
                if (this.sortPairs) {
                    combined.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
                }
                let hash = this.hashFn(this.concatenator(combined));
                // double hash if bitcoin tree
                if (this.isBitcoinTree) {
                    hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.hashFn(hash));
                }
                this.layers[layerIndex].push(hash);
            }
            nodes = this.layers[layerIndex];
        }
    }
    /**
   * addLeaf
   * @desc Adds a leaf to the tree and re-calculates layers.
   * @param {String|Buffer} - Leaf
   * @param {Boolean} - Set to true if the leaf should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaf(newLeaf)
   *```
   */ addLeaf(leaf) {
        let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (shouldHash) {
            leaf = this.hashFn(leaf);
        }
        this.processLeaves(this.leaves.concat(leaf));
    }
    /**
   * addLeaves
   * @desc Adds multiple leaves to the tree and re-calculates layers.
   * @param {String[]|Buffer[]} - Array of leaves
   * @param {Boolean} - Set to true if the leaves should be hashed before being added to tree.
   * @example
   *```js
   *tree.addLeaves(newLeaves)
   *```
   */ addLeaves(leaves) {
        let shouldHash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (shouldHash) {
            leaves = leaves.map(this.hashFn);
        }
        this.processLeaves(this.leaves.concat(leaves));
    }
    /**
   * getLeaves
   * @desc Returns array of leaves of Merkle Tree.
   * @return {Buffer[]}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *```
   */ getLeaves(values) {
        if (Array.isArray(values)) {
            if (this.hashLeaves) {
                values = values.map(this.hashFn);
                if (this.sortLeaves) {
                    values = values.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
                }
            }
            return this.leaves.filter(// @ts-expect-error - issue from original code
            (leaf)=>this.bufferIndexOf(values, leaf, this.sortLeaves) !== -1);
        }
        return this.leaves;
    }
    /**
   * getLeaf
   * @desc Returns the leaf at the given index.
   * @param {Number} - Index number
   * @return {Buffer}
   * @example
   *```js
   *const leaf = tree.getLeaf(1)
   *```
   */ getLeaf(index) {
        if (index < 0 || index > this.leaves.length - 1) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([]);
        }
        return this.leaves[index];
    }
    /**
   * getLeafIndex
   * @desc Returns the index of the given leaf, or -1 if the leaf is not found.
   * @param {String|Buffer} - Target leaf
   * @return {number}
   * @example
   *```js
   *const leaf = Buffer.from('abc')
   *const index = tree.getLeafIndex(leaf)
   *```
   */ getLeafIndex(target) {
        target = this.bufferify(target);
        const leaves = this.getLeaves();
        for(let i = 0; i < leaves.length; i++){
            const leaf = leaves[i];
            if (leaf.equals(target)) {
                return i;
            }
        }
        return -1;
    }
    /**
   * getLeafCount
   * @desc Returns the total number of leaves.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLeafCount()
   *```
   */ getLeafCount() {
        return this.leaves.length;
    }
    /**
   * getHexLeaves
   * @desc Returns array of leaves of Merkle Tree as hex strings.
   * @return {String[]}
   * @example
   *```js
   *const leaves = tree.getHexLeaves()
   *```
   */ getHexLeaves() {
        return this.leaves.map((leaf)=>this.bufferToHex(leaf));
    }
    /**
   * marshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a JSON string.
   * @param {String[]|Buffer[]} - Merkle tree leaves
   * @return {String} - List of leaves as JSON string
   * @example
   *```js
   *const jsonStr = MerkleTree.marshalLeaves(leaves)
   *```
   */ static marshalLeaves(leaves) {
        return JSON.stringify(leaves.map((leaf)=>MerkleTree.bufferToHex(leaf)), null, 2);
    }
    /**
   * unmarshalLeaves
   * @desc Returns array of leaves of Merkle Tree as a Buffers.
   * @param {String|Object} - JSON stringified leaves
   * @return {Buffer[]} - Unmarshalled list of leaves
   * @example
   *```js
   *const leaves = MerkleTree.unmarshalLeaves(jsonStr)
   *```
   */ static unmarshalLeaves(jsonStr) {
        let parsed = null;
        if (typeof jsonStr === "string") {
            parsed = JSON.parse(jsonStr);
        } else if (jsonStr instanceof Object) {
            parsed = jsonStr;
        } else {
            throw new Error("Expected type of string or object");
        }
        if (!parsed) {
            return [];
        }
        if (!Array.isArray(parsed)) {
            throw new Error("Expected JSON string to be array");
        }
        return parsed.map(MerkleTree.bufferify);
    }
    /**
   * getLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[][]}
   * @example
   *```js
   *const layers = tree.getLayers()
   *```
   */ getLayers() {
        return this.layers;
    }
    /**
   * getHexLayers
   * @desc Returns multi-dimensional array of all layers of Merkle Tree, including leaves and root as hex strings.
   * @return {String[][]}
   * @example
   *```js
   *const layers = tree.getHexLayers()
   *```
   */ getHexLayers() {
        return this.layers.reduce((acc, item)=>{
            if (Array.isArray(item)) {
                acc.push(item.map((layer)=>this.bufferToHex(layer)));
            } else {
                acc.push(item);
            }
            return acc;
        }, []);
    }
    /**
   * getLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root.
   * @return {Buffer[]}
   * @example
   *```js
   *const layers = tree.getLayersFlat()
   *```
   */ getLayersFlat() {
        const layers = this.layers.reduce((acc, item)=>{
            if (Array.isArray(item)) {
                acc.unshift(...item);
            } else {
                acc.unshift(item);
            }
            return acc;
        }, []);
        layers.unshift(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
            0
        ]));
        return layers;
    }
    /**
   * getHexLayersFlat
   * @desc Returns single flat array of all layers of Merkle Tree, including leaves and root as hex string.
   * @return {String[]}
   * @example
   *```js
   *const layers = tree.getHexLayersFlat()
   *```
   */ getHexLayersFlat() {
        return this.getLayersFlat().map((layer)=>this.bufferToHex(layer));
    }
    /**
   * getLayerCount
   * @desc Returns the total number of layers.
   * @return {number}
   * @example
   *```js
   *const count = tree.getLayerCount()
   *```
   */ getLayerCount() {
        return this.getLayers().length;
    }
    /**
   * getRoot
   * @desc Returns the Merkle root hash as a Buffer.
   * @return {Buffer}
   * @example
   *```js
   *const root = tree.getRoot()
   *```
   */ getRoot() {
        if (this.layers.length === 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([]);
        }
        return this.layers[this.layers.length - 1][0] || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([]);
    }
    /**
   * getHexRoot
   * @desc Returns the Merkle root hash as a hex string.
   * @return {String}
   * @example
   *```js
   *const root = tree.getHexRoot()
   *```
   */ getHexRoot() {
        return this.bufferToHex(this.getRoot());
    }
    /**
   * getProof
   * @desc Returns the proof for a target leaf.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {Object[]} - Array of objects containing a position property of type string
   * with values of 'left' or 'right' and a data property of type Buffer.
   * @example
   * ```js
   *const proof = tree.getProof(leaves[2])
   *```
   *
   * @example
   *```js
   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
   *const tree = new MerkleTree(leaves, keccak)
   *const proof = tree.getProof(leaves[2], 2)
   *```
   */ getProof(leaf, index) {
        if (typeof leaf === "undefined") {
            throw new Error("leaf is required");
        }
        leaf = this.bufferify(leaf);
        const proof = [];
        if (!Number.isInteger(index)) {
            index = -1;
            for(let i = 0; i < this.leaves.length; i++){
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(leaf, this.leaves[i]) === 0) {
                    index = i;
                }
            }
        }
        // @ts-expect-error - issue from original code
        if (index <= -1) {
            return [];
        }
        for(let i = 0; i < this.layers.length; i++){
            const layer = this.layers[i];
            // @ts-expect-error - issue from original code
            const isRightNode = index % 2;
            const pairIndex = isRightNode ? // @ts-expect-error - issue from original code
            index - 1 : this.isBitcoinTree && index === layer.length - 1 && i < this.layers.length - 1 ? // Proof Generation for Bitcoin Trees
            index : // Proof Generation for Non-Bitcoin Trees
            // @ts-expect-error - issue from original code
            index + 1;
            if (pairIndex < layer.length) {
                proof.push({
                    position: isRightNode ? "left" : "right",
                    data: layer[pairIndex]
                });
            }
            // set index to parent index
            // @ts-expect-error - issue from original code
            index = index / 2 | 0;
        }
        // @ts-expect-error - issue from original code
        return proof;
    }
    /**
   * getHexProof
   * @desc Returns the proof for a target leaf as hex strings.
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {String[]} - Proof array as hex strings.
   * @example
   * ```js
   *const proof = tree.getHexProof(leaves[2])
   *```
   */ getHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item)=>this.bufferToHex(item.data));
    }
    /**
   * getProofs
   * @desc Returns the proofs for all leaves.
   * @return {Object[]} - Array of objects containing a position property of type string
   * with values of 'left' or 'right' and a data property of type Buffer for all leaves.
   * @example
   * ```js
   *const proofs = tree.getProofs()
   *```
   *
   * @example
   *```js
   *const leaves = ['a', 'b', 'a'].map(value => keccak(value))
   *const tree = new MerkleTree(leaves, keccak)
   *const proofs = tree.getProofs()
   *```
   */ getProofs() {
        // @ts-expect-error - issue from original code
        const proof = [];
        // @ts-expect-error - issue from original code
        const proofs = [];
        // @ts-expect-error - issue from original code
        this.getProofsDFS(this.layers.length - 1, 0, proof, proofs);
        // @ts-expect-error - issue from original code
        return proofs;
    }
    /**
   * getProofsDFS
   * @desc Get all proofs through single traverse
   * @param {Number} currentLayer - Current layer index in traverse.
   * @param {Number} index - Current tarvese node index in traverse.
   * @param {Object[]} proof - Proof chain for single leaf.
   * @param {Object[]} proofs - Proofs for all leaves
   * @example
   * ```js
   *const layers = tree.getLayers()
   *const index = 0;
   *let proof = [];
   *let proofs = [];
   *const proof = tree.getProofsDFS(layers, index, proof, proofs)
   *```
   */ // @ts-expect-error - issue from original code
    getProofsDFS(currentLayer, index, proof, proofs) {
        const isRightNode = index % 2;
        if (currentLayer === -1) {
            if (!isRightNode) {
                proofs.push([
                    ...proof
                ].reverse());
            }
            // @ts-expect-error - issue from original code
            return;
        }
        if (index >= this.layers[currentLayer].length) {
            // @ts-expect-error - issue from original code
            return;
        }
        const layer = this.layers[currentLayer];
        const pairIndex = isRightNode ? index - 1 : index + 1;
        let pushed = false;
        if (pairIndex < layer.length) {
            pushed = true;
            proof.push({
                position: isRightNode ? "left" : "right",
                data: layer[pairIndex]
            });
        }
        const leftchildIndex = index * 2;
        const rightchildIndex = index * 2 + 1;
        this.getProofsDFS(currentLayer - 1, leftchildIndex, proof, proofs);
        this.getProofsDFS(currentLayer - 1, rightchildIndex, proof, proofs);
        if (pushed) {
            proof.splice(proof.length - 1, 1);
        }
    }
    /**
   * getHexProofs
   * @desc Returns the proofs for all leaves as hex strings.
   * @return {String[]} - Proofs array as hex strings.
   * @example
   * ```js
   *const proofs = tree.getHexProofs()
   *```
   */ getHexProofs() {
        return this.getProofs().map((item)=>this.bufferToHex(item.data));
    }
    /**
   * getPositionalHexProof
   * @desc Returns the proof for a target leaf as hex strings and the position in binary (left == 0).
   * @param {Buffer} leaf - Target leaf
   * @param {Number} [index] - Target leaf index in leaves array.
   * Use if there are leaves containing duplicate data in order to distinguish it.
   * @return {(string | number)[][]} - Proof array as hex strings. position at index 0
   * @example
   * ```js
   *const proof = tree.getPositionalHexProof(leaves[2])
   *```
   */ getPositionalHexProof(leaf, index) {
        return this.getProof(leaf, index).map((item)=>{
            return [
                item.position === "left" ? 0 : 1,
                this.bufferToHex(item.data)
            ];
        });
    }
    /**
   * getProofIndices
   * @desc Returns the proof indices for given tree indices.
   * @param {Number[]} treeIndices - Tree indices
   * @param {Number} depth - Tree depth; number of layers.
   * @return {Number[]} - Proof indices
   * @example
   * ```js
   *const proofIndices = tree.getProofIndices([2,5,6], 4)
   *console.log(proofIndices) // [ 23, 20, 19, 8, 3 ]
   *```
   */ getProofIndices(treeIndices, depth) {
        const leafCount = 2 ** depth;
        let maximalIndices = new Set();
        for (const index of treeIndices){
            let x = leafCount + index;
            while(x > 1){
                maximalIndices.add(x ^ 1);
                x = x / 2 | 0;
            }
        }
        const a = treeIndices.map((index)=>leafCount + index);
        const b = Array.from(maximalIndices).sort((x, y)=>x - y).reverse();
        maximalIndices = a.concat(b);
        const redundantIndices = new Set();
        const proof = [];
        for (let index of maximalIndices){
            if (!redundantIndices.has(index)) {
                proof.push(index);
                while(index > 1){
                    redundantIndices.add(index);
                    if (!redundantIndices.has(index ^ 1)) {
                        break;
                    }
                    index = index / 2 | 0;
                }
            }
        }
        return proof.filter((index)=>{
            return !treeIndices.includes(index - leafCount);
        });
    }
    getProofIndicesForUnevenTree(sortedLeafIndices, leavesCount) {
        const depth = Math.ceil(Math.log2(leavesCount));
        const unevenLayers = [];
        for(let index = 0; index < depth; index++){
            const unevenLayer = leavesCount % 2 !== 0;
            if (unevenLayer) {
                unevenLayers.push({
                    index,
                    leavesCount
                });
            }
            leavesCount = Math.ceil(leavesCount / 2);
        }
        const proofIndices = [];
        let layerNodes = sortedLeafIndices;
        for(let layerIndex = 0; layerIndex < depth; layerIndex++){
            const siblingIndices = layerNodes.map((index)=>{
                if (index % 2 === 0) {
                    return index + 1;
                }
                return index - 1;
            });
            let proofNodeIndices = siblingIndices.filter((index)=>!layerNodes.includes(index));
            const unevenLayer = unevenLayers.find((_ref)=>{
                let { index } = _ref;
                return index === layerIndex;
            });
            if (unevenLayer && layerNodes.includes(unevenLayer.leavesCount - 1)) {
                proofNodeIndices = proofNodeIndices.slice(0, -1);
            }
            proofIndices.push(proofNodeIndices);
            layerNodes = [
                ...new Set(layerNodes.map((index)=>{
                    if (index % 2 === 0) {
                        return index / 2;
                    }
                    if (index % 2 === 0) {
                        return (index + 1) / 2;
                    }
                    return (index - 1) / 2;
                }))
            ];
        }
        return proofIndices;
    }
    /**
   * getMultiProof
   * @desc Returns the multiproof for given tree indices.
   * @param {Number[]} indices - Tree indices.
   * @return {Buffer[]} - Multiproofs
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *```
   */ getMultiProof(tree, indices) {
        if (!this.complete) {
            console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true");
        }
        if (!indices) {
            indices = tree;
            tree = this.getLayersFlat();
        }
        const isUneven = this.isUnevenTree();
        if (isUneven) {
            // @ts-expect-error - issue from original code
            if (indices.every(Number.isInteger)) {
                return this.getMultiProofForUnevenTree(indices);
            }
        }
        // @ts-expect-error - issue from original code
        if (!indices.every(Number.isInteger)) {
            let els = indices;
            if (this.sortPairs) {
                // @ts-expect-error - issue from original code
                els = els.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
            }
            // @ts-expect-error - issue from original code
            let ids = els.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);
            if (!ids.every((idx)=>idx !== -1)) {
                throw new Error("Element does not exist in Merkle tree");
            }
            // @ts-expect-error - issue from original code
            const hashes = [];
            const proof = [];
            let nextIds = [];
            for(let i = 0; i < this.layers.length; i++){
                const layer = this.layers[i];
                for(let j = 0; j < ids.length; j++){
                    const idx = ids[j];
                    const pairElement = this.getPairNode(layer, idx);
                    hashes.push(layer[idx]);
                    if (pairElement) {
                        proof.push(pairElement);
                    }
                    nextIds.push(idx / 2 | 0);
                }
                ids = nextIds.filter((value, j, self)=>self.indexOf(value) === j);
                nextIds = [];
            }
            // @ts-expect-error - issue from original code
            return proof.filter((value)=>!hashes.includes(value));
        }
        // @ts-expect-error - issue from original code
        return this.getProofIndices(indices, Math.log2(tree.length / 2 | 0)).map(// @ts-expect-error - issue from original code
        (index)=>tree[index]);
    }
    getMultiProofForUnevenTree(tree, indices) {
        if (!indices) {
            indices = tree;
            tree = this.getLayers();
        }
        let proofHashes = [];
        // @ts-expect-error - issue from original code
        let currentLayerIndices = indices;
        // @ts-expect-error - issue from original code
        for (const treeLayer of tree){
            const siblings = [];
            for (const index of currentLayerIndices){
                if (index % 2 === 0) {
                    const idx = index + 1;
                    if (!currentLayerIndices.includes(idx)) {
                        if (treeLayer[idx]) {
                            siblings.push(treeLayer[idx]);
                            continue;
                        }
                    }
                }
                const idx = index - 1;
                if (!currentLayerIndices.includes(idx)) {
                    if (treeLayer[idx]) {
                        siblings.push(treeLayer[idx]);
                        continue;
                    }
                }
            }
            proofHashes = proofHashes.concat(siblings);
            const uniqueIndices = new Set();
            for (const index of currentLayerIndices){
                if (index % 2 === 0) {
                    uniqueIndices.add(index / 2);
                    continue;
                }
                if (index % 2 === 0) {
                    uniqueIndices.add((index + 1) / 2);
                    continue;
                }
                uniqueIndices.add((index - 1) / 2);
            }
            currentLayerIndices = Array.from(uniqueIndices);
        }
        return proofHashes;
    }
    /**
   * getHexMultiProof
   * @desc Returns the multiproof for given tree indices as hex strings.
   * @param {Number[]} indices - Tree indices.
   * @return {String[]} - Multiproofs as hex strings.
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getHexMultiProof(indices)
   *```
   */ getHexMultiProof(tree, indices) {
        return this.getMultiProof(tree, indices).map((x)=>this.bufferToHex(x));
    }
    /**
   * getProofFlags
   * @desc Returns list of booleans where proofs should be used instead of hashing.
   * Proof flags are used in the Solidity multiproof verifiers.
   * @param {Number[]|Buffer[]} leaves
   * @param {Buffer[]} proofs
   * @return {Boolean[]} - Boolean flags
   * @example
   * ```js
   *const indices = [2, 5, 6]
   *const proof = tree.getMultiProof(indices)
   *const proofFlags = tree.getProofFlags(leaves, proof)
   *```
   */ getProofFlags(leaves, proofs) {
        if (!Array.isArray(leaves) || leaves.length <= 0) {
            throw new Error("Invalid Inputs!");
        }
        let ids;
        if (leaves.every(Number.isInteger)) {
            ids = [
                ...leaves
            ].sort((a, b)=>a === b ? 0 : a > b ? 1 : -1); // Indices where passed
        } else {
            ids = leaves.map((el)=>this.bufferIndexOf(this.leaves, el, this.sortLeaves)).sort((a, b)=>a === b ? 0 : a > b ? 1 : -1);
        }
        if (!ids.every((idx)=>idx !== -1)) {
            throw new Error("Element does not exist in Merkle tree");
        }
        const _proofs = proofs.map((item)=>this.bufferify(item));
        // @ts-expect-error - issue from original code
        const tested = [];
        // @ts-expect-error - issue from original code
        const flags = [];
        for(let index = 0; index < this.layers.length; index++){
            const layer = this.layers[index];
            ids = ids.reduce((ids_, idx)=>{
                // @ts-expect-error - issue from original code
                const skipped = tested.includes(layer[idx]);
                if (!skipped) {
                    const pairElement = this.getPairNode(layer, idx);
                    const proofUsed = _proofs.includes(layer[idx]) || _proofs.includes(pairElement);
                    // eslint-disable-next-line no-unused-expressions
                    pairElement && flags.push(!proofUsed);
                    tested.push(layer[idx]);
                    tested.push(pairElement);
                }
                // @ts-expect-error - issue from original code
                ids_.push(idx / 2 | 0);
                return ids_;
            }, []);
        }
        // @ts-expect-error - issue from original code
        return flags;
    }
    /**
   * verify
   * @desc Returns true if the proof path (array of hashes) can connect the target node
   * to the Merkle root.
   * @param {Object[]} proof - Array of proof objects that should connect
   * target node to Merkle root.
   * @param {Buffer} targetNode - Target node Buffer
   * @param {Buffer} root - Merkle root Buffer
   * @return {Boolean}
   * @example
   *```js
   *const root = tree.getRoot()
   *const proof = tree.getProof(leaves[2])
   *const verified = tree.verify(proof, leaves[2], root)
   *```
   */ verify(proof, targetNode, root) {
        let hash = this.bufferify(targetNode);
        root = this.bufferify(root);
        if (!Array.isArray(proof) || !targetNode || !root) {
            return false;
        }
        for(let i = 0; i < proof.length; i++){
            const node = proof[i];
            let data = null;
            let isLeftNode = null;
            // case for when proof is hex values only
            if (typeof node === "string") {
                data = this.bufferify(node);
                isLeftNode = true;
            } else if (Array.isArray(node)) {
                isLeftNode = node[0] === 0;
                data = this.bufferify(node[1]);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(node)) {
                data = node;
                isLeftNode = true;
            } else if (node instanceof Object) {
                data = this.bufferify(node.data);
                isLeftNode = node.position === "left";
            } else {
                throw new Error("Expected node to be of type string or object");
            }
            const buffers = [];
            if (this.isBitcoinTree) {
                buffers.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(hash));
                buffers[isLeftNode ? "unshift" : "push"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(data));
                hash = this.hashFn(this.concatenator(buffers));
                hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2d$reverse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.hashFn(hash));
            } else {
                if (this.sortPairs) {
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(hash, data) === -1) {
                        buffers.push(hash, data);
                        hash = this.hashFn(this.concatenator(buffers));
                    } else {
                        buffers.push(data, hash);
                        hash = this.hashFn(this.concatenator(buffers));
                    }
                } else {
                    buffers.push(hash);
                    buffers[isLeftNode ? "unshift" : "push"](data);
                    hash = this.hashFn(this.concatenator(buffers));
                }
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(hash, root) === 0;
    }
    /**
   * verifyMultiProof
   * @desc Returns true if the multiproofs can connect the leaves to the Merkle root.
   * @param {Buffer} root - Merkle tree root
   * @param {Number[]} proofIndices - Leave indices for proof
   * @param {Buffer[]} proofLeaves - Leaf values at indices for proof
   * @param {Number} leavesCount - Count of original leaves
   * @param {Buffer[]} proof - Multiproofs given indices
   * @return {Boolean}
   * @example
   *```js
   *const leaves = tree.getLeaves()
   *const root = tree.getRoot()
   *const treeFlat = tree.getLayersFlat()
   *const leavesCount = leaves.length
   *const proofIndices = [2, 5, 6]
   *const proofLeaves = proofIndices.map(i => leaves[i])
   *const proof = tree.getMultiProof(treeFlat, indices)
   *const verified = tree.verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof)
   *```
   */ verifyMultiProof(root, proofIndices, proofLeaves, leavesCount, proof) {
        const isUneven = this.isUnevenTree();
        if (isUneven) {
            // TODO: combine these functions and simplify
            return this.verifyMultiProofForUnevenTree(root, proofIndices, proofLeaves, leavesCount, proof);
        }
        const depth = Math.ceil(Math.log2(leavesCount));
        root = this.bufferify(root);
        proofLeaves = proofLeaves.map((leaf)=>this.bufferify(leaf));
        proof = proof.map((leaf)=>this.bufferify(leaf));
        const tree = {};
        for (const [index, leaf] of this.zip(proofIndices, proofLeaves)){
            // @ts-expect-error - issue from original code
            tree[2 ** depth + index] = leaf;
        }
        for (const [index, proofitem] of this.zip(this.getProofIndices(proofIndices, depth), proof)){
            // @ts-expect-error - issue from original code
            tree[index] = proofitem;
        }
        let indexqueue = Object.keys(tree).map((value)=>Number(value)).sort((a, b)=>a - b);
        indexqueue = indexqueue.slice(0, indexqueue.length - 1);
        let i = 0;
        while(i < indexqueue.length){
            const index = indexqueue[i];
            if (index >= 2 && ({}).hasOwnProperty.call(tree, index ^ 1)) {
                // @ts-expect-error - issue from original code
                let pair = [
                    tree[index - index % 2],
                    tree[index - index % 2 + 1]
                ];
                if (this.sortPairs) {
                    pair = pair.sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
                }
                const hash = pair[1] ? this.hashFn(this.concatenator(pair)) : pair[0];
                // @ts-expect-error - issue from original code
                tree[index / 2 | 0] = hash;
                indexqueue.push(index / 2 | 0);
            }
            i += 1;
        }
        return !proofIndices.length || // @ts-expect-error - issue from original code
        ({}).hasOwnProperty.call(tree, 1) && tree[1].equals(root);
    }
    verifyMultiProofWithFlags(root, leaves, proofs, proofFlag) {
        root = this.bufferify(root);
        leaves = leaves.map(this.bufferify);
        proofs = proofs.map(this.bufferify);
        const leavesLen = leaves.length;
        const totalHashes = proofFlag.length;
        const hashes = [];
        let leafPos = 0;
        let hashPos = 0;
        let proofPos = 0;
        for(let i = 0; i < totalHashes; i++){
            const bufA = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];
            const bufB = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            const buffers = [
                bufA,
                bufB
            ].sort(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare);
            hashes[i] = this.hashFn(this.concatenator(buffers));
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].compare(hashes[totalHashes - 1], root) === 0;
    }
    verifyMultiProofForUnevenTree(root, indices, leaves, leavesCount, proof) {
        root = this.bufferify(root);
        leaves = leaves.map((leaf)=>this.bufferify(leaf));
        proof = proof.map((leaf)=>this.bufferify(leaf));
        const computedRoot = this.calculateRootForUnevenTree(indices, leaves, leavesCount, proof);
        return root.equals(computedRoot);
    }
    /**
   * getDepth
   * @desc Returns the tree depth (number of layers)
   * @return {Number}
   * @example
   *```js
   *const depth = tree.getDepth()
   *```
   */ getDepth() {
        return this.getLayers().length - 1;
    }
    /**
   * getLayersAsObject
   * @desc Returns the layers as nested objects instead of an array.
   * @example
   *```js
   *const layersObj = tree.getLayersAsObject()
   *```
   */ getLayersAsObject() {
        const layers = this.getLayers().map((layer)=>layer.map((value)=>this.bufferToHex(value, false)));
        const objs = [];
        for(let i = 0; i < layers.length; i++){
            const arr = [];
            for(let j = 0; j < layers[i].length; j++){
                const obj = {
                    [layers[i][j]]: null
                };
                if (objs.length) {
                    // @ts-expect-error - issue from original code
                    obj[layers[i][j]] = {};
                    const a = objs.shift();
                    // @ts-expect-error - issue from original code
                    const akey = Object.keys(a)[0];
                    // @ts-expect-error - issue from original code
                    obj[layers[i][j]][akey] = a[akey];
                    if (objs.length) {
                        const b = objs.shift();
                        // @ts-expect-error - issue from original code
                        const bkey = Object.keys(b)[0];
                        // @ts-expect-error - issue from original code
                        obj[layers[i][j]][bkey] = b[bkey];
                    }
                }
                arr.push(obj);
            }
            objs.push(...arr);
        }
        return objs[0];
    }
    /**
   * resetTree
   * @desc Resets the tree by clearing the leaves and layers.
   * @example
   *```js
   *tree.resetTree()
   *```
   */ resetTree() {
        this.leaves = [];
        this.layers = [];
    }
    /**
   * getPairNode
   * @desc Returns the node at the index for given layer.
   * @param {Buffer[]} layer - Tree layer
   * @param {Number} index - Index at layer.
   * @return {Buffer} - Node
   *
   *@example
   * ```js
   *const node = tree.getPairNode(layer, index)
   *```
   */ getPairNode(layer, idx) {
        const pairIdx = idx % 2 === 0 ? idx + 1 : idx - 1;
        if (pairIdx < layer.length) {
            return layer[pairIdx];
        } else {
            // @ts-expect-error - issue from original code
            return null;
        }
    }
    /**
   * toTreeString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @return {String}
   * @example
   *```js
   *console.log(tree.toTreeString())
   *```
   */ toTreeString() {
        const obj = this.getLayersAsObject();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$treeify$2f$treeify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asTree"])(obj, true, false);
    }
    /**
   * toString
   * @desc Returns a visual representation of the merkle tree as a string.
   * @example
   *```js
   *console.log(tree.toString())
   *```
   */ toString() {
        return this.toTreeString();
    }
    isUnevenTree(treeLayers) {
        const depth = treeLayers?.length || this.getDepth();
        return !this.isPowOf2(depth);
    }
    isPowOf2(v) {
        return v && !(v & v - 1);
    }
    calculateRootForUnevenTree(leafIndices, leafHashes, totalLeavesCount, proofHashes) {
        const leafTuples = this.zip(leafIndices, leafHashes).sort((_ref2, _ref3)=>{
            let [indexA] = _ref2;
            let [indexB] = _ref3;
            return indexA - indexB;
        });
        const leafTupleIndices = leafTuples.map((_ref4)=>{
            let [index] = _ref4;
            return index;
        });
        const proofIndices = this.getProofIndicesForUnevenTree(leafTupleIndices, totalLeavesCount);
        let nextSliceStart = 0;
        const proofTuplesByLayers = [];
        for(let i = 0; i < proofIndices.length; i++){
            const indices = proofIndices[i];
            const sliceStart = nextSliceStart;
            nextSliceStart += indices.length;
            proofTuplesByLayers[i] = this.zip(indices, proofHashes.slice(sliceStart, nextSliceStart));
        }
        const tree = [
            leafTuples
        ];
        for(let layerIndex = 0; layerIndex < proofTuplesByLayers.length; layerIndex++){
            const currentLayer = proofTuplesByLayers[layerIndex].concat(tree[layerIndex])// @ts-expect-error - issue from original code
            .sort((_ref5, _ref6)=>{
                let [indexA] = _ref5;
                let [indexB] = _ref6;
                return indexA - indexB;
            })// @ts-expect-error - issue from original code
            .map((_ref7)=>{
                let [, hash] = _ref7;
                return hash;
            });
            const s = tree[layerIndex].map((_ref8)=>{
                let [layerIndex_] = _ref8;
                return layerIndex_;
            });
            const parentIndices = [
                ...new Set(s.map((index)=>{
                    if (index % 2 === 0) {
                        return index / 2;
                    }
                    if (index % 2 === 0) {
                        return (index + 1) / 2;
                    }
                    return (index - 1) / 2;
                }))
            ];
            const parentLayer = [];
            for(let i = 0; i < parentIndices.length; i++){
                const parentNodeTreeIndex = parentIndices[i];
                const bufA = currentLayer[i * 2];
                const bufB = currentLayer[i * 2 + 1];
                const hash = bufB ? this.hashFn(this.concatenator([
                    bufA,
                    bufB
                ])) : bufA;
                parentLayer.push([
                    parentNodeTreeIndex,
                    hash
                ]);
            }
            tree.push(parentLayer);
        }
        return tree[tree.length - 1][0][1];
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "A": (()=>newContractModelToAbstract),
    "B": (()=>BaseSignaturePayloadInput),
    "C": (()=>ClaimEligibility),
    "D": (()=>convertQuantityToBigNumber),
    "E": (()=>prepareClaim),
    "F": (()=>SnapshotFormatVersion),
    "G": (()=>GenericRequest),
    "H": (()=>processClaimConditionInputs),
    "I": (()=>abstractContractModelToLegacy),
    "J": (()=>abstractContractModelToNew),
    "K": (()=>updateExistingClaimConditions),
    "L": (()=>resolveOrGenerateId),
    "M": (()=>MintRequest20),
    "P": (()=>PartialClaimConditionInputSchema),
    "S": (()=>Signature20PayloadInput),
    "a": (()=>approveErc20Allowance),
    "b": (()=>createSnapshot),
    "c": (()=>convertToReadableQuantity),
    "d": (()=>createMerkleTreeFromAllowList),
    "e": (()=>ClaimConditionMetadataSchema),
    "f": (()=>fetchSnapshotEntryForAddress),
    "g": (()=>getProofsForAllowListEntry),
    "h": (()=>hashAllowListEntry),
    "i": (()=>ClaimConditionInputSchema),
    "j": (()=>ClaimConditionInputArray),
    "k": (()=>ClaimConditionOutputSchema),
    "l": (()=>CurrencySchema),
    "m": (()=>CurrencyValueSchema),
    "n": (()=>Signature20PayloadOutput),
    "o": (()=>Signature721PayloadInput),
    "p": (()=>Signature721PayloadOutput),
    "q": (()=>Signature1155PayloadInput),
    "r": (()=>Signature1155PayloadInputWithTokenId),
    "s": (()=>Signature1155PayloadOutput),
    "t": (()=>Signature721WithQuantityInput),
    "u": (()=>Signature721WithQuantityOutput),
    "v": (()=>MintRequest721),
    "w": (()=>MintRequest1155),
    "x": (()=>MintRequest721withQuantity),
    "y": (()=>transformResultToClaimCondition),
    "z": (()=>legacyContractModelToAbstract)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-client] (ecmascript) <export * as constants>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$merkletree$2f$dist$2f$thirdweb$2d$dev$2d$merkletree$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/merkletree/dist/thirdweb-dev-merkletree.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
;
;
;
;
;
;
;
;
;
function abstractContractModelToLegacy(model) {
    return {
        startTimestamp: model.startTimestamp,
        maxClaimableSupply: model.maxClaimableSupply,
        supplyClaimed: model.supplyClaimed,
        merkleRoot: model.merkleRoot,
        pricePerToken: model.pricePerToken,
        currency: model.currency,
        quantityLimitPerTransaction: model.maxClaimablePerWallet,
        waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0
    };
}
function abstractContractModelToNew(model) {
    return {
        startTimestamp: model.startTimestamp,
        maxClaimableSupply: model.maxClaimableSupply,
        supplyClaimed: model.supplyClaimed,
        merkleRoot: model.merkleRoot,
        pricePerToken: model.pricePerToken,
        currency: model.currency,
        quantityLimitPerWallet: model.maxClaimablePerWallet,
        metadata: model.metadata || ""
    };
}
/**
 * @internal
 * @param quantity - The quantity to convert
 * @param tokenDecimals - The token decimals to use
 */ function convertQuantityToBigNumber(quantity, tokenDecimals) {
    if (quantity === "unlimited") {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256;
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(quantity, tokenDecimals);
    }
}
async function parseSnapshotInputs(inputs) {
    const chunkSize = 25000;
    const chunks = Array.from({
        length: Math.ceil(inputs.length / chunkSize)
    }, (_, i)=>inputs.slice(i * chunkSize, i * chunkSize + chunkSize));
    const results = [];
    const parsedChunks = await Promise.all(chunks.map((chunk)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bM"].parseAsync(chunk)));
    for (const chunk of parsedChunks){
        results.push(...chunk);
    }
    return results;
}
// shard using the first 2 hex character of the address
// this splits the merkle tree into 256 shards
// shard files will be 00.json, 01.json, 02.json, ..., ff.json
const SHARD_NYBBLES = 2;
let SnapshotFormatVersion = /*#__PURE__*/ function(SnapshotFormatVersion) {
    SnapshotFormatVersion[SnapshotFormatVersion["V1"] = 1] = "V1";
    SnapshotFormatVersion[SnapshotFormatVersion["V2"] = 2] = "V2";
    return SnapshotFormatVersion;
}({}); // address, maxClaimable, price, currencyAddress
class ShardedMerkleTree {
    constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals){
        this.storage = storage;
        this.shardNybbles = shardNybbles;
        this.baseUri = baseUri;
        this.originalEntriesUri = originalEntriesUri;
        this.tokenDecimals = tokenDecimals;
        this.shards = {};
        this.trees = {};
    }
    static async fromUri(uri, storage) {
        try {
            const shardedMerkleTreeInfo = await storage.downloadJSON(uri);
            if (shardedMerkleTreeInfo.isShardedMerkleTree) {
                return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);
            }
        } catch (e) {
            return undefined;
        }
    }
    static async fromShardedMerkleTreeInfo(info, storage) {
        return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);
    }
    static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {
        switch(snapshotFormatVersion){
            case SnapshotFormatVersion.V1:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
                    "address",
                    "uint256"
                ], [
                    entry.address,
                    convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)
                ]);
            case SnapshotFormatVersion.V2:
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
                    "address",
                    "uint256",
                    "uint256",
                    "address"
                ], [
                    entry.address,
                    convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals),
                    convertQuantityToBigNumber(entry.price || "unlimited", currencyDecimals),
                    entry.currencyAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero
                ]);
        }
    }
    static async fetchAndCacheDecimals(cache, provider, currencyAddress) {
        if (!currencyAddress) {
            return 18;
        }
        // cache decimals for each currency to avoid refetching for every address
        let currencyDecimals = cache[currencyAddress];
        if (currencyDecimals === undefined) {
            const currencyMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(provider, currencyAddress);
            currencyDecimals = currencyMetadata.decimals;
            cache[currencyAddress] = currencyDecimals;
        }
        return currencyDecimals;
    }
    static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
        let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;
        const inputs = await parseSnapshotInputs(snapshotInput);
        // TODO Could also derive shardNybbles from input size
        const shards = {};
        for (const snapshotEntry of inputs){
            const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();
            if (shards[shard] === undefined) {
                shards[shard] = [];
            }
            shards[shard].push(snapshotEntry);
        }
        const currencyDecimalMap = {};
        // create shard => subtree root map
        const subTrees = await Promise.all(Object.entries(shards).map(async (_ref)=>{
            let [shard, entries] = _ref;
            return [
                shard,
                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$merkletree$2f$dist$2f$thirdweb$2d$dev$2d$merkletree$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MerkleTree"](await Promise.all(entries.map(async (entry)=>{
                    // cache decimals for each currency to avoid refetching for every address
                    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
                    return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);
                })), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].keccak256, {
                    sort: true
                }).getHexRoot()
            ];
        }));
        const roots = Object.fromEntries(subTrees);
        // create master tree from shard => subtree root map
        const tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$merkletree$2f$dist$2f$thirdweb$2d$dev$2d$merkletree$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MerkleTree"](Object.values(roots), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].keccak256, {
            sort: true
        });
        const shardsToUpload = [];
        for (const [shardId, entries] of Object.entries(shards)){
            const data = {
                proofs: tree.getProof(roots[shardId]).map((value)=>"0x" + value.data.toString("hex")),
                entries
            };
            shardsToUpload.push({
                data: JSON.stringify(data),
                name: `${shardId}.json`
            });
        }
        const uris = await storage.uploadBatch(shardsToUpload);
        const baseUri = uris[0].slice(0, uris[0].lastIndexOf("/"));
        const originalEntriesUri = await storage.upload(inputs);
        const shardedMerkleInfo = {
            merkleRoot: tree.getHexRoot(),
            baseUri,
            originalEntriesUri,
            shardNybbles,
            tokenDecimals,
            isShardedMerkleTree: true
        };
        const masterUri = await storage.upload(shardedMerkleInfo);
        return {
            shardedMerkleInfo,
            uri: masterUri
        };
    }
    async getProof(address, provider, snapshotFormatVersion) {
        const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();
        let shard = this.shards[shardId];
        const currencyDecimalMap = {};
        if (shard === undefined) {
            try {
                const uri = this.baseUri.endsWith("/") ? this.baseUri : `${this.baseUri}/`;
                shard = this.shards[shardId] = await this.storage.downloadJSON(`${uri}${shardId}.json`);
                const hashedEntries = await Promise.all(shard.entries.map(async (entry)=>{
                    // cache decimals for each currency to avoid refetching for every address
                    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
                    return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
                }));
                this.trees[shardId] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$merkletree$2f$dist$2f$thirdweb$2d$dev$2d$merkletree$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MerkleTree"](hashedEntries, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].keccak256, {
                    sort: true
                });
            } catch (e) {
                return null;
            }
        }
        const entry = shard.entries.find((i)=>i.address.toLowerCase() === address.toLowerCase());
        if (!entry) {
            return null;
        }
        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);
        const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);
        const proof = this.trees[shardId].getProof(leaf).map((i)=>"0x" + i.data.toString("hex"));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bN"].parseAsync({
            ...entry,
            proof: proof.concat(shard.proofs)
        });
    }
    async getAllEntries() {
        try {
            return await this.storage.downloadJSON(this.originalEntriesUri);
        } catch (e) {
            console.warn("Could not fetch original snapshot entries", e);
            return [];
        }
    }
}
/**
 * @internal
 */ async function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {
    if (!merkleMetadata) {
        return null;
    }
    const snapshotUri = merkleMetadata[merkleRoot];
    if (snapshotUri) {
        const raw = await storage.downloadJSON(snapshotUri);
        if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
            const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);
            return await merkleTree.getProof(address, provider, snapshotFormatVersion);
        }
        // legacy non-sharded, just fetch it all and filter out
        const snapshotData = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bO"].parseAsync(raw);
        if (merkleRoot === snapshotData.merkleRoot) {
            return snapshotData.claims.find((c)=>c.address.toLowerCase() === address.toLowerCase()) || null;
        }
    }
    return null;
}
function legacyContractModelToAbstract(model) {
    return {
        startTimestamp: model.startTimestamp,
        maxClaimableSupply: model.maxClaimableSupply,
        supplyClaimed: model.supplyClaimed,
        merkleRoot: model.merkleRoot.toString(),
        pricePerToken: model.pricePerToken,
        currency: model.currency,
        maxClaimablePerWallet: model.quantityLimitPerTransaction,
        waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims
    };
}
function newContractModelToAbstract(model) {
    return {
        startTimestamp: model.startTimestamp,
        maxClaimableSupply: model.maxClaimableSupply,
        supplyClaimed: model.supplyClaimed,
        merkleRoot: model.merkleRoot.toString(),
        pricePerToken: model.pricePerToken,
        currency: model.currency,
        maxClaimablePerWallet: model.quantityLimitPerWallet,
        waitTimeInSecondsBetweenClaims: 0,
        metadata: model.metadata
    };
}
/**
 * @internal
 */ async function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {
    const signer = contractToApprove.getSigner();
    const provider = contractToApprove.getProvider();
    const ERC20Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json (json, async loader)")(__turbopack_context__.i)).default;
    const erc20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);
    const owner = await contractToApprove.getSignerAddress();
    const spender = contractToApprove.address;
    const allowance = await erc20.read("allowance", [
        owner,
        spender
    ]);
    const totalPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(price).mul(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(quantity)).div(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits("1", tokenDecimals));
    if (allowance.lt(totalPrice)) {
        await erc20.sendTransaction("approve", [
            spender,
            allowance.add(totalPrice)
        ]);
    }
}
/**
 * Returns proofs and the overrides required for the transaction.
 * @internal
 * @returns  `overrides` and `proofs` as an object.
 */ async function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {
    let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);
    let proofs = [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad([
            0
        ], 32)
    ];
    let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs
    let currencyAddressInProof = activeClaimCondition.currencyAddress;
    try {
        if (!activeClaimCondition.merkleRootHash.toString().startsWith(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero)) {
            const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);
            if (snapshotEntry) {
                proofs = snapshotEntry.proof;
                // override only if not default values (unlimited for quantity, zero addr for currency)
                maxClaimable = snapshotEntry.maxClaimable === "unlimited" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(snapshotEntry.maxClaimable, tokenDecimals);
                priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === "unlimited" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256 : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero);
                currencyAddressInProof = snapshotEntry.currencyAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero;
            } else {
                // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim
                if (snapshotFormatVersion === SnapshotFormatVersion.V1) {
                    throw new Error("No claim found for this address");
                }
            // but if its snapshot v2 (override list behavior) then address can still claim with default settings
            }
        }
    } catch (e) {
        // have to handle the valid error case that we *do* want to throw on
        if (e?.message === "No claim found for this address") {
            throw e;
        }
        // other errors we wanna ignore and try to continue
        console.warn("failed to check claim condition merkle root hash, continuing anyways", e);
    }
    const overrides = await contractWrapper.getCallOverrides() || {};
    // the actual price to check allowance against
    // if proof price is unlimited, then we use the price from the claim condition
    // this mimics the contract behavior
    const pricePerToken = priceInProof.toString() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256.toString() ? priceInProof : activeClaimCondition.price;
    // same for currency address
    const currencyAddress = currencyAddressInProof !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;
    if (pricePerToken.gt(0)) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(currencyAddress)) {
            overrides["value"] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(pricePerToken).mul(quantity).div(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits("1", tokenDecimals));
        } else if (checkERC20Allowance) {
            await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);
        }
    }
    return {
        overrides,
        proofs,
        maxClaimable,
        price: pricePerToken,
        currencyAddress: currencyAddress,
        priceInProof,
        currencyAddressInProof
    };
}
/**
 * @internal
 */ const CurrencySchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        symbol: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        decimals: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number()
    }))();
/**
 * @internal
 */ const CurrencyValueSchema = /* @__PURE__ */ (()=>CurrencySchema.extend({
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        displayValue: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }))();
/**
 * @internal
 */ const ClaimConditionMetadataSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    }).catchall(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()))();
/**
 * @internal
 */ const ClaimConditionInputSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        startTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"],
        currencyAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]),
        price: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].default(0),
        maxClaimableSupply: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cA"],
        maxClaimablePerWallet: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cA"],
        waitInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(0),
        merkleRootHash: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cB"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad([
            0
        ], 32)),
        snapshot: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bM"]).nullable(),
        metadata: ClaimConditionMetadataSchema.optional()
    }))();
/**
 * @internal
 */ const ClaimConditionInputArray = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(ClaimConditionInputSchema))();
/**
 * @internal
 */ const PartialClaimConditionInputSchema = /* @__PURE__ */ (()=>ClaimConditionInputSchema.partial())();
/**
 * @internal
 */ const ClaimConditionOutputSchema = /* @__PURE__ */ (()=>ClaimConditionInputSchema.extend({
        availableSupply: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cA"],
        currentMintSupply: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cA"],
        currencyMetadata: CurrencyValueSchema.default({
            value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from("0"),
            displayValue: "0",
            symbol: "",
            decimals: 18,
            name: ""
        }),
        price: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        waitInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        startTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"].transform((n)=>new Date(n.toNumber() * 1000)),
        snapshot: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bM"].optional().nullable()
    }))();
/**
 * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS
 * @param snapshotInput - the list of addresses to hash
 * @param tokenDecimals - the token decimals
 * @param provider - the provider to use
 * @param storage - the storage to upload to
 * @param snapshotFormatVersion - the snapshot format version
 * @returns The generated snapshot and URI
 * @internal
 */ async function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {
    const input = await parseSnapshotInputs(snapshotInput);
    const addresses = input.map((i)=>i.address);
    const hasDuplicates = new Set(addresses).size < addresses.length;
    if (hasDuplicates) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"]();
    }
    const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);
    return {
        merkleRoot: tree.shardedMerkleInfo.merkleRoot,
        snapshotUri: tree.uri
    };
}
/**
 * Create a MerkleTree based on an allow list of addresses and maxClaimable
 * @param snapshotInput - the list of addresses and maxClaimable
 * @param tokenDecimals - optional decimals for the token to claim (default 18)
 * @param version - optional version of the snapshot format (default V1)
 * @returns The generated MerkleTree
 */ async function createMerkleTreeFromAllowList(snapshotInput) {
    let tokenDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 18;
    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SnapshotFormatVersion.V1;
    const input = await parseSnapshotInputs(snapshotInput);
    const addresses = input.map((i)=>i.address);
    const hasDuplicates = new Set(addresses).size < addresses.length;
    if (hasDuplicates) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"]();
    }
    const leaves = input.map((i)=>{
        return hashAllowListEntry(i, tokenDecimals, version);
    });
    const tree = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$merkletree$2f$dist$2f$thirdweb$2d$dev$2d$merkletree$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MerkleTree"](leaves, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].keccak256, {
        sort: true
    });
    return tree;
}
/**
 * Get the proofs for a given entry of addresses
 * @param merkleTree - the merkle tree to get the proof from
 * @param snapshotEntry - the entry to get the proof for
 * @param tokenDecimals - optional decimals for the token to claim (default 18)
 * @param version - optional version of the snapshot format (default V1)
 * @returns
 */ async function getProofsForAllowListEntry(merkleTree, snapshotEntry) {
    let tokenDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 18;
    let version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : SnapshotFormatVersion.V1;
    return merkleTree.getProof(hashAllowListEntry(snapshotEntry, tokenDecimals, version)).map((value)=>"0x" + value.data.toString("hex"));
}
/**
 * Hash an allow list entry for use in a MerkleTree
 * @param snapshotEntry - the entry to hash
 * @param tokenDecimals - optional decimals for the token to claim (default 18)
 * @param version - optional version of the snapshot format (default V1)
 * @returns
 */ function hashAllowListEntry(snapshotEntry) {
    let tokenDecimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 18;
    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : SnapshotFormatVersion.V1;
    return ShardedMerkleTree.hashEntry(snapshotEntry, tokenDecimals, tokenDecimals, version);
}
function compare(a, b) {
    const left = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(a);
    const right = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(b);
    if (left.eq(right)) {
        return 0;
    } else if (left.gt(right)) {
        return 1;
    } else {
        return -1;
    }
}
/**
 * @internal
 * Decorates claim conditions with merkle roots from snapshots if present
 * @param claimConditionInputs - The claim conditions to process
 * @param tokenDecimals - The token decimals to use
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param snapshotFormatVersion - The snapshot format version to use
 */ async function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
    const snapshotInfos = [];
    const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async (conditionInput)=>{
        // check snapshots and upload if provided
        if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {
            const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);
            snapshotInfos.push(snapshotInfo);
            conditionInput.merkleRootHash = snapshotInfo.merkleRoot;
        } else {
            // if no snapshot is passed or empty, reset the merkle root
            conditionInput.merkleRootHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad([
                0
            ], 32);
        }
        // fill condition with defaults values if not provided
        return conditionInput;
    }));
    return {
        inputsWithSnapshots,
        snapshotInfos
    };
}
/**
 * Converts a local SDK model to contract model
 * @param c - The condition input
 * @param tokenDecimals - The token decimals to use
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @internal
 */ async function convertToContractModel(c, tokenDecimals, provider, storage) {
    const currency = c.currencyAddress === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"] : c.currencyAddress;
    const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);
    const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);
    let metadataOrUri;
    if (c.metadata) {
        if (typeof c.metadata === "string") {
            metadataOrUri = c.metadata;
        } else {
            metadataOrUri = await storage.upload(c.metadata);
        }
    }
    return {
        startTimestamp: c.startTime,
        maxClaimableSupply,
        supplyClaimed: 0,
        maxClaimablePerWallet,
        pricePerToken: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(provider, c.price, currency),
        currency,
        merkleRoot: c.merkleRootHash.toString(),
        waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,
        metadata: metadataOrUri
    };
}
/**
 * Create and uploads snapshots + converts claim conditions to contract format
 * @param claimConditionInputs - The claim conditions to process
 * @param tokenDecimals - The token decimals to use
 * @param provider - The provider to use
 * @param storage - The storage to use
 * @param snapshotFormatVersion - The snapshot format version to use
 * @internal
 */ async function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {
    const { inputsWithSnapshots, snapshotInfos } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);
    const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);
    // Convert processed inputs to the format the contract expects, and sort by timestamp
    const sortedConditions = (await Promise.all(parsedInputs.map((c)=>convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b)=>{
        return compare(a.startTimestamp, b.startTimestamp);
    });
    return {
        snapshotInfos,
        sortedConditions
    };
}
/**
 * @internal
 * @param merkleRoot - The merkle root to fetch the snapshot for
 * @param merkleMetadata - The merkle metadata to use
 * @param storage - The storage to use
 */ async function fetchSnapshot(merkleRoot, merkleMetadata, storage) {
    if (!merkleMetadata) {
        return null;
    }
    const snapshotUri = merkleMetadata[merkleRoot];
    if (snapshotUri) {
        const raw = await storage.downloadJSON(snapshotUri);
        if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {
            const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);
            return smt?.getAllEntries() || null;
        } else {
            const snapshotData = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bO"].parseAsync(raw);
            if (merkleRoot === snapshotData.merkleRoot) {
                return snapshotData.claims.map((claim)=>({
                        address: claim.address,
                        maxClaimable: claim.maxClaimable,
                        price: claim.price,
                        currencyAddress: claim.currencyAddress
                    }));
            }
        }
    }
    return null;
}
/**
 * @internal
 * @param bn - The big number to convert
 * @param tokenDecimals - The token decimals to use
 */ function convertToReadableQuantity(bn, tokenDecimals) {
    if (bn.toString() === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256.toString()) {
        return "unlimited";
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatUnits(bn, tokenDecimals);
    }
}
/**
 * Transforms a contract model to local model
 * @param pm - The contract model to transform
 * @param tokenDecimals - The token decimals to use
 * @param provider - The provider to use
 * @param merkleMetadata - The merkle metadata to use
 * @param storage - The storage to use
 * @param shouldDownloadSnapshot - Whether to download the snapshot
 * @internal
 */ async function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {
    const cv = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(provider, pm.currency, pm.pricePerToken);
    const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);
    const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);
    const availableSupply = convertToReadableQuantity(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);
    const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);
    let resolvedMetadata;
    if (pm.metadata) {
        resolvedMetadata = await storage.downloadJSON(pm.metadata);
    }
    return ClaimConditionOutputSchema.parseAsync({
        startTime: pm.startTimestamp,
        maxClaimableSupply,
        maxClaimablePerWallet,
        currentMintSupply,
        availableSupply,
        waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),
        price: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(pm.pricePerToken),
        currency: pm.currency,
        currencyAddress: pm.currency,
        currencyMetadata: cv,
        merkleRootHash: pm.merkleRoot,
        snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,
        metadata: resolvedMetadata
    });
}
/**
 * @internal
 * @param index - The index of the condition to update
 * @param claimConditionInput - The input claim condition to update
 * @param existingConditions - The existing claim conditions
 */ async function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {
    if (index >= existingConditions.length) {
        throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);
    }
    // merge input with existing claim condition
    const priceDecimals = existingConditions[index].currencyMetadata.decimals;
    const priceInWei = existingConditions[index].price;
    const priceInTokens = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatUnits(priceInWei, priceDecimals);
    // merge existing (output format) with incoming (input format)
    const newConditionParsed = await ClaimConditionInputSchema.parseAsync({
        ...existingConditions[index],
        price: priceInTokens,
        ...claimConditionInput
    });
    // convert to output claim condition
    const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({
        ...newConditionParsed,
        price: priceInWei
    });
    return existingConditions.map((existingOutput, i)=>{
        let newConditionAtIndex;
        if (i === index) {
            newConditionAtIndex = mergedConditionOutput;
        } else {
            newConditionAtIndex = existingOutput;
        }
        const formattedPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatUnits(newConditionAtIndex.price, priceDecimals);
        return {
            ...newConditionAtIndex,
            price: formattedPrice // manually transform back to input price type
        };
    });
}
let ClaimEligibility = /*#__PURE__*/ function(ClaimEligibility) {
    ClaimEligibility["NotEnoughSupply"] = "There is not enough supply to claim.";
    ClaimEligibility["AddressNotAllowed"] = "This address is not on the allowlist.";
    ClaimEligibility["WaitBeforeNextClaimTransaction"] = "Not enough time since last claim transaction. Please wait.";
    ClaimEligibility["ClaimPhaseNotStarted"] = "Claim phase has not started yet.";
    ClaimEligibility["AlreadyClaimed"] = "You have already claimed the token.";
    ClaimEligibility["WrongPriceOrCurrency"] = "Incorrect price or currency.";
    ClaimEligibility["OverMaxClaimablePerWallet"] = "Cannot claim more than maximum allowed quantity.";
    ClaimEligibility["NotEnoughTokens"] = "There are not enough tokens in the wallet to pay for the claim.";
    ClaimEligibility["NoActiveClaimPhase"] = "There is no active claim phase at the moment. Please check back in later.";
    ClaimEligibility["NoClaimConditionSet"] = "There is no claim condition set.";
    ClaimEligibility["NoWallet"] = "No wallet connected.";
    ClaimEligibility["Unknown"] = "No claim conditions found.";
    return ClaimEligibility;
}({});
function resolveOrGenerateId(requestUId) {
    if (requestUId === undefined) {
        const buffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].alloc(16);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])({}, buffer);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexlify(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes(buffer.toString("hex")));
    } else {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexlify(requestUId);
    }
}
/**
 * @internal
 */ const BaseSignaturePayloadInput = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        to: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].refine((address)=>address.toLowerCase() !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero, {
            message: "Cannot create payload to mint to zero address"
        }),
        price: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].default(0),
        currencyAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b8"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]),
        mintStartTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"],
        mintEndTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"],
        uid: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional().transform((arg)=>resolveOrGenerateId(arg)),
        primarySaleRecipient: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero)
    }))();
/**
 * @internal
 */ const Signature20PayloadInput = /* @__PURE__ */ (()=>BaseSignaturePayloadInput.extend({
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"]
    }))();
/**
 * @internal
 */ const Signature20PayloadOutput = /* @__PURE__ */ (()=>Signature20PayloadInput.extend({
        mintStartTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        mintEndTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"]
    }))();
/**
 * @internal
 */ const Signature721PayloadInput = /* @__PURE__ */ (()=>BaseSignaturePayloadInput.extend({
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["N"],
        royaltyRecipient: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero),
        royaltyBps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cC"].default(0)
    }))();
/**
 * @internal
 */ const Signature721PayloadOutput = /* @__PURE__ */ (()=>Signature721PayloadInput.extend({
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["N"].default(""),
        uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        royaltyBps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        mintStartTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        mintEndTime: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"]
    }))();
/**
 * @internal
 */ const Signature1155PayloadInput = /* @__PURE__ */ (()=>Signature721PayloadInput.extend({
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["N"].default(""),
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"]
    }))();
/**
 * @internal
 */ const Signature1155PayloadInputWithTokenId = /* @__PURE__ */ (()=>Signature1155PayloadInput.extend({
        tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"]
    }))();
/**
 * @internal
 */ const Signature1155PayloadOutput = /* @__PURE__ */ (()=>Signature721PayloadOutput.extend({
        tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"],
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"]
    }))();
/**
 * @internal
 */ const Signature721WithQuantityInput = /* @__PURE__ */ (()=>Signature721PayloadInput.extend({
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["N"].default(""),
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"].default(1)
    }))();
/**
 * @internal
 */ const Signature721WithQuantityOutput = /* @__PURE__ */ (()=>Signature721PayloadOutput.extend({
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"].default(1)
    }))();
/**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ /**
 * @public
 */ const MintRequest20 = [
    {
        name: "to",
        type: "address"
    },
    {
        name: "primarySaleRecipient",
        type: "address"
    },
    {
        name: "quantity",
        type: "uint256"
    },
    {
        name: "price",
        type: "uint256"
    },
    {
        name: "currency",
        type: "address"
    },
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
const MintRequest721 = [
    {
        name: "to",
        type: "address"
    },
    {
        name: "royaltyRecipient",
        type: "address"
    },
    {
        name: "royaltyBps",
        type: "uint256"
    },
    {
        name: "primarySaleRecipient",
        type: "address"
    },
    {
        name: "uri",
        type: "string"
    },
    {
        name: "price",
        type: "uint256"
    },
    {
        name: "currency",
        type: "address"
    },
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
const MintRequest1155 = [
    {
        name: "to",
        type: "address"
    },
    {
        name: "royaltyRecipient",
        type: "address"
    },
    {
        name: "royaltyBps",
        type: "uint256"
    },
    {
        name: "primarySaleRecipient",
        type: "address"
    },
    {
        name: "tokenId",
        type: "uint256"
    },
    {
        name: "uri",
        type: "string"
    },
    {
        name: "quantity",
        type: "uint256"
    },
    {
        name: "pricePerToken",
        type: "uint256"
    },
    {
        name: "currency",
        type: "address"
    },
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
const MintRequest721withQuantity = [
    {
        name: "to",
        type: "address"
    },
    {
        name: "royaltyRecipient",
        type: "address"
    },
    {
        name: "royaltyBps",
        type: "uint256"
    },
    {
        name: "primarySaleRecipient",
        type: "address"
    },
    {
        name: "uri",
        type: "string"
    },
    {
        name: "quantity",
        type: "uint256"
    },
    {
        name: "pricePerToken",
        type: "uint256"
    },
    {
        name: "currency",
        type: "address"
    },
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
const GenericRequest = [
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    },
    {
        name: "data",
        type: "bytes"
    }
];
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/airdrop-erc1155-f9016b81.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "A": (()=>Account),
    "C": (()=>ContractPublishedMetadata),
    "D": (()=>DEFAULT_PERMISSIONS),
    "E": (()=>ExtensionManager),
    "P": (()=>PermissionSnapshotSchema),
    "S": (()=>SignerPermissionsSchema),
    "a": (()=>AccountFactory),
    "b": (()=>Airdrop20),
    "c": (()=>Airdrop721),
    "d": (()=>Airdrop1155),
    "e": (()=>extractEventsFromAbi),
    "f": (()=>AdminFlag),
    "g": (()=>SignerPermissionRequestV1),
    "h": (()=>SignerPermissionRequest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchSourceFilesFromMetadata$2d$906c835e$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchSourceFilesFromMetadata-906c835e.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/deployContractDeterministic-7823c15c.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
let AdminFlag = /*#__PURE__*/ function(AdminFlag) {
    AdminFlag[AdminFlag["None"] = 0] = "None";
    AdminFlag[AdminFlag["AddAdmin"] = 1] = "AddAdmin";
    AdminFlag[AdminFlag["RemoveAdmin"] = 2] = "RemoveAdmin";
    return AdminFlag;
}({});
const DEFAULT_PERMISSIONS = {
    // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
    startDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
    // eslint-disable-next-line better-tree-shaking/no-top-level-side-effects
    expirationDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
    approvedCallTargets: [],
    nativeTokenLimitPerTransaction: "0"
};
const SignerPermissionsSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        startDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"],
        expirationDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"],
        nativeTokenLimitPerTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].default(0),
        approvedCallTargets: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"]),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("*")
        ])
    }))();
const PermissionSnapshotSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        signer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"],
        makeAdmin: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        permissions: SignerPermissionsSchema
    })))();
const SignerPermissionRequestV1 = [
    {
        name: "signer",
        type: "address"
    },
    {
        name: "approvedTargets",
        type: "address[]"
    },
    {
        name: "nativeTokenLimitPerTransaction",
        type: "uint256"
    },
    {
        name: "permissionStartTimestamp",
        type: "uint128"
    },
    {
        name: "permissionEndTimestamp",
        type: "uint128"
    },
    {
        name: "reqValidityStartTimestamp",
        type: "uint128"
    },
    {
        name: "reqValidityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
const SignerPermissionRequest = [
    {
        name: "signer",
        type: "address"
    },
    {
        name: "isAdmin",
        type: "uint8"
    },
    {
        name: "approvedTargets",
        type: "address[]"
    },
    {
        name: "nativeTokenLimitPerTransaction",
        type: "uint256"
    },
    {
        name: "permissionStartTimestamp",
        type: "uint128"
    },
    {
        name: "permissionEndTimestamp",
        type: "uint128"
    },
    {
        name: "reqValidityStartTimestamp",
        type: "uint128"
    },
    {
        name: "reqValidityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    }
];
class AccountPermissions {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /*********************************
   * HELPER FUNCTIONS
   ********************************/ hasDuplicateSigners(snapshot) {
        const checkedSigner = {};
        const signers = snapshot.map((item)=>item.signer);
        for (const signer of signers){
            if (!checkedSigner[signer]) {
                checkedSigner[signer] = true;
            } else {
                return true;
            }
        }
        return false;
    }
    /**
   * Format the access restrictions for a given role
   *
   * @param restrictions - The access restrictions for a given role
   * @returns formatted role restrictions
   *
   */ parseSignerPermissionsStruct(permissions) {
        return {
            startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1000),
            expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1000),
            nativeTokenLimitPerTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(permissions.nativeTokenLimitPerTransaction),
            approvedCallTargets: permissions.approvedTargets
        };
    }
    async sendSignerPermissionRequest(signerAddress, permissions, adminFlag) {
        const { payload, signature } = await this.generatePayload(signerAddress, permissions, adminFlag);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setPermissionsForSigner",
            args: [
                payload,
                signature
            ]
        });
    }
    /**
   * Generate and sign a payload to grant or revoke a signer's access to the account.
   *
   * @param signer - The address of the signer
   * @param roleAction - The address of the signer
   * @returns The generated payload and signature produced on signing that payload.
   *
   */ async generatePayload(signerAddress, permissions, isAdmin) {
        // Get payload struct.
        const payload = {
            signer: signerAddress,
            isAdmin: isAdmin.valueOf(),
            approvedTargets: permissions.approvedCallTargets === "*" ? [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cu"]
            ] : permissions.approvedCallTargets,
            nativeTokenLimitPerTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseEther(permissions.nativeTokenLimitPerTransaction),
            permissionStartTimestamp: permissions.startDate,
            permissionEndTimestamp: permissions.expirationDate,
            reqValidityStartTimestamp: 0,
            // Req validity ends 10 years from now.
            reqValidityEndTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Math.floor(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10).getTime() / 1000)),
            uid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["L"])(undefined)
        };
        // Generate signature
        const chainId = await this.contractWrapper.getChainID();
        const connectedSigner = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(connectedSigner, "No signer available");
        const signature = await this.contractWrapper.signTypedData(connectedSigner, {
            name: "Account",
            version: "1",
            chainId,
            verifyingContract: this.getAddress()
        }, {
            SignerPermissionRequest
        }, payload);
        return {
            payload,
            signature
        };
    }
    async generateLegacyPayload(signerAddress, permissions) {
        if (permissions.approvedCallTargets === "*") {
            throw new Error("Wildcard call targets are not supported on legacy account permissions contract, please deploy an updated contract factory.");
        }
        // legacy account permissions contract
        // admin is set only via EOA
        // signer permissions are set via EOA or admin but no wildcard
        const payload = {
            signer: signerAddress,
            approvedTargets: permissions.approvedCallTargets,
            nativeTokenLimitPerTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseEther(permissions.nativeTokenLimitPerTransaction),
            permissionStartTimestamp: permissions.startDate,
            permissionEndTimestamp: permissions.expirationDate,
            reqValidityStartTimestamp: 0,
            // Req validity ends 10 years from now.
            reqValidityEndTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Math.floor(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10).getTime() / 1000)),
            uid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["L"])(undefined)
        };
        const chainId = await this.contractWrapper.getChainID();
        const connectedSigner = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(connectedSigner, "No signer available");
        const signature = await this.contractWrapper.signTypedData(connectedSigner, {
            name: "Account",
            version: "1",
            chainId,
            verifyingContract: this.getAddress()
        }, {
            SignerPermissionRequest: SignerPermissionRequestV1
        }, payload);
        return {
            payload,
            signature
        };
    }
    /*********************************
   * READ FUNCTIONS
   ********************************/ /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */ async isAdmin(signerAddress) {
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        return await this.contractWrapper.read("isAdmin", [
            resolvedSignerAddress
        ]);
    }
    /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async isSigner(signerAddress) {
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        return await this.contractWrapper.read("isActiveSigner", [
            resolvedSignerAddress
        ]);
    }
    /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns All admins of the account.
   *
   * @twfeature AccountPermissions
   */ async getAllAdmins() {
        return await this.contractWrapper.read("getAllAdmins", []);
    }
    /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns All (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async getAllSigners() {
        const activeSignersWithPerms = await this.contractWrapper.read("getAllActiveSigners", []);
        return await Promise.all(activeSignersWithPerms.map(async (signerWithPermissions)=>{
            const signer = signerWithPermissions.signer;
            const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);
            return {
                signer,
                permissions
            };
        }));
    }
    /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns All admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async getAllAdminsAndSigners() {
        const allAdmins = await this.getAllAdmins();
        const transformedAdmins = allAdmins.map((admin)=>{
            return {
                isAdmin: true,
                signer: admin,
                permissions: {
                    startDate: new Date(0),
                    expirationDate: new Date(0),
                    nativeTokenLimitPerTransaction: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
                    approvedCallTargets: []
                }
            };
        });
        const allSigners = await this.getAllSigners();
        return [
            ...transformedAdmins,
            ...allSigners
        ];
    }
    /*********************************
   * WRITE FUNCTIONS
   ********************************/ /**
   * Grant an address admin access to the account.
   *
   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
   *
   * @param signer - The address to be granted admin access to the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.grantAdminAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ grantAdminPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin);
    });
    /**
   * Revoke an address' admin access to the account.
   *
   * @remarks Revokes an address' admin access to the account.
   *
   * @param signer - The address of an admin of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.revokeAdminAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ revokeAdminPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin);
    });
    /**
   * Grant a signer permissions to use the account.
   *
   * @remarks Grants a signer permissions to use the account.
   *
   * @param signer - The signer to be granted permissions to use the account.
   * @param permissions - The permissions to be applied to the signer's use of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.grantPermissions(signer, permissions);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ grantPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, permissions)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    });
    /**
   * Update the permissions of a signer for using the account.
   *
   * @remarks Updates the permissions of a signer for using the account.
   *
   * @param signer - The signer whose permissions to use the account are to be updated.
   * @param permissions - The permissions to be applied to the signer's use of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.updatePermissions(signer, permissions);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ updatePermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, permissions)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);
        if (await this.isAdmin(resolvedSignerAddress)) {
            throw new Error("Signer is already an admin. Cannot update permissions of an existing admin.");
        }
        if (!await this.isSigner(resolvedSignerAddress)) {
            throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
        }
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions, AdminFlag.None);
    });
    /**
   * Revoke a scoped access address to the account
   *
   * @remarks Revokes an address' access to the account.
   *
   * @param signer - The address whose access to the account is to be revoked.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.revokeAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ revokeAccess = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
            startDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
            expirationDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
            approvedCallTargets: [],
            nativeTokenLimitPerTransaction: "0"
        }, AdminFlag.None);
    });
    /**
   * Approve an address as a call target for a given signer on the account
   *
   * @remarks Approves an address as a call target for a given signer on the account.
   *
   * @param signer - A signer with restricted access to the account.
   * @param target - The address to approve as a call target for the signer.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.approveTargetForSigner(signer, target);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ approveTargetForSigner = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, target)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        const resolvedTarget = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(target);
        if (await this.isAdmin(resolvedSignerAddress)) {
            throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
        }
        if (!await this.isSigner(resolvedSignerAddress)) {
            throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
        }
        const permissions = await this.contractWrapper.read("getPermissionsForSigner", [
            resolvedSignerAddress
        ]);
        if (permissions.approvedTargets.includes(target)) {
            throw new Error("Target is already approved");
        }
        const newTargets = [
            ...permissions.approvedTargets,
            resolvedTarget
        ];
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
            startDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(permissions.startTimestamp),
            expirationDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(permissions.endTimestamp),
            approvedCallTargets: newTargets,
            nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
        }, AdminFlag.None);
    });
    /**
   * Disapprove an address as a call target for a given signer on the account
   *
   * @remarks Disapprove an address as a call target for a given signer on the account.
   *
   * @param signer - A signer with restricted access to the account.
   * @param target - The address to disapprove as a call target for the signer.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.disapproveTargetForSigner(signer, target);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ disapproveTargetForSigner = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, target)=>{
        const resolvedSignerAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(signerAddress);
        const resolvedTarget = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(target);
        if (await this.isAdmin(resolvedSignerAddress)) {
            throw new Error("Signer is already an admin. Cannot approve targets for an admin.");
        }
        if (!await this.isSigner(resolvedSignerAddress)) {
            throw new Error("Signer does not already have permissions. You can grant permissions using `grantPermissions`.");
        }
        const permissions = await this.contractWrapper.read("getPermissionsForSigner", [
            resolvedSignerAddress
        ]);
        if (!permissions.approvedTargets.includes(resolvedTarget)) {
            throw new Error("Target is currently not approved");
        }
        const newTargets = permissions.approvedTargets.filter((approvedTarget)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(approvedTarget) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].getAddress(resolvedTarget));
        return await this.sendSignerPermissionRequest(resolvedSignerAddress, {
            startDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(permissions.startTimestamp),
            expirationDate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(permissions.endTimestamp),
            approvedCallTargets: newTargets,
            nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()
        }, AdminFlag.None);
    });
    /**
   * Set the account's entire snapshot of permissions.
   *
   * @remarks Sets the account's entire snapshot of permissions.
   *
   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.setAccess(permissionSnapshot);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ resetAllPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (permissionSnapshot)=>{
        const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);
        /**
     * All cases
     *
     * - Add new admin :check:
     * - Remove current admin :check:
     * - Add new scoped :check:
     * - Remove current scoped :check:
     * - Update current scoped :check:
     * - Current admin - new scoped :check:
     * - Current scoped - new admin :check:
     **/ // No duplicate signers in input!
        if (this.hasDuplicateSigners(resolvedSnapshot)) {
            throw new Error("Duplicate signers found in input.");
        }
        const removeAdminData = [];
        const addOrUpdateSignerData = [];
        const removeSignerData = [];
        // Remove all existing admins not included in the passed snapshot.
        const allAdmins = await this.getAllAdmins();
        const allToMakeAdmin = resolvedSnapshot.filter((item)=>item.makeAdmin).map((item)=>item.signer);
        allAdmins.forEach(async (admin)=>{
            if (!allToMakeAdmin.includes(admin)) {
                const data = (await this.sendSignerPermissionRequest(admin, DEFAULT_PERMISSIONS, AdminFlag.RemoveAdmin)).encode();
                removeAdminData.push(data);
            }
        });
        // Remove all existing signers not included in the passed snapshot.
        const allSigners = await this.getAllSigners();
        const allToMakeSigners = resolvedSnapshot.filter((item)=>{
            return !item.makeAdmin;
        }).map((item)=>item.signer);
        await Promise.all(allSigners.map(async (item)=>{
            if (!allToMakeSigners.includes(item.signer)) {
                const data = (await this.sendSignerPermissionRequest(item.signer, DEFAULT_PERMISSIONS, AdminFlag.None)).encode();
                removeSignerData.push(data);
            }
        }));
        for (const member of resolvedSnapshot){
            // Add new admin
            if (member.makeAdmin) {
                (await this.sendSignerPermissionRequest(member.signer, DEFAULT_PERMISSIONS, AdminFlag.AddAdmin)).encode();
            } else {
                // Add new scoped
                const data = (await this.sendSignerPermissionRequest(member.signer, member.permissions, AdminFlag.None)).encode();
                addOrUpdateSignerData.push(data);
            }
        }
        const data = [];
        removeAdminData.forEach((item)=>{
            data.push(item);
        });
        removeSignerData.forEach((item)=>{
            data.push(item);
        });
        addOrUpdateSignerData.forEach((item)=>{
            data.push(item);
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                data
            ]
        });
    });
}
/**
 * Interact with ERC-4337 accounts
 * @remarks Exposes useful functions available on account contracts.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.account.getAllAdminsAndSigners();
 * ```
 * @public
 */ class Account {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dn"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
        this.accountPermissions = this.detectAccountPermissions();
    }
    detectAccountPermissions() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AccountPermissions") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AccountPermissionsV1")) {
            return new AccountPermissions(this.contractWrapper);
        }
        return undefined;
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /*********************************
   * READ FUNCTIONS
   ********************************/ /**
   * Get whether a signer is an admin on the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isAdmin(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer is an admin on the account.
   *
   * @twfeature AccountPermissions
   */ async isAdmin(signerAddress) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).isAdmin(signerAddress);
    }
    /**
   * Get whether a signer has permissions to use the account.
   *
   * @example
   * ```javascript
   * const isAdmin = await contract.account.isSigner(signer);
   * ```
   * @param signer - The address of a signer of the account.
   * @returns whether a signer has permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async isSigner(signerAddress) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).isSigner(signerAddress);
    }
    /**
   * Get all admins of the account.
   *
   * @example
   * ```javascript
   * const allAdmins = await contract.account.getAllAdmins();
   * ```
   *
   * @returns All admins of the account.
   *
   * @twfeature AccountPermissions
   */ async getAllAdmins() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).getAllAdmins();
    }
    /**
   * Get all (non-admin) signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allSigners = await contract.account.getAllSigners();
   * ```
   *
   * @returns All (non-admin) signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async getAllSigners() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).getAllSigners();
    }
    /**
   * Get all admins and non-admin signers with permissions to use the account.
   *
   * @example
   * ```javascript
   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();
   * ```
   *
   * @returns All admins and non-admin signers with permissions to use the account.
   *
   * @twfeature AccountPermissions
   */ async getAllAdminsAndSigners() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).getAllAdminsAndSigners();
    }
    /*********************************
   * WRITE FUNCTIONS
   ********************************/ /**
   * Grant an address admin access to the account.
   *
   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.
   *
   * @param signer - The address to be granted admin access to the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.grantAdminAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ grantAdminPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).grantAdminPermissions.prepare(signerAddress);
    });
    /**
   * Revoke an address' admin access to the account.
   *
   * @remarks Revokes an address' admin access to the account.
   *
   * @param signer - The address of an admin of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.revokeAdminAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ revokeAdminPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).revokeAdminPermissions.prepare(signerAddress);
    });
    /**
   * Grant a signer permissions to use the account.
   *
   * @remarks Grants a signer permissions to use the account.
   *
   * @param signer - The signer to be granted permissions to use the account.
   * @param permissions - The permissions to be applied to the signer's use of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.grantPermissions(signer, permissions);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ grantPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, permissions)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).grantPermissions.prepare(signerAddress, permissions);
    });
    /**
   * Update the permissions of a signer for using the account.
   *
   * @remarks Updates the permissions of a signer for using the account.
   *
   * @param signer - The signer whose permissions to use the account are to be updated.
   * @param permissions - The permissions to be applied to the signer's use of the account.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.updateAccess(signer, restrictions);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ updatePermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, permissions)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).updatePermissions.prepare(signerAddress, permissions);
    });
    /**
   * Revoke a scoped access address to the account
   *
   * @remarks Revokes an address' access to the account.
   *
   * @param signer - The address whose access to the account is to be revoked.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.revokeAccess(signer);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ revokeAccess = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).revokeAccess.prepare(signerAddress);
    });
    /**
   * Approve an address as a call target for a given signer on the account
   *
   * @remarks Approves an address as a call target for a given signer on the account.
   *
   * @param signer - A signer with restricted access to the account.
   * @param target - The address to approve as a call target for the signer.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.approveTargetForSigner(signer, target);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ approveTargetForSigner = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, target)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).approveTargetForSigner.prepare(signerAddress, target);
    });
    /**
   * Disapprove an address as a call target for a given signer on the account
   *
   * @remarks Disapprove an address as a call target for a given signer on the account.
   *
   * @param signer - A signer with restricted access to the account.
   * @param target - The address to disapprove as a call target for the signer.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.disapproveTargetForSigner(signer, target);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ disapproveTargetForSigner = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signerAddress, target)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).disapproveTargetForSigner.prepare(signerAddress, target);
    });
    /**
   * Set the account's entire snapshot of permissions.
   *
   * @remarks Sets the account's entire snapshot of permissions.
   *
   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.
   *
   * @example
   * ```javascript
   * const tx = await contract.account.setAccess(permissionSnapshot);
   * const receipt = tx.receipt();
   * ```
   *
   * @twfeature AccountPermissions
   */ resetAllPermissions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (permissionSnapshot)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.accountPermissions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dm"]).resetAllPermissions.prepare(permissionSnapshot);
    });
}
/**
 * Interact with ERC-4337 account factory contracts
 * @remarks Exposes useful functions available on the account factory contract.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.accountFactory.predictAccountAddress(walletAddress);
 * ```
 * @public
 */ class AccountFactory {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dp"].name;
    // utilities
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /*********************************
   * READ FUNCTIONS
   *******************************/ /**
   * Get the deterministic address of the account that will be created
   *
   * @example
   * ```javascript
   * const accountAddress = await contract.accountFactory.predictAccountAddress(admin);
   * ```
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns The deterministic address of the account that will be created for the given admin.
   *
   * @twfeature AccountFactory
   */ async predictAccountAddress(admin, extraData) {
        let data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("");
        if (extraData) {
            data = extraData;
        }
        return this.contractWrapper.read("getAddress", [
            admin,
            data
        ]);
    }
    /**
   * Get all accounts on which the given signer has authority
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAssociatedAccounts(admin);
   * ```
   * @param signer - The account address.
   * @returns All accounts on which the given signer has authority.
   *
   * @twfeature AccountFactory
   */ async getAssociatedAccounts(signer) {
        return this.contractWrapper.read("getAccountsOfSigner", [
            signer
        ]);
    }
    /**
   * Get all accounts
   *
   * @example
   * ```javascript
   * const allAccounts = await contract.accountFactory.getAllAccounts();
   * ```
   *
   * @returns All accounts created via the account factory.
   *
   * @twfeature AccountFactory
   */ async getAllAccounts() {
        return await this.contractWrapper.read("getAllAccounts", []);
    }
    /**
   * Check if a account has been deployed for the given admin
   *
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   * @returns whether the account has been deployed for the given admin.
   */ async isAccountDeployed(admin, extraData) {
        const addr = await this.predictAccountAddress(admin, extraData);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["au"])(addr, this.contractWrapper.getProvider());
    }
    /*********************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Create a account
   *
   * @remarks Create a account for an admin. The admin will have complete authority over the account.
   *
   * @param admin - The admin of the account.
   * @param extraData - (Optional) Extra data to be passed to the account on creation.
   *
   * @example
   * ```javascript
   * const tx = await contract.accountFactory.createAccount(admin, extraData);
   * const receipt = tx.receipt();
   * const accountAddress = tx.address;
   * ```
   *
   * @twfeature AccountFactory
   */ createAccount = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (accountAdmin, extraData)=>{
        if (await this.isAccountDeployed(accountAdmin, extraData)) {
            throw new Error(`Account already deployed for admin: ${accountAdmin}`);
        }
        let data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("");
        if (extraData) {
            data = extraData;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAccount",
            args: [
                accountAdmin,
                data
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("AccountCreated", receipt?.logs);
                return {
                    address: event[0].args.account,
                    receipt
                };
            }
        });
    });
}
/**
 * @internal
 * @param abi - The abi to extract events from
 * @param metadata - The metadata to extract comments from
 */ function extractEventsFromAbi(abi, metadata) {
    const parsedAbi = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(abi || []);
    const events = parsedAbi.filter((el)=>el.type === "event");
    const parsed = [];
    for (const e of events){
        const doc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a0"])(e.name, metadata, "events");
        parsed.push({
            inputs: e.inputs || [],
            outputs: e.outputs || [],
            name: e.name || "unknown",
            comment: doc
        });
    }
    return parsed;
}
/**
 * Handles publish metadata for a contract
 * @internal
 */ class ContractPublishedMetadata {
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Get the published metadata for this contract
   * @public
   */ async get() {
        if (this._cachedMetadata) {
            return this._cachedMetadata;
        }
        this._cachedMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);
        return this._cachedMetadata;
    }
    /**
   * @public
   */ async extractSources() {
        const publishedMetadata = await this.get();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchSourceFilesFromMetadata$2d$906c835e$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(publishedMetadata, this.storage);
    }
    /**
   * @public
   */ async extractFunctions() {
        let publishedMetadata;
        try {
            publishedMetadata = await this.get();
        } catch (e) {
        // ignore for built-in contracts
        }
        // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a2"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi), publishedMetadata?.metadata);
    }
    /**
   * @public
   */ async extractEvents() {
        let publishedMetadata;
        try {
            publishedMetadata = await this.get();
        } catch (e) {
        // ignore for built-in contracts
        }
        // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)
        return extractEventsFromAbi(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi), publishedMetadata?.metadata);
    }
}
class ExtensionManager {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dq"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    getAddress() {
        return this.contractWrapper.readContract.address;
    }
    /** ******************************
   * READ FUNCTIONS
   *******************************/ async getAll() {
        const extensions = await this.contractWrapper.readContract.getAllExtensions();
        return extensions;
    }
    async get(extensionName) {
        const extension = await this.contractWrapper.readContract.getExtension(extensionName);
        return extension;
    }
    async getExtensionAddress(extensionName) {
        const extension = await this.get(extensionName);
        return extension.metadata.implementation;
    }
    async getAllFunctions(extensionName) {
        const extension = await this.get(extensionName);
        return extension.functions;
    }
    async getExtensionForFunction(functionInput) {
        let selector = functionInput.functionSelector;
        if (!selector) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(functionInput.functionSignature, "Atleast one of function selector and signature must be provided");
            selector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].id(functionInput.functionSignature).substring(0, 10);
        }
        const extensionMetadata = await this.contractWrapper.readContract.getMetadataForFunction(selector);
        return extensionMetadata;
    }
    async getExtensionAddressForFunction(functionInput) {
        const extensionMetadata = await this.getExtensionForFunction(functionInput);
        return extensionMetadata.implementation;
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Adds an extension to the contract
   */ add = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "addExtension",
            args: [
                inputArgs.extension
            ],
            parse: async (receipt)=>{
                const events = this.contractWrapper.parseLogs("ExtensionAdded", receipt.logs);
                if (events.length < 1) {
                    throw new Error("No ExtensionAdded event found");
                }
                const extensionAbi = inputArgs.extensionAbi ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(inputArgs.extensionAbi) : (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
                const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
                const updatedAbi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aj"])([
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi),
                    abiToAdd
                ]);
                this.contractWrapper.updateAbi(updatedAbi);
                return receipt;
            }
        });
    });
    /**
   * Adds a deployed extension to the contract
   */ addDeployed = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        let extensionAbi = inputArgs.extensionAbi;
        if (!extensionAbi) {
            const metadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
            extensionAbi = metadata.abi;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(extensionAbi, "Require extension ABI");
        let extensionMetadataUri = "";
        if (inputArgs.extensionMetadata) {
            if (typeof inputArgs.extensionMetadata === "string") {
                extensionMetadataUri = inputArgs.extensionMetadata;
            } else {
                const parsedMetadata = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bD"].parseAsync(inputArgs.extensionMetadata);
                extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
            }
        }
        const extensionFunctions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(extensionAbi));
        const extension = {
            metadata: {
                name: inputArgs.extensionName,
                metadataURI: extensionMetadataUri,
                implementation: inputArgs.extensionAddress
            },
            functions: extensionFunctions
        };
        return this.add.prepare({
            extension,
            extensionAbi
        });
    });
    /**
   * Adds a published extension to the contract, and deploys it deterministically if necessary
   */ addPublished = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        const version = inputArgs.version || "latest";
        const { deployedExtensionAddress, extensionMetadata } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aH"], version);
        return this.addDeployed.prepare({
            extensionName: inputArgs.extensionName,
            extensionAddress: deployedExtensionAddress,
            extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
        });
    });
    replace = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "replaceExtension",
            args: [
                inputArgs.extension
            ],
            parse: async (receipt)=>{
                const events = this.contractWrapper.parseLogs("ExtensionReplaced", receipt.logs);
                if (events.length < 1) {
                    throw new Error("No ExtensionReplaced event found");
                }
                const extensionAbi = inputArgs.extensionAbi ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(inputArgs.extensionAbi) : (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
                const contractAbi = this.filterAbiForRemove(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi), extensionAbi);
                const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);
                const updatedAbi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aj"])([
                    contractAbi,
                    abiToAdd
                ]);
                this.contractWrapper.updateAbi(updatedAbi);
                return receipt;
            }
        });
    });
    replaceDeployed = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        let extensionAbi = inputArgs.extensionAbi;
        if (!extensionAbi) {
            const metadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);
            extensionAbi = metadata.abi;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(extensionAbi, "Require extension ABI");
        let extensionMetadataUri = "";
        if (inputArgs.extensionMetadata) {
            if (typeof inputArgs.extensionMetadata === "string") {
                extensionMetadataUri = inputArgs.extensionMetadata;
            } else {
                const parsedMetadata = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bD"].parseAsync(inputArgs.extensionMetadata);
                extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);
            }
        }
        const extensionFunctions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(extensionAbi));
        const extension = {
            metadata: {
                name: inputArgs.extensionName,
                metadataURI: extensionMetadataUri,
                implementation: inputArgs.extensionAddress
            },
            functions: extensionFunctions
        };
        return this.replace.prepare({
            extension,
            extensionAbi
        });
    });
    replacePublished = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        const version = inputArgs.version || "latest";
        const { deployedExtensionAddress, extensionMetadata } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aH"], version);
        return this.replaceDeployed.prepare({
            extensionName: inputArgs.extensionName,
            extensionAddress: deployedExtensionAddress,
            extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata
        });
    });
    remove = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (inputArgs)=>{
        const extensionAddress = await this.getExtensionAddress(inputArgs.extensionName);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "removeExtension",
            args: [
                inputArgs.extensionName
            ],
            parse: async (receipt)=>{
                const events = this.contractWrapper.parseLogs("ExtensionRemoved", receipt.logs);
                if (events.length < 1) {
                    throw new Error("No ExtensionRemoved event found");
                }
                const extensionAbi = (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;
                const updatedAbi = this.filterAbiForRemove(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi), extensionAbi);
                this.contractWrapper.updateAbi(updatedAbi);
                return receipt;
            }
        });
    });
    /** ******************************
   * Internal / private
   *******************************/ filterAbiForAdd(extensionAbi, extension) {
        const extensionAbiInterface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].Interface(extensionAbi);
        const extensionFunctionSelectors = extension.functions.map((fn)=>fn.functionSelector);
        const filtered = extensionAbi.filter((item)=>{
            const fnFragment = Object.values(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].Interface([
                item
            ]).functions);
            if (fnFragment.length === 0) {
                return false;
            }
            const fnSigHash = extensionAbiInterface.getSighash(fnFragment[0]);
            return extensionFunctionSelectors.includes(fnSigHash);
        });
        return filtered;
    }
    filterAbiForRemove(fullAbi, abiToRemove) {
        const fullAbiInterface = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].Interface(fullAbi);
        const interfaceToRemove = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].Interface(abiToRemove);
        const functionsToRemove = Object.values(interfaceToRemove.functions).map((fn)=>interfaceToRemove.getSighash(fn));
        const filtered = fullAbi.filter((item)=>{
            const fnFragment = Object.values(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].Interface([
                item
            ]).functions);
            if (fnFragment.length === 0) {
                return false;
            }
            const fnSigHash = fullAbiInterface.getSighash(fnFragment[0]);
            return !functionsToRemove.includes(fnSigHash);
        });
        return filtered;
    }
    async deployExtension(extensionName, publisherAddress) {
        let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "latest";
        const published = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aI"])(publisherAddress, extensionName, version, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
        const deploymentInfo = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(published.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), "", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);
        const implementationAddress = deploymentInfo.find((i)=>i.type === "implementation")?.transaction.predictedAddress;
        // deploy infra + plugins + implementation using a throwaway Deployer contract
        // filter out already deployed contracts (data is empty)
        const transactionsToSend = deploymentInfo.filter((i)=>i.transaction.data && i.transaction.data.length > 0);
        const transactionsforDirectDeploy = transactionsToSend.filter((i)=>{
            return i.type !== "infra";
        }).map((i)=>i.transaction);
        const transactionsForThrowawayDeployer = transactionsToSend.filter((i)=>{
            return i.type === "infra";
        }).map((i)=>i.transaction);
        const signer = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(signer, "Signer is required");
        // deploy via throwaway deployer, multiple infra contracts in one transaction
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(signer, transactionsForThrowawayDeployer, {});
        // send each transaction directly to Create2 factory
        // process txns one at a time
        for (const tx of transactionsforDirectDeploy){
            try {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$deployContractDeterministic$2d$7823c15c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(signer, tx);
            } catch (e) {
                console.debug(`Error deploying contract at ${tx.predictedAddress}`, e?.message);
            }
        }
        return {
            deployedExtensionAddress: implementationAddress,
            extensionMetadata: published.metadataUri
        };
    }
}
/**
 * @public
 */ class Airdrop20 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dr"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * @internal
   */ getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Perform airdrop of ERC20 tokens
   *
   * @example
   * ```javascript
   * // Airdrop content array, with recipients and token amounts
   * const contents = [
   *      {
   *        recipient: "0xabc...", // first recipient address
   *        amount: "10" // number of tokens in wei units
   *      },
   *      {
   *        recipient: "0x123...", // second recipient address
   *        amount: "20" // number of tokens in wei units
   *      }
   *   ]
   *
   * const tokenAddress = "0x..." // Address of the ERC20 token being airdropped
   * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
   *
   * const output = await contract.airdrop20.drop(tokenAddress, tokenOwner, contents);
   *
   * // the `output` return value above contains:
   * //     - count of successful and failed drops
   * //     - array containing failed drops, if any
   *
   * ```
   * @param tokenAddress - Address of the ERC20 token being airdropped
   * @param tokenOwner - Address of the owner of the tokens being airdropped
   * @param contents - Array of airdrop contents
   *
   * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
   * @twfeature AirdropERC20
   */ drop = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenAddress, tokenOwner, contents)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "airdropERC20",
            args: [
                tokenAddress,
                tokenOwner,
                contents
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
                const failedDrops = events.map((e)=>{
                    return {
                        recipient: e.args.recipient,
                        amount: e.args.amount.toString()
                    };
                });
                return {
                    successfulDropCount: contents.length - failedDrops.length,
                    failedDropCount: failedDrops.length,
                    failedDrops
                };
            }
        });
    });
}
/**
 * @public
 */ class Airdrop721 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ds"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * @internal
   */ getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Perform airdrop of ERC721 tokens
   *
   * @example
   * ```javascript
   * // Airdrop content array, with recipients and tokenIds
   * const contents = [
   *      {
   *        recipient: "0xabc...", // first recipient address
   *        tokenId: 0
   *      },
   *      {
   *        recipient: "0x123...", // second recipient address
   *        tokenId: 2
   *      }
   *   ]
   *
   * const tokenAddress = "0x..." // Address of the ERC721 token being airdropped
   * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
   *
   * const output = await contract.airdrop721.drop(tokenAddress, tokenOwner, contents);
   *
   * // the `output` return value above contains:
   * //     - count of successful and failed drops
   * //     - array containing failed drops, if any
   *
   * ```
   * @param tokenAddress - Address of the ERC721 token being airdropped
   * @param tokenOwner - Address of the owner of the tokens being airdropped
   * @param contents - Array of recipients and tokenIds to airdrop
   *
   * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
   * @twfeature AirdropERC721
   */ drop = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenAddress, tokenOwner, contents)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "airdropERC721",
            args: [
                tokenAddress,
                tokenOwner,
                contents
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
                const failedDrops = events.map((e)=>{
                    return {
                        recipient: e.args.recipient,
                        tokenId: e.args.tokenId.toNumber()
                    };
                });
                return {
                    successfulDropCount: contents.length - failedDrops.length,
                    failedDropCount: failedDrops.length,
                    failedDrops
                };
            }
        });
    });
}
/**
 * @public
 */ class Airdrop1155 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dt"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * @internal
   */ getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Perform airdrop of ERC1155 tokens
   *
   * @example
   * ```javascript
   * // Airdrop content array, with recipients and tokenIds
   * const contents = [
   *      {
   *        recipient: "0xabc...", // first recipient address
   *        tokenId: 0,
   *        amount: "10" // number of tokens
   *      },
   *      {
   *        recipient: "0x123...", // second recipient address
   *        tokenId: 0
   *        amount: "20" // number of tokens
   *      }
   *   ]
   *
   * const tokenAddress = "0x..." // Address of the ERC1155 token being airdropped
   * const tokenOwner = "0x..." // Address of the owner of the tokens being airdropped
   *
   * const output = await contract.airdrop1155.drop(tokenAddress, tokenOwner, contents);
   *
   * // the `output` return value above contains:
   * //     - count of successful and failed drops
   * //     - array containing failed drops, if any
   *
   * ```
   * @param tokenAddress - Address of the ERC1155 token being airdropped
   * @param tokenOwner - Address of the owner of the tokens being airdropped
   * @param contents - Array of recipients and tokenIds to airdrop
   *
   * @returns An array of recipients for who the airdrop failed (empty means all transfers were successful)
   * @twfeature AirdropERC1155
   */ drop = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenAddress, tokenOwner, contents)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "airdropERC1155",
            args: [
                tokenAddress,
                tokenOwner,
                contents
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("AirdropFailed", receipt.logs);
                const failedDrops = events.map((e)=>{
                    return {
                        recipient: e.args.recipient,
                        tokenId: e.args.tokenId.toNumber(),
                        amount: e.args.amount.toString()
                    };
                });
                return {
                    successfulDropCount: contents.length - failedDrops.length,
                    failedDropCount: failedDrops.length,
                    failedDrops
                };
            }
        });
    });
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-interceptor-d7b164a7.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * Allows overriding transaction behavior for this contract
 * @internal
 */ __turbopack_context__.s({
    "C": (()=>ContractInterceptor)
});
class ContractInterceptor {
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * The next transaction executed will add/replace any overrides passed via the passed in hook.
   * @remarks Overridden values will be applied to the next transaction executed.
   * @example
   * ```javascript
   * contract.interceptor.overrideNextTransaction(() => ({
   *   gasLimit: 3000000,
   * }));
   * ```
   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)
   * @public
   */ overrideNextTransaction(hook) {
        this.contractWrapper.withTransactionOverride(hook);
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "D": (()=>DEFAULT_QUERY_ALL_COUNT),
    "F": (()=>FALLBACK_METADATA),
    "I": (()=>InterfaceId_IERC721),
    "a": (()=>InterfaceId_IERC1155),
    "b": (()=>uploadOrExtractURI),
    "c": (()=>fetchTokenMetadataForContract),
    "f": (()=>fetchTokenMetadata),
    "g": (()=>getBaseUriFromBatch),
    "u": (()=>uploadOrExtractURIs)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @internal
 */ /**
 * @internal
 */ const InterfaceId_IERC721 = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].arrayify("0x80ac58cd"))();
/**
 * @internal
 */ const InterfaceId_IERC1155 = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].arrayify("0xd9b67a26"))();
const FALLBACK_METADATA = {
    name: "Failed to load NFT metadata"
};
/**
 * fetches the token metadata
 * @param tokenId - the id (to get it back in the output)
 * @param tokenUri - the uri to fetch
 * @param storage - which storage to fetch from
 *
 * @internal
 */ async function fetchTokenMetadata(tokenId, tokenUri, storage) {
    // check for base64 encoded JSON
    if (tokenUri.startsWith("data:application/json;base64") && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"] !== "undefined") {
        const base64 = tokenUri.split(",")[1];
        const jsonMetadata = JSON.parse(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(base64, "base64").toString("utf-8"));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"].parse({
            ...jsonMetadata,
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId).toString(),
            uri: tokenUri
        });
    }
    // handle dynamic id URIs (2 possible formats)
    const parsedUri = tokenUri.replace("{id}", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId).toHexString(), 32).slice(2));
    let jsonMetadata;
    try {
        jsonMetadata = await storage.downloadJSON(parsedUri);
    } catch (err) {
        const unparsedTokenIdUri = tokenUri.replace("{id}", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId).toString());
        try {
            jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);
        } catch (e) {
            console.warn(`failed to get token metadata: ${JSON.stringify({
                tokenId: tokenId.toString(),
                tokenUri
            })} -- falling back to default metadata`);
            jsonMetadata = FALLBACK_METADATA;
        }
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"].parse({
        ...jsonMetadata,
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId).toString(),
        uri: tokenUri
    });
}
// Used for marketplace to fetch NFT metadata from contract address + tokenId
/**
 * @internal
 * @param contractAddress - the contract address
 * @param provider - the provider to use
 * @param tokenId - the token id
 * @param storage - the storage to use
 */ async function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {
    let uri;
    const ERC165MetadataAbi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json (json, async loader)")(__turbopack_context__.i)).default;
    const erc165 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](contractAddress, ERC165MetadataAbi, provider);
    const [isERC721, isERC1155] = await Promise.all([
        erc165.supportsInterface(InterfaceId_IERC721),
        erc165.supportsInterface(InterfaceId_IERC1155)
    ]);
    if (isERC721) {
        const ERC721MetadataAbi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json (json, async loader)")(__turbopack_context__.i)).default;
        const erc721 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](contractAddress, ERC721MetadataAbi, provider);
        uri = await erc721.tokenURI(tokenId);
    } else if (isERC1155) {
        const ERC1155MetadataAbi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json (json, async loader)")(__turbopack_context__.i)).default;
        const erc1155 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](contractAddress, ERC1155MetadataAbi, provider);
        uri = await erc1155.uri(tokenId);
    } else {
        throw Error("Contract must implement ERC 1155 or ERC 721.");
    }
    if (!uri) {
        // no uri found, return fallback metadata
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"].parse({
            ...FALLBACK_METADATA,
            id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId).toString(),
            uri: ""
        });
    }
    return fetchTokenMetadata(tokenId, uri, storage);
}
/**
 * @internal
 * @param metadata - the metadata to upload
 * @param storage - the storage to use
 */ async function uploadOrExtractURI(metadata, storage) {
    if (typeof metadata === "string") {
        return metadata;
    } else {
        return await storage.upload(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(metadata));
    }
}
/**
 * @internal
 * @param metadatas - the metadata to upload
 * @param storage - the storage to use
 * @param startNumber - the number to start the file names at
 * @param contractAddress - the contract address
 * @param signerAddress - the signer address
 * @param options - options
 */ async function uploadOrExtractURIs(metadatas, storage, startNumber, options) {
    if (isUriList(metadatas)) {
        return metadatas;
    } else if (isMetadataList(metadatas)) {
        const uris = await storage.uploadBatch(metadatas.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(m)), {
            rewriteFileNames: {
                fileStartNumber: startNumber || 0
            },
            onProgress: options?.onProgress
        });
        return uris;
    } else {
        throw new Error("NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)");
    }
}
function getBaseUriFromBatch(uris) {
    const baseUri = uris[0].substring(0, uris[0].lastIndexOf("/"));
    for(let i = 0; i < uris.length; i++){
        const uri = uris[i].substring(0, uris[i].lastIndexOf("/"));
        if (baseUri !== uri) {
            throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
        }
    }
    // Ensure that baseUri ends with trailing slash
    return baseUri.replace(/\/$/, "") + "/";
}
function isUriList(metadatas) {
    return metadatas.find((m)=>typeof m !== "string") === undefined;
}
function isMetadataList(metadatas) {
    return metadatas.find((m)=>typeof m !== "object") === undefined;
}
/**
 * @internal
 */ const DEFAULT_QUERY_ALL_COUNT = 100;
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>ContractRoyalty),
    "D": (()=>DelayedReveal),
    "a": (()=>ContractOwner),
    "c": (()=>calculateClaimCost)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * Handle contract royalties
 * @remarks Configure royalties for an entire contract or a particular token.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
 * await contract.roles.setTokenRoyaltyInfo(tokenId, {
 *   seller_fee_basis_points: 100, // 1% royalty fee
 *   fee_recipient: "0x...", // the fee recipient
 * });
 * ```
 * @public
 */ class ContractRoyalty {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d5"].name;
    constructor(contractWrapper, metadata){
        this.contractWrapper = contractWrapper;
        this.metadata = metadata;
    }
    /**
   * Get the royalty recipient and fee
   * @returns  The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */ async getDefaultRoyaltyInfo() {
        const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getDefaultRoyaltyInfo", []);
        // parse it on the way out to make sure we default things if they are not set
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bF"].parseAsync({
            fee_recipient: royaltyRecipient,
            seller_fee_basis_points: royaltyBps
        });
    }
    /**
   * Get the royalty recipient and fee of a particular token
   * @returns  The royalty recipient and BPS
   * @example
   * ```javascript
   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();
   * console.log(royaltyInfo.fee_recipient);
   * console.log(royaltyInfo.seller_fee_basis_points);
   * ```
   * @public
   * @twfeature Royalty
   */ async getTokenRoyaltyInfo(tokenId) {
        const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read("getRoyaltyInfoForToken", [
            tokenId
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bF"].parseAsync({
            fee_recipient: royaltyRecipient,
            seller_fee_basis_points: royaltyBps
        });
    }
    /**
   * Set the royalty recipient and fee
   * @param royaltyData - the royalty recipient and fee
   *  @example
   * ```javascript
   * await contract.roles.setDefaultRoyaltyInfo({
   *   seller_fee_basis_points: 100, // 1% royalty fee
   *   fee_recipient: "0x...", // the fee recipient
   * });
   * ```
   * @public
   * @twfeature Royalty
   */ setDefaultRoyaltyInfo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (royaltyData)=>{
        // read the metadata from the contract
        const oldMetadata = await this.metadata.get();
        // update the metadata with the new royalty data
        // if one of the keys is "undefined" it will be ignored (which is the desired behavior)
        const mergedMetadata = await this.metadata.parseInputMetadata({
            ...oldMetadata,
            ...royaltyData
        });
        // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`
        // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!
        const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("setContractURI", this.contractWrapper)) {
            const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
            // encode both the functions we want to send
            const encoded = [
                contractEncoder.encode("setDefaultRoyaltyInfo", [
                    mergedMetadata.fee_recipient,
                    mergedMetadata.seller_fee_basis_points
                ]),
                contractEncoder.encode("setContractURI", [
                    contractURI
                ])
            ];
            // actually send the transaction and return the receipt + a way to get the new royalty info
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "multicall",
                args: [
                    encoded
                ],
                parse: (receipt)=>({
                        receipt,
                        data: ()=>this.getDefaultRoyaltyInfo()
                    })
            });
        } else {
            throw new Error("Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.");
        }
    });
    /**
   * Set the royalty recipient and fee for a particular token
   * @param tokenId - the token id
   * @param royaltyData - the royalty recipient and fee
   * @example
   * ```javascript
   * const tokenId = 0;
   * await contract.roles.setTokenRoyaltyInfo(tokenId, {
   *   seller_fee_basis_points: 100, // 1% royalty fee
   *   fee_recipient: "0x...", // the fee recipient
   * });
   * ```
   * @public
   * @twfeature Royalty
   */ setTokenRoyaltyInfo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, royaltyData)=>{
        const parsedRoyaltyData = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bF"].parse(royaltyData);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setRoyaltyInfoForToken",
            args: [
                tokenId,
                parsedRoyaltyData.fee_recipient,
                parsedRoyaltyData.seller_fee_basis_points
            ],
            parse: (receipt)=>({
                    receipt,
                    data: ()=>this.getDefaultRoyaltyInfo()
                })
        });
    });
}
/**
 * Handles delayed reveal logic
 * @public
 */ class DelayedReveal {
    constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn){
        this.featureName = featureName;
        this.nextTokenIdToMintFn = nextTokenIdToMintFn;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Create a batch of encrypted NFTs that can be revealed at a later time.
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until your reveal them!
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * ```
   * @public
   * @param placeholder - the placeholder NFT to show before the reveal
   * @param metadatas - the final NFTs that will be hidden
   * @param password - the password that will be used to reveal these NFTs
   * @param options - additional options like upload progress
   */ createDelayedRevealBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (placeholder, metadatas, password, options)=>{
        if (!password) {
            throw new Error("Password is required");
        }
        const placeholderUris = await this.storage.uploadBatch([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(placeholder)
        ], {
            rewriteFileNames: {
                fileStartNumber: 0
            }
        });
        const placeholderUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(placeholderUris);
        const startFileNumber = await this.nextTokenIdToMintFn();
        const uris = await this.storage.uploadBatch(metadatas.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(m)), {
            onProgress: options?.onProgress,
            rewriteFileNames: {
                fileStartNumber: startFileNumber.toNumber()
            }
        });
        const baseUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(uris);
        const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
        const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);
        const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes(baseUri),
            hashedPassword
        ]);
        let data;
        const legacyContract = await this.isLegacyContract();
        if (legacyContract) {
            data = encryptedBaseUri;
        } else {
            const chainId = await this.contractWrapper.getChainID();
            const provenanceHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
                "bytes",
                "bytes",
                "uint256"
            ], [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes(baseUri),
                hashedPassword,
                chainId
            ]);
            data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].defaultAbiCoder.encode([
                "bytes",
                "bytes32"
            ], [
                encryptedBaseUri,
                provenanceHash
            ]);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "lazyMint",
            args: [
                uris.length,
                placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`,
                data
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
                const startingIndex = events[0].args.startTokenId;
                const endingIndex = events[0].args.endTokenId;
                const results = [];
                for(let id = startingIndex; id.lte(endingIndex); id = id.add(1)){
                    results.push({
                        id,
                        receipt
                    });
                }
                return results;
            }
        });
    });
    /**
   * Reveal a batch of hidden NFTs
   * @remarks Reveal the NFTs of a batch using the password.
   * @example
   * ```javascript
   * // the batch to reveal
   * const batchId = 0;
   * // reveal the batch
   * await contract.revealer.reveal(batchId, "my secret password");
   * ```
   * @public
   * @param batchId - the id of the batch to reveal
   * @param password - the password
   */ reveal = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (batchId, password)=>{
        if (!password) {
            throw new Error("Password is required");
        }
        const key = await this.hashDelayRevealPassword(batchId, password);
        // performing the reveal locally to make sure it'd succeed before sending the transaction
        try {
            const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
            // basic sanity check for making sure decryptedUri is valid
            // this is optional because invalid decryption key would result in non-utf8 bytes and
            // ethers would throw when trying to decode it
            if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
                throw new Error("invalid password");
            }
        } catch (e) {
            throw new Error("invalid password");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "reveal",
            args: [
                batchId,
                key
            ]
        });
    });
    /**
   * Gets the list of unrevealed NFT batches.
   * @remarks Gets the list of unrevealed NFT batches.
   * @example
   * ```javascript
   * const batches = await contract.revealer.getBatchesToReveal();
   * ```
   * @public
   */ async getBatchesToReveal() {
        const count = await this.contractWrapper.read("getBaseURICount", []);
        if (count.isZero()) {
            return [];
        }
        const countRangeArray = Array.from(Array(count.toNumber()).keys());
        // map over to get the base uri indices, which should be the end token id of every batch
        const uriIndices = await Promise.all(countRangeArray.map((i)=>{
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("getBatchIdAtIndex", this.contractWrapper)) {
                return this.contractWrapper.read("getBatchIdAtIndex", [
                    i
                ]);
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("baseURIIndices", this.contractWrapper)) {
                return this.contractWrapper.read("baseURIIndices", [
                    i
                ]);
            }
            throw new Error("Contract does not have getBatchIdAtIndex or baseURIIndices.");
        }));
        // first batch always start from 0. don't need to fetch the last batch so pop it from the range array
        const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);
        // returns the token uri for each batches. first batch always starts from token id 0.
        const tokenMetadatas = await Promise.all(Array.from([
            0,
            ...uriIndicesWithZeroStart
        ]).map((i)=>this.getNftMetadata(i.toString())));
        // index is the uri indices, which is end token id. different from uris
        const legacyContract = await this.isLegacyContract();
        const encryptedUriData = await Promise.all(Array.from([
            ...uriIndices
        ]).map((i)=>legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read("encryptedData", [
                i
            ])));
        const encryptedBaseUris = encryptedUriData.map((data)=>{
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexDataLength(data) > 0) {
                if (legacyContract) {
                    return data;
                }
                const result = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].defaultAbiCoder.decode([
                    "bytes",
                    "bytes32"
                ], data);
                return result[0];
            } else {
                return data;
            }
        });
        return tokenMetadatas.map((meta, index)=>({
                batchId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(index),
                batchUri: meta.uri,
                placeholderMetadata: meta
            })).filter((_, index)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexDataLength(encryptedBaseUris[index]) > 0);
    }
    /**
   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.
   *
   * @internal
   */ async hashDelayRevealPassword(batchTokenIndex, password) {
        const chainId = await this.contractWrapper.getChainID();
        const contractAddress = this.contractWrapper.address;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
            "string",
            "uint256",
            "uint256",
            "address"
        ], [
            password,
            chainId,
            batchTokenIndex,
            contractAddress
        ]);
    }
    async getNftMetadata(tokenId) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);
    }
    async isLegacyContract() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("contractVersion", this.contractWrapper)) {
            try {
                const version = await this.contractWrapper.read("contractVersion", []);
                return version <= 2;
            } catch (e) {
                return false;
            }
        }
        return false;
    }
    async getLegacyEncryptedData(index) {
        const DeprecatedAbi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json (json, async loader)")(__turbopack_context__.i)).default;
        const legacy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());
        const result = await legacy.functions["encryptedBaseURI"](index);
        if (result.length > 0) {
            return result[0];
        } else {
            return "0x";
        }
    }
}
async function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {
    let overrides = {};
    const currency = currencyAddress || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"];
    const normalizedPrice = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(contractWrapper.getProvider(), pricePerToken, currency);
    const totalCost = normalizedPrice.mul(quantity);
    if (totalCost.gt(0)) {
        if (currency === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]) {
            overrides = {
                value: totalCost
            };
        } else if (currency !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"] && checkERC20Allowance) {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(contractWrapper, currency, totalCost, quantity, 0);
        }
    }
    return overrides;
}
/**
 * Encodes and decodes Contract functions
 * @public
 */ class ContractOwner {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d6"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get the current owner of the contract
   * @example
   * ```javascript
   * await contract.owner.get();
   * console.log("Owner address: ", ownerAddress);
   * ```
   * @returns The owner address
   * @twfeature Ownable
   */ async get() {
        return this.contractWrapper.read("owner", []);
    }
    /**
   * Set the new owner of the contract
   * @remarks Can only be called by the current owner.
   *
   * @param address - the address of the new owner
   *
   * @example
   * ```javascript
   * const newOwnerAddress = "{{wallet_address}}";
   * await contract.owner.set(newOwnerAddress);
   * ```
   * @twfeature Ownable
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (address)=>{
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setOwner",
            args: [
                resolvedAddress
            ]
        });
    });
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-platform-fee-e756e68f.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>ContractPlatformFee)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
;
;
/**
 * Handle platform fees and recipients
 * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const feeInfo = await contract.platformFees.get();
 * await contract.platformFees.set({
 *   platform_fee_basis_points: 100, // 1% fee
 *   platform_fee_recipient: "0x..." // the fee recipient
 * })
 * ```
 * @public
 */ class ContractPlatformFee {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["du"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get the platform fee recipient and basis points
   *
   * @example
   * ```javascript
   * const feeInfo = await contract.platformFees.get();
   * console.log(feeInfo.platform_fee_recipient);
   * console.log(feeInfo.platform_fee_basis_points);
   * ```
   * @twfeature PlatformFee
   */ async get() {
        const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read("getPlatformFeeInfo", []);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bH"].parseAsync({
            platform_fee_recipient: platformFeeRecipient,
            platform_fee_basis_points: platformFeeBps
        });
    }
    /**
   * Set the platform fee recipient and basis points
   *
   * @example
   * ```javascript
   * await contract.platformFees.set({
   *   platform_fee_basis_points: 100, // 1% fee
   *   platform_fee_recipient: "0x..." // the fee recipient
   * })
   * ```
   *
   * @param platformFeeInfo - the platform fee information
   * @twfeature PlatformFee
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (platformFeeInfo)=>{
        const parsed = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bH"].parseAsync(platformFeeInfo);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setPlatformFeeInfo",
            args: [
                parsed.platform_fee_recipient,
                parsed.platform_fee_basis_points
            ]
        });
    });
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-roles-71988d2e.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>ContractRoles)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * Handle contract permissions
 * @remarks Configure roles and permissions for a contract, to restrict certain actions.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const rolesAndMembers = await contract.roles.getAll();
 * await contract.roles.grantRole("admin", "0x...");
 * ```
 * @public
 */ // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4
class ContractRoles {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d4"].name;
    /**
   * @internal
   * @remarks This is used for typing inside react hooks which is why it has to be public.
   */ constructor(contractWrapper, roles){
        this.contractWrapper = contractWrapper;
        this.roles = roles;
    }
    /** **************************
   * READ FUNCTIONS
   ****************************/ /**
   * Get all members of all roles
   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.
   * @example
   * ```javascript
   * const rolesAndMembers = await contract.roles.getAll();
   * ```
   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.
   * @throws If the contract does not support roles this will throw an error.
   *
   * @public
   * @twfeature PermissionsEnumerable
   */ async getAll() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.roles.length, "this contract has no support for roles");
        const roles = {};
        const entries = Object.entries(this.roles);
        (await Promise.all(entries.map((_ref)=>{
            let [, role] = _ref;
            return this.get(role);
        }))).forEach((item, index)=>roles[entries[index][1]] = item);
        return roles;
    }
    /**
   * Get all members of a specific role
   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.
   * @param role - The Role to get a memberlist for.
   * @returns The list of addresses that are members of the specific role.
   * @throws If you are requesting a role that does not exist on the contract this will throw an error.
   *
   * @example Say you want to get the list of addresses that are members of the minter role.
   * ```javascript
   * const minterAddresses = await contract.roles.get("minter");
   * ```
   *
   * @public
   * @twfeature Permissions
   */ async get(role) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.roles.includes(role), `this contract does not support the "${role}" role`);
        const wrapper = this.contractWrapper;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("getRoleMemberCount", wrapper) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("getRoleMember", wrapper)) {
            const roleHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(role);
            const count = (await wrapper.read("getRoleMemberCount", [
                roleHash
            ])).toNumber();
            return await Promise.all(Array.from(Array(count).keys()).map((i)=>wrapper.read("getRoleMember", [
                    roleHash,
                    i
                ])));
        }
        throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.");
    }
    /**
   * Overwrite the list of members for specific roles
   *
   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.
   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.
   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.
   * @throws If you are requesting a role that does not exist on the contract this will throw an error.
   * @example Say you want to overwrite the list of addresses that are members of the minter role.
   * ```javascript
   * const minterAddresses = await contract.roles.get("minter");
   * await contract.roles.setAll({
   *  minter: []
   * });
   * console.log(await contract.roles.get("minter")); // No matter what members had the role before, the new list will be set to []
   * ```
   * @public
   * @twfeature Permissions
   *
   * */ setAll = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (rolesWithAddresses, actingAddress)=>{
        // if we are removing multiple roles, we need to allways remove the connected wallet address *last*
        // this is so we don't renounce (i.e.)  admin role first and then try to revoke someone else's (i.e.) admin role after (which will revert the entire txn because we are no longer an admin)
        // if it is explicitly passed in (i.e. for estimation) we use that value, otherwise we get it from the connected signer
        const connectedWalletAddress = actingAddress || await this.contractWrapper.getSignerAddress();
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const roles = Object.keys(rolesWithAddresses);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(roles.length, "you must provide at least one role to set");
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(roles.every((role)=>this.roles.includes(role)), "this contract does not support the given role");
        const currentRoles = await this.getAll();
        const encoded = [];
        // add / remove admin role at the end so we don't revoke admin then grant
        const sortedRoles = roles.sort((role)=>role === "admin" ? 1 : -1);
        for(let i = 0; i < sortedRoles.length; i++){
            const role = sortedRoles[i];
            const [addresses, currentAddresses] = await Promise.all([
                Promise.all(rolesWithAddresses[role]?.map((addressOrEns)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressOrEns)) || []),
                Promise.all(currentRoles[role]?.map((addressOrEns)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressOrEns)) || [])
            ]);
            const toAdd = addresses.filter((address)=>!currentAddresses.includes(address));
            const toRemove = currentAddresses.filter((address)=>!addresses.includes(address));
            // if we're removing more than one address we have to make sure we always remove the *connected* (acting) wallet address first
            // otherwise we'll revoke the connected wallet address and then try to revoke someone else's address which will revert the entire txn
            if (toRemove.length > 1) {
                const index = toRemove.indexOf(connectedWalletAddress);
                if (index > -1) {
                    toRemove.splice(index, 1);
                    toRemove.push(connectedWalletAddress);
                }
            }
            if (toAdd.length) {
                toAdd.forEach((address)=>{
                    encoded.push(contractEncoder.encode("grantRole", [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(role),
                        address
                    ]));
                });
            }
            if (toRemove.length) {
                const revokeFunctionNames = await Promise.all(toRemove.map((address)=>this.getRevokeRoleFunctionName(address)));
                revokeFunctionNames.forEach((revokeFunctionName, index)=>encoded.push(contractEncoder.encode(revokeFunctionName, [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(role),
                        toRemove[index]
                    ])));
            }
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ]
        });
    });
    /**
   * Throws an error if an address is missing the roles specified.
   *
   * @param roles - The roles to check
   * @param address - The address to check
   *
   * @internal
   */ async verify(roles, address) {
        await Promise.all(roles.map(async (role)=>{
            const [members, resolvedAddress] = await Promise.all([
                this.get(role),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address)
            ]);
            if (!members.map((a)=>a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["o"](resolvedAddress, role);
            }
        }));
    }
    /** **************************
   * WRITE FUNCTIONS
   ****************************/ /**
   * Grant a role to a specific address
   *
   * @remarks Make sure you are sure you want to grant the role to the address.
   *
   * @example
   * ```javascript
   * await contract.roles.grant("minter", "{{wallet_address}}");
   * ```
   *
   * @param role - The {@link Role} to grant to the address
   * @param address - The address to grant the role to
   * @returns The transaction receipt
   * @throws If you are trying to grant does not exist on the contract this will throw an error.
   *
   * @public
   * @twfeature Permissions
   */ grant = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (role, address)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.roles.includes(role), `this contract does not support the "${role}" role`);
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "grantRole",
            args: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(role),
                resolvedAddress
            ]
        });
    });
    /**
   * Revoke a role from a specific address
   *
   * @remarks
   *
   * -- Caution --
   *
   * This will let you remove yourself from the role, too.
   * If you remove yourself from the admin role, you will no longer be able to administer the contract.
   * There is no way to recover from this.
   *
   * @example
   * ```javascript
   * await contract.roles.revoke("minter", "{{wallet_address}}");
   * ```
   *
   * @param role - The {@link Role} to revoke
   * @param address - The address to revoke the role from
   * @returns The transaction receipt
   * @throws If you are trying to revoke does not exist on the module this will throw an error.
   *
   * @public
   * @twfeature Permissions
   */ revoke = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (role, address)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(this.roles.includes(role), `this contract does not support the "${role}" role`);
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address);
        const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: revokeFunctionName,
            args: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(role),
                resolvedAddress
            ]
        });
    });
    /** **************************
   * PRIVATE FUNCTIONS
   ****************************/ async getRevokeRoleFunctionName(address) {
        const [resolvedAddress, signerAddress] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address),
            this.contractWrapper.getSignerAddress()
        ]);
        if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {
            return "renounceRole";
        }
        return "revokeRole";
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/contract-sales-918c7cb8.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "C": (()=>ContractPrimarySale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
;
;
/**
 * Handle primary sales recipients
 * @remarks Configure primary sale recipients for an entire contract.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const salesRecipient = await contract.sales.getRecipient();
 * await contract.sales.setRecipient(recipientWalletAddress);
 * ```
 * @public
 */ class ContractPrimarySale {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d7"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get the primary sale recipient
   * @returns The wallet address.
   * @example
   * ```javascript
   * const salesRecipient = await contract.sales.getRecipient();
   * ```
   * @public
   * @twfeature PrimarySale
   */ async getRecipient() {
        const result = await this.contractWrapper.read("primarySaleRecipient", []);
        return result;
    }
    /**
   * Set the primary sale recipient
   * @param recipient - the wallet address
   * @example
   * ```javascript
   * await contract.sales.setRecipient(recipientWalletAddress);
   * ```
   * @public
   * @twfeature PrimarySale
   */ setRecipient = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (recipient)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setPrimarySaleRecipient",
            args: [
                recipient
            ]
        });
    });
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/erc-1155-7ce9bee1.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "D": (()=>DropErc1155ClaimConditions),
    "E": (()=>Erc1155),
    "a": (()=>Erc1155SignatureMintable)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-client] (ecmascript) <export * as constants>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Manages claim conditions for Edition Drop contracts
 * @erc1155
 * @public
 */ class DropErc1155ClaimConditions {
    constructor(contractWrapper, metadata, storage){
        this.storage = storage;
        this.contractWrapper = contractWrapper;
        this.metadata = metadata;
    }
    /** ***************************************
   * READ FUNCTIONS
   *****************************************/ /**
   * Get the currently active claim condition
   *
   * @returns The claim condition metadata
   */ async getActive(tokenId, options) {
        const mc = await this.get(tokenId);
        const metadata = await this.metadata.get();
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"])(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false);
    }
    async get(tokenId, conditionId) {
        if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            const contractModel = await this.contractWrapper.read("claimCondition", [
                tokenId
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["z"])(contractModel);
        } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [
                tokenId
            ]);
            const contractModel = await this.contractWrapper.read("getClaimConditionById", [
                tokenId,
                id
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["z"])(contractModel);
        } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            const contractModel = await this.contractWrapper.read("claimCondition", [
                tokenId
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"])(contractModel);
        } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", [
                tokenId
            ]);
            const contractModel = await this.contractWrapper.read("getClaimConditionById", [
                tokenId,
                id
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"])(contractModel);
        } else {
            throw new Error("Contract does not support claim conditions");
        }
    }
    /**
   * Get all the claim conditions
   *
   * @returns The claim conditions metadata
   */ async getAll(tokenId, options) {
        if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
            const claimCondition = await this.contractWrapper.read("claimCondition", [
                tokenId
            ]);
            const startId = claimCondition.currentStartId.toNumber();
            const count = claimCondition.count.toNumber();
            const conditions = [];
            for(let i = startId; i < startId + count; i++){
                conditions.push(await this.get(tokenId, i));
            }
            const metadata = await this.metadata.get();
            return Promise.all(conditions.map((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"])(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));
        } else {
            return [
                await this.getActive(tokenId, options)
            ];
        }
    }
    /**
   * Can Claim
   *
   * @remarks Check if a particular NFT can currently be claimed by a given user.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */ async canClaim(tokenId, quantity, addressToCheck) {
        // TODO switch to use verifyClaim
        if (addressToCheck) {
            addressToCheck = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressToCheck);
        }
        return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;
    }
    /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human-readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param tokenId - the token id to check
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */ async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {
        const reasons = [];
        let activeConditionIndex;
        let claimCondition;
        if (addressToCheck === undefined) {
            try {
                addressToCheck = await this.contractWrapper.getSignerAddress();
            } catch (err) {
                console.warn("failed to get signer address", err);
            }
        }
        // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason
        if (!addressToCheck) {
            return [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NoWallet
            ];
        }
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressToCheck);
        try {
            claimCondition = await this.getActive(tokenId);
        } catch (err) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "!CONDITION") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "no active mint condition") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "DropNoActiveCondition")) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NoClaimConditionSet);
                return reasons;
            }
            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].Unknown);
            return reasons;
        }
        if (claimCondition.availableSupply !== "unlimited") {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(claimCondition.availableSupply).lt(quantity)) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughSupply);
                return reasons;
            }
        }
        // check for merkle root inclusion
        const merkleRootArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].stripZeros(claimCondition.merkleRootHash);
        const hasAllowList = merkleRootArray.length > 0;
        let allowListEntry = null;
        if (hasAllowList) {
            allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);
            if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
                // exclusive allowlist behavior
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                return reasons;
            }
            if (allowListEntry) {
                try {
                    const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);
                    let validMerkleProof;
                    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [
                            tokenId
                        ]);
                        // legacy verifyClaimerMerkleProofs function
                        [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                            activeConditionIndex,
                            resolvedAddress,
                            tokenId,
                            quantity,
                            claimVerification.proofs,
                            claimVerification.maxClaimable
                        ]);
                        if (!validMerkleProof) {
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                            return reasons;
                        }
                    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                        [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                            tokenId,
                            resolvedAddress,
                            quantity,
                            {
                                proof: claimVerification.proofs,
                                maxQuantityInAllowlist: claimVerification.maxClaimable
                            }
                        ]);
                        if (!validMerkleProof) {
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                            return reasons;
                        }
                    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
                        await this.contractWrapper.read("verifyClaim", [
                            tokenId,
                            resolvedAddress,
                            quantity,
                            claimVerification.currencyAddress,
                            claimVerification.price,
                            {
                                proof: claimVerification.proofs,
                                quantityLimitPerWallet: claimVerification.maxClaimable,
                                currency: claimVerification.currencyAddressInProof,
                                pricePerToken: claimVerification.priceInProof
                            }
                        ]);
                    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [
                            tokenId
                        ]);
                        await this.contractWrapper.read("verifyClaim", [
                            activeConditionIndex,
                            resolvedAddress,
                            tokenId,
                            quantity,
                            claimVerification.currencyAddress,
                            claimVerification.price,
                            {
                                proof: claimVerification.proofs,
                                quantityLimitPerWallet: claimVerification.maxClaimable,
                                currency: claimVerification.currencyAddressInProof,
                                pricePerToken: claimVerification.priceInProof
                            }
                        ]);
                    }
                } catch (e) {
                    console.warn("Merkle proof verification failed:", "reason" in e ? e.reason || e.errorName : e);
                    const reason = e.reason || e.errorName;
                    switch(reason){
                        case "!Qty":
                        case "DropClaimExceedLimit":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].OverMaxClaimablePerWallet);
                            break;
                        case "!PriceOrCurrency":
                        case "DropClaimInvalidTokenPrice":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].WrongPriceOrCurrency);
                            break;
                        case "!MaxSupply":
                        case "DropClaimExceedMaxSupply":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughSupply);
                            break;
                        case "cant claim yet":
                        case "DropClaimNotStarted":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].ClaimPhaseNotStarted);
                            break;
                        default:
                            {
                                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                                break;
                            }
                    }
                    return reasons;
                }
            }
        }
        if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
            let claimedSupply = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
            let maxClaimable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"])(claimCondition.maxClaimablePerWallet, 0);
            try {
                claimedSupply = await this.getSupplyClaimedByWallet(tokenId, resolvedAddress);
            } catch (e) {
            // no-op
            }
            if (allowListEntry) {
                maxClaimable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"])(allowListEntry.maxClaimable, 0);
            }
            if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantity))) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].OverMaxClaimablePerWallet);
                return reasons;
            }
            // if there is no allowlist, or if there is an allowlist and the address is not in it
            // if maxClaimable is 0, we consider it as the address is not allowed
            if (!hasAllowList || hasAllowList && !allowListEntry) {
                if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                    return reasons;
                }
            }
        }
        // check for claim timestamp between claims
        let [lastClaimedTimestamp, timestampForNextClaim] = [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0)
        ];
        if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", [
                tokenId
            ]);
            [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [
                tokenId,
                activeConditionIndex,
                resolvedAddress
            ]);
        } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [
                tokenId,
                resolvedAddress
            ]);
        }
        const now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Date.now()).div(1000);
        if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
            // contract will return MaxUint256 if user has already claimed and cannot claim again
            if (timestampForNextClaim.eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256)) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AlreadyClaimed);
            } else {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].WaitBeforeNextClaimTransaction);
            }
            return reasons;
        }
        // if not within a browser conetext, check for wallet balance.
        // In browser context, let the wallet do that job
        if (claimCondition.price.gt(0) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d8"])()) {
            const totalPrice = claimCondition.price.mul(quantity);
            const provider = this.contractWrapper.getProvider();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(claimCondition.currencyAddress)) {
                const balance = await provider.getBalance(resolvedAddress);
                if (balance.lt(totalPrice)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughTokens);
                }
            } else {
                const IERC20ABI = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json (json, async loader)")(__turbopack_context__.i)).default;
                const erc20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](provider, claimCondition.currencyAddress, IERC20ABI, {}, this.storage);
                const balance = await erc20.read("balanceOf", [
                    resolvedAddress
                ]);
                if (balance.lt(totalPrice)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughTokens);
                }
            }
        }
        return reasons;
    }
    /**
   * Returns allow list information and merkle proofs for the given address.
   * @param tokenId - the token ID to check
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */ async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {
        const claimCondition = await this.get(tokenId, claimConditionId);
        const merkleRoot = claimCondition.merkleRoot;
        const merkleRootArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].stripZeros(merkleRoot);
        if (merkleRootArray.length > 0) {
            const metadata = await this.metadata.get();
            const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(claimerAddress);
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
        } else {
            return null;
        }
    }
    /**
   * Get the total supply claimed by a specific wallet
   * @param walletAddress - the wallet address to check
   * @returns The total supply claimed
   */ async getSupplyClaimedByWallet(tokenId, walletAddress) {
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress);
        if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            return await this.contractWrapper.read("getSupplyClaimedByWallet", [
                tokenId,
                resolvedAddress
            ]);
        }
        if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", [
                tokenId
            ]);
            return await this.contractWrapper.read("getSupplyClaimedByWallet", [
                tokenId,
                activeClaimConditionId,
                resolvedAddress
            ]);
        }
        throw new Error("This contract does not support the getSupplyClaimedByWallet function");
    }
    /** ***************************************
   * WRITE FUNCTIONS
   *****************************************/ /**
   * Set claim conditions on a single NFT
   *
   * @remarks Sets the public mint conditions that need to be fulfilled by users to claim a particular NFT in this contract.
   *
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   *
   * // Optionally specify addresses that can claim
   * const snapshots = ['0x...', '0x...']
   *
   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim
   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]
   *
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: snapshots, // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   *
   * const tokenId = 0; // the id of the NFT to set claim conditions on
   * await dropContract.claimConditions.set(tokenId, claimConditions);
   * ```
   *
   * @param tokenId - The id of the NFT to set the claim conditions on
   * @param claimConditionInputs - The claim conditions
   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this = this;
        return async function(tokenId, claimConditionInputs) {
            let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            return _this.setBatch.prepare([
                {
                    tokenId,
                    claimConditions: claimConditionInputs
                }
            ], resetClaimEligibilityForAll);
        };
    })());
    /**
   * Set claim conditions on multiple NFTs at once
   *
   * @remarks Sets the claim conditions that need to be fulfilled by users to claim the given NFTs in this contract.
   *
   * @example
   * ```javascript
   * const claimConditionsForTokens = [
   *   {
   *     tokenId: 0,
   *     claimConditions: [{
   *       startTime: new Date(), // start the claim phase now
   *       maxClaimableSupply: 2, // limit how many mints for this tokenId
   *       price: 0.01, // price for this tokenId
   *       snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *     }]
   *   },
   *   {
   *     tokenId: 1,
   *     claimConditions: [{
   *       startTime: new Date(),
   *       price: 0.08, // different price for this tokenId
   *     }]
   *   },
   * ];
   *
   * await dropContract.claimConditions.setBatch(claimConditionsForTokens);
   * ```
   *
   * @param claimConditionsForToken - The claim conditions for each NFT
   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
   */ setBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this2 = this;
        return async function(claimConditionsForToken) {
            let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            const merkleInfo = {};
            const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async (_ref)=>{
                let { tokenId, claimConditions } = _ref;
                // sanitize for single phase deletions
                let claimConditionsProcessed = claimConditions;
                if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
                    resetClaimEligibilityForAll = true;
                    if (claimConditions.length === 0) {
                        claimConditionsProcessed = [
                            {
                                startTime: new Date(0),
                                currencyAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero,
                                price: 0,
                                maxClaimableSupply: 0,
                                maxClaimablePerWallet: 0,
                                waitInSeconds: 0,
                                merkleRootHash: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad([
                                    0
                                ], 32),
                                snapshot: []
                            }
                        ];
                    } else if (claimConditions.length > 1) {
                        throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
                    }
                }
                // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well
                if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper) || _this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
                    claimConditionsProcessed.forEach((cc)=>{
                        if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === "unlimited")) {
                            throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\n" + "Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist." + "\n\nex:\n" + "contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
                        }
                        if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === "0" && cc.snapshot.map((s)=>{
                            if (typeof s === "string") {
                                return 0;
                            } else {
                                return Number(s.maxClaimable?.toString() || 0);
                            }
                        }).reduce((acc, current)=>{
                            return acc + current;
                        }, 0) === 0) {
                            throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
                        }
                    });
                }
                // process inputs
                const { snapshotInfos, sortedConditions } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(claimConditionsProcessed, 0, _this2.contractWrapper.getProvider(), _this2.storage, _this2.getSnapshotFormatVersion());
                snapshotInfos.forEach((s)=>{
                    merkleInfo[s.merkleRoot] = s.snapshotUri;
                });
                return {
                    tokenId,
                    sortedConditions
                };
            }));
            const metadata = await _this2.metadata.get();
            const encoded = [];
            // keep the old merkle roots from other tokenIds
            for (const key of Object.keys(metadata.merkle || {})){
                merkleInfo[key] = metadata.merkle[key];
            }
            // upload new merkle roots to snapshot URIs if updated
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata.merkle, merkleInfo)) {
                const mergedMetadata = await _this2.metadata.parseInputMetadata({
                    ...metadata,
                    merkle: merkleInfo
                });
                // using internal method to just upload, avoids one contract call
                const contractURI = await _this2.metadata._parseAndUploadMetadata(mergedMetadata);
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("setContractURI", _this2.contractWrapper)) {
                    const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](_this2.contractWrapper);
                    encoded.push(contractEncoder.encode("setContractURI", [
                        contractURI
                    ]));
                } else {
                    throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
                }
            }
            processedClaimConditions.forEach((_ref2)=>{
                let { tokenId, sortedConditions } = _ref2;
                const baseContractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](_this2.contractWrapper);
                if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {
                    const legacyContractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](_this2.contractWrapper);
                    encoded.push(legacyContractEncoder.encode("setClaimConditions", [
                        tokenId,
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"])(sortedConditions[0]),
                        resetClaimEligibilityForAll
                    ]));
                } else if (_this2.isLegacyMultiPhaseDrop(_this2.contractWrapper)) {
                    encoded.push(baseContractEncoder.encode("setClaimConditions", [
                        tokenId,
                        sortedConditions.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"]),
                        resetClaimEligibilityForAll
                    ]));
                } else if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper)) {
                    encoded.push(baseContractEncoder.encode("setClaimConditions", [
                        tokenId,
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["J"])(sortedConditions[0]),
                        resetClaimEligibilityForAll
                    ]));
                } else if (_this2.isNewMultiphaseDrop(_this2.contractWrapper)) {
                    encoded.push(baseContractEncoder.encode("setClaimConditions", [
                        tokenId,
                        sortedConditions.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["J"]),
                        resetClaimEligibilityForAll
                    ]));
                } else {
                    throw new Error("Contract does not support claim conditions");
                }
            });
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("multicall", _this2.contractWrapper)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                    contractWrapper: _this2.contractWrapper,
                    method: "multicall",
                    args: [
                        encoded
                    ]
                });
            }
            throw new Error("Contract does not support multicall");
        };
    })());
    /**
   * Update a single claim condition with new data.
   * @param tokenId - the token id to update
   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`
   * @param claimConditionInput - the new data to update, previous data will be retained
   */ update = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, index, claimConditionInput)=>{
        const existingConditions = await this.getAll(tokenId);
        const newConditionInputs = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(index, claimConditionInput, existingConditions);
        return await this.set.prepare(tokenId, newConditionInputs);
    });
    /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns  `overrides` and `proofs` as an object.
   */ async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {
        const addressToClaim = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address ? address : await this.contractWrapper.getSignerAddress());
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"])(addressToClaim, quantity, await this.getActive(tokenId), async ()=>(await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
    }
    async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(destinationAddress);
        if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            return [
                resolvedAddress,
                tokenId,
                quantity,
                claimVerification.currencyAddress,
                claimVerification.price,
                claimVerification.proofs,
                claimVerification.maxClaimable
            ];
        } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            return [
                resolvedAddress,
                tokenId,
                quantity,
                claimVerification.currencyAddress,
                claimVerification.price,
                {
                    proof: claimVerification.proofs,
                    maxQuantityInAllowlist: claimVerification.maxClaimable
                },
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
            ];
        }
        return [
            resolvedAddress,
            tokenId,
            quantity,
            claimVerification.currencyAddress,
            claimVerification.price,
            {
                proof: claimVerification.proofs,
                quantityLimitPerWallet: claimVerification.maxClaimable,
                pricePerToken: claimVerification.priceInProof,
                currency: claimVerification.currencyAddressInProof
            },
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
        ];
    }
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */ async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
        if (options?.pricePerToken) {
            throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");
        }
        const claimVerification = await this.prepareClaim(tokenId, quantity, options?.checkERC20Allowance || true);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "claim",
            args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),
            overrides: claimVerification.overrides
        });
    }
    isNewSinglePhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC1155ClaimConditionsV2");
    }
    isNewMultiphaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC1155ClaimPhasesV2");
    }
    isLegacySinglePhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC1155ClaimConditionsV1");
    }
    isLegacyMultiPhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC1155ClaimPhasesV1");
    }
    getSnapshotFormatVersion() {
        return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"].V1 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"].V2;
    }
}
/**
 * @internal
 */ const AirdropAddressInput = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        address: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"],
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].default(1)
    }))();
/**
 * @internal
 */ const AirdropInputSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()).transform(async (strings)=>await Promise.all(strings.map((address)=>AirdropAddressInput.parseAsync({
                    address
                })))),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(AirdropAddressInput)
    ]))();
/**
 * Configure and claim ERC1155 NFTs
 * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.edition.drop.claim.to("0x...", tokenId, quantity);
 * ```
 */ class ERC1155Claimable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d9"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */ async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
        let overrides = {};
        if (options && options.pricePerToken) {
            overrides = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "claim",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(destinationAddress),
                tokenId,
                quantity
            ],
            overrides
        });
    }
    /**
   * Claim NFTs to a specific Wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const tokenId = 0; // the id of the NFT you want to claim
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @returns  Receipt for the transaction
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, tokenId, quantity, options)=>{
        return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    });
}
/**
 * Configure and claim ERC1155 NFTs
 * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc1155.claim(tokenId, quantity);
 * await contract.erc1155.claimConditions.getActive(tokenId);
 * ```
 */ class Erc1155ClaimableWithConditions {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["da"].name;
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        const metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
        this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);
    }
    /**
   * Claim NFTs to a specific Wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const tokenId = 0; // the id of the NFT you want to claim
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   *
   * @returns  Receipt for the transaction
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, tokenId, quantity, options)=>{
        return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
    });
}
/**
 * Enables generating dynamic ERC1155 NFTs with rules and an associated signature, which can then be minted by anyone securely
 * @erc1155
 * @public
 */ class Erc1155SignatureMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["db"].name;
    constructor(contractWrapper, storage, roles){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.roles = roles;
    }
    /**
   * Mint a dynamically generated NFT
   *
   * @remarks Mint a dynamic NFT with a previously generated signature.
   *
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `generate()` documentation
   * const signedPayload = contract.erc1155.signature.generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc1155.signature.mint(signedPayload);
   * ```
   * @param signedPayload - the previously generated payload and signature with {@link Erc1155SignatureMintable.generate}
   * @twfeature ERC1155SignatureMintable
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayload)=>{
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        const [message, overrides] = await Promise.all([
            this.mapPayloadToContractStruct(mintRequest),
            this.contractWrapper.getCallOverrides()
        ]);
        // TODO: Transaction Sequence Pattern
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [
                message,
                signature
            ],
            overrides,
            parse: (receipt)=>{
                const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
                if (t.length === 0) {
                    throw new Error("No MintWithSignature event found");
                }
                const id = t[0].args.tokenIdMinted;
                return {
                    id,
                    receipt
                };
            }
        });
    });
    /**
   * Mint any number of dynamically generated NFT at once
   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
   *
   * @example
   * ```javascript
   * // see how to craft a batch of payloads to sign in the `generateBatch()` documentation
   * const signedPayloads = contract.erc1155.signature.generateBatch(payloads);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc1155.signature.mintBatch(signedPayloads);
   * ```
   *
   * @param signedPayloads - the array of signed payloads to mint
   * @twfeature ERC1155SignatureMintable
   */ mintBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayloads)=>{
        const contractStructs = await Promise.all(signedPayloads.map((s)=>this.mapPayloadToContractStruct(s.payload)));
        const contractPayloads = signedPayloads.map((s, index)=>{
            const message = contractStructs[index];
            const signature = s.signature;
            const price = s.payload.price;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(price).gt(0)) {
                throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
            }
            return {
                message,
                signature
            };
        });
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = contractPayloads.map((p)=>{
            return contractEncoder.encode("mintWithSignature", [
                p.message,
                p.signature
            ]);
        });
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("multicall", this.contractWrapper)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "multicall",
                args: [
                    encoded
                ],
                parse: (receipt)=>{
                    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
                    if (events.length === 0) {
                        throw new Error("No MintWithSignature event found");
                    }
                    return events.map((log)=>({
                            id: log.args.tokenIdMinted,
                            receipt
                        }));
                }
            });
        } else {
            throw new Error("Multicall not supported on this contract!");
        }
    });
    /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC1155SignatureMintable
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = contract.erc1155.signature.generate(payload);
   * // Now you can verify that the payload is valid
   * const isValid = await contract.erc1155.signature.verify(signedPayload);
   * ```
   */ async verify(signedPayload) {
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        const message = await this.mapPayloadToContractStruct(mintRequest);
        const verification = await this.contractWrapper.read("verify", [
            message,
            signature
        ]);
        return verification[0];
    }
    /**
   * Generate a signature that can be used to mint an NFT dynamically.
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns The signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */ async generate(payloadToSign) {
        const payload = {
            ...payloadToSign,
            tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256
        };
        return this.generateFromTokenId(payload);
    }
    /**
   * Generate a signature that can be used to mint additionally supply to an existing NFT.
   *
   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   tokenId: 0, // Instead of metadata, we specify the token ID of the NFT to mint supply to
   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);
   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`
   * ```
   * @param payloadToSign - the payload to sign
   * @returns The signed payload and the corresponding signature
   * @twfeature ERC1155SignatureMintable
   */ async generateFromTokenId(payloadToSign) {
        const payloads = await this.generateBatchFromTokenIds([
            payloadToSign
        ]);
        return payloads[0];
    }
    /**
   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns An array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */ async generateBatch(payloadsToSign) {
        const payloads = payloadsToSign.map((payload)=>({
                ...payload,
                tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256
            }));
        return this.generateBatchFromTokenIds(payloads);
    }
    /**
   * Generate a batch of signatures that can be used to mint new NFTs or additionally supply to existing NFTs dynamically.
   *
   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}
   *
   * @param payloadsToSign - the payloads to sign with tokenIds specified
   * @returns An array of payloads and signatures
   * @twfeature ERC1155SignatureMintable
   */ async generateBatchFromTokenIds(payloadsToSign) {
        const signer = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(signer, "No signer available");
        await this.roles?.verify([
            "minter"
        ], await signer.getAddress());
        const parsedRequests = await Promise.all(payloadsToSign.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["r"].parseAsync(m)));
        const metadatas = parsedRequests.map((r)=>r.metadata);
        const [uris, chainId, contractInfo] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage),
            this.contractWrapper.getChainID(),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dc"])(this.contractWrapper.address, this.contractWrapper.getProvider())
        ]);
        const finalPayloads = await Promise.all(parsedRequests.map((m, i)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"].parseAsync({
                ...m,
                uri: uris[i]
            })));
        const contractStructs = await Promise.all(finalPayloads.map((finalPayload)=>this.mapPayloadToContractStruct(finalPayload)));
        const isLegacyContract = contractInfo?.type === "TokenERC1155";
        const signatures = await Promise.all(contractStructs.map((contractStruct)=>this.contractWrapper.signTypedData(signer, {
                name: isLegacyContract ? "TokenERC1155" : "SignatureMintERC1155",
                version: "1",
                chainId,
                verifyingContract: this.contractWrapper.address
            }, {
                MintRequest: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["w"]
            }, // TYPEHASH
            contractStruct)));
        return signatures.map((signature, index)=>({
                payload: finalPayloads[index],
                signature: signature.toString()
            }));
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns  The mapped payload.
   */ async mapPayloadToContractStruct(mintRequest) {
        const normalizedPricePerToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
        return {
            to: mintRequest.to,
            tokenId: mintRequest.tokenId,
            uri: mintRequest.uri,
            quantity: mintRequest.quantity,
            pricePerToken: normalizedPricePerToken,
            currency: mintRequest.currencyAddress,
            validityStartTimestamp: mintRequest.mintStartTime,
            validityEndTimestamp: mintRequest.mintEndTime,
            uid: mintRequest.uid,
            royaltyRecipient: mintRequest.royaltyRecipient,
            royaltyBps: mintRequest.royaltyBps,
            primarySaleRecipient: mintRequest.primarySaleRecipient
        };
    }
}
class Erc1155Burnable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dd"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Burn a specified amount of a NFTs
   *
   * @remarks Burn the specified NFTs from the connected wallet
   *
   * @param tokenId - the token Id to burn
   * @param amount - amount to burn
   *
   * @example
   * ```javascript
   * // The token ID to burn NFTs of
   * const tokenId = 0;
   * // The amount of the NFT you want to burn
   * const amount = 2;
   *
   * const result = await contract.edition.burn.tokens(tokenId, amount);
   * ```
   */ tokens = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, amount)=>{
        const account = await this.contractWrapper.getSignerAddress();
        return this.from.prepare(account, tokenId, amount);
    });
    /**
   * Burn a specified amount of a NFTs
   *
   * @remarks Burn the specified NFTs from a specified wallet
   *
   * @param account - the address to burn NFTs from
   * @param tokenId - the tokenId to burn
   * @param amount - amount to burn
   *
   * @example
   * ```javascript
   * // The address of the wallet to burn NFTS from
   * const account = "0x...";
   * // The token ID to burn NFTs of
   * const tokenId = 0;
   * // The amount of this NFT you want to burn
   * const amount = 2;
   *
   * const result = await contract.edition.burn.from(account, tokenId, amount);
   * ```
   */ from = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (account, tokenId, amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "burn",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(account),
                tokenId,
                amount
            ]
        });
    });
    /**
   * Burn a batch of NFTs
   *
   * @remarks Burn the batch NFTs from the connected wallet
   *
   * @param tokenIds - the tokenIds to burn
   * @param amounts - amount of each token to burn
   *
   * @example
   * ```javascript
   * // The token IDs to burn NFTs of
   * const tokenIds = [0, 1];
   * // The amounts of each NFT you want to burn
   * const amounts = [2, 2];
   *
   * const result = await contract.edition.burn.batch(tokenIds, amounts);
   * ```
   */ batch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenIds, amounts)=>{
        const account = await this.contractWrapper.getSignerAddress();
        return this.batchFrom.prepare(account, tokenIds, amounts);
    });
    /**
   * Burn a batch of NFTs
   *
   * @remarks Burn the batch NFTs from the specified wallet
   *
   * @param account - the address to burn NFTs from
   * @param tokenIds - the tokenIds to burn
   * @param amounts - amount of each token to burn
   *
   * @example
   * ```javascript
   * // The address of the wallet to burn NFTS from
   * const account = "0x...";
   * // The token IDs to burn NFTs of
   * const tokenIds = [0, 1];
   * // The amounts of each NFT you want to burn
   * const amounts = [2, 2];
   *
   * const result = await contract.edition.burn.batchFrom(account, tokenIds, amounts);
   * ```
   */ batchFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (account, tokenIds, amounts)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "burnBatch",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(account),
                tokenIds,
                amounts
            ]
        });
    });
}
/**
 * List ERC1155 NFTs
 * @remarks Easily list all the NFTs in a ERC1155 contract.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const nfts = await contract.edition.query.all();
 * ```
 * @public
 */ class Erc1155Enumerable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["de"].name;
    constructor(erc1155, contractWrapper){
        this.erc1155 = erc1155;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get All NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.edition.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */ async all(queryParams) {
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(queryParams?.start || 0).toNumber();
        const count = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"]).toNumber();
        const maxId = Math.min((await this.totalCount()).toNumber(), start + count);
        return await Promise.all([
            ...Array(maxId - start).keys()
        ].map((i)=>this.erc1155.get((start + i).toString())));
    }
    /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns The total number of NFTs minted in this contract
   * @public
   */ async totalCount() {
        return await this.contractWrapper.read("nextTokenIdToMint", []);
    }
    /**
   * Get the supply of token for a given tokenId.
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns The total number of NFTs minted in this contract
   * @public
   */ async totalCirculatingSupply(tokenId) {
        return await this.contractWrapper.read("totalSupply", [
            tokenId
        ]);
    }
    /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.edition.query.owned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   */ async owned(walletAddress, queryParams) {
        const [address, maxId] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress || await this.contractWrapper.getSignerAddress()),
            this.contractWrapper.read("nextTokenIdToMint", [])
        ]);
        const balances = await this.contractWrapper.read("balanceOfBatch", [
            Array(maxId.toNumber()).fill(address),
            Array.from(Array(maxId.toNumber()).keys())
        ]);
        let ownedBalances = balances.map((b, i)=>{
            return {
                tokenId: i,
                balance: b
            };
        }).filter((b)=>b.balance.gt(0));
        if (queryParams) {
            const start = queryParams?.start || 0;
            const count = queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
            ownedBalances = ownedBalances.slice(start, start + count);
        }
        const nfts = (await Promise.all(ownedBalances.map((item)=>this.erc1155.get(item.tokenId.toString())))).map((editionMetadata, index)=>({
                ...editionMetadata,
                owner: address,
                quantityOwned: ownedBalances[index].balance.toString()
            }));
        return nfts;
    }
}
class Erc1155LazyMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["df"].name;
    /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.edition.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.edition.drop.revealer.reveal(batchId, "my secret password");
   * ```
   */ constructor(erc1155, contractWrapper, storage){
        this.erc1155 = erc1155;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.revealer = this.detectErc1155Revealable();
    }
    /**
   * Create a batch of NFTs to be claimed in the future
   *
   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.
   *
   * @example
   * ```javascript
   * // Custom metadata of the NFTs to create
   * const metadatas = [{
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   *
   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain
   * const firstTokenId = results[0].id; // token id of the first created NFT
   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
   * ```
   *
   * @param metadatas - The metadata to include in the batch.
   * @param options - optional upload progress callback
   */ lazyMint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas, options)=>{
        const startFileNumber = await this.erc1155.nextTokenIdToMint();
        const batch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage, startFileNumber.toNumber(), options);
        // ensure baseUri is the same for the entire batch
        const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
        for(let i = 0; i < batch.length; i++){
            const uri = batch[i].substring(0, batch[i].lastIndexOf("/"));
            if (baseUri !== uri) {
                throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);
            }
        }
        const parse = (receipt)=>{
            const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
            const startingIndex = event[0].args.startTokenId;
            const endingIndex = event[0].args.endTokenId;
            const results = [];
            for(let id = startingIndex; id.lte(endingIndex); id = id.add(1)){
                results.push({
                    id,
                    receipt,
                    data: ()=>this.erc1155.getTokenMetadata(id)
                });
            }
            return results;
        };
        const prebuiltInfo = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dc"])(this.contractWrapper.address, this.contractWrapper.getProvider());
        if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "lazyMint",
                args: [
                    batch.length,
                    `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`
                ],
                parse
            });
        } else {
            // new contracts/extensions have support for delayed reveal that adds an extra parameter to lazyMint
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "lazyMint",
                args: [
                    batch.length,
                    `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`,
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
                ],
                parse
            });
        }
    });
    updateMetadata = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, metadata, options)=>{
        const batchCount = await this.contractWrapper.read("getBaseURICount", []);
        if (batchCount.eq(0)) {
            throw new Error("No base URI set. Please set a base URI before updating metadata");
        }
        const targetTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId);
        let startTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        let endTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        let batchIndex = 0;
        for(let i = 0; i < batchCount.toNumber(); i++){
            batchIndex = i;
            endTokenId = await this.contractWrapper.read("getBatchIdAtIndex", [
                batchIndex
            ]);
            if (endTokenId.gt(targetTokenId)) {
                break;
            }
            startTokenId = endTokenId;
        }
        // for the entire batch,
        // 1. download all of the metadata as a list of nft metadata
        const range = Array.from({
            length: endTokenId.sub(startTokenId).toNumber()
        }, (v, k)=>k + startTokenId.toNumber());
        const metadatas = await Promise.all(range.map((id)=>this.erc1155.getTokenMetadata(id)));
        // 2. replace the metadata of the tokenId desired
        const newMetadatas = [];
        for(let i = 0; i < metadatas.length; i++){
            const { id, uri, ...rest } = metadatas[i];
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(targetTokenId).eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(id))) {
                newMetadatas.push(metadata);
            } else {
                newMetadatas.push(rest);
            }
        }
        // 3. re-upload the entire batch with the correct starting number
        const batch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(newMetadatas, this.storage, startTokenId.toNumber(), options);
        const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
        // 4. update the base uri for the entire batch
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            // TODO contract detection
            method: "updateBatchBaseURI",
            args: [
                batchIndex,
                `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`
            ]
        });
    });
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ detectErc1155Revealable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155Revealable")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"](this.contractWrapper, this.storage, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dg"].name, ()=>this.erc1155.nextTokenIdToMint());
        }
        return undefined;
    }
    isLegacyEditionDropContract(contractWrapper, info) {
        return info && info.type === "DropERC1155" && info.version < 3 || false;
    }
}
/**
 * Mint Many ERC1155 NFTs at once
 * @remarks NFT batch minting functionality that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.edition.mint.batch.to(walletAddress, [nftMetadataWithSupply1, nftMetadataWithSupply2, ...]);
 * ```
 * @public
 */ class Erc1155BatchMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dh"].name;
    constructor(erc1155, contractWrapper, storage){
        this.erc1155 = erc1155;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Mint Many NFTs with limited supplies
   *
   * @remarks Mint many different NFTs with limited supplies to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   *
   * // Custom metadata and supplies of your NFTs
   * const metadataWithSupply = [{
   *   supply: 50, // The number of this NFT you want to mint
   *   metadata: {
   *     name: "Cool NFT #1",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }, {
   *   supply: 100,
   *   metadata: {
   *     name: "Cool NFT #2",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }];
   *
   * const tx = await contract.edition.mint.batch.to(toAddress, metadataWithSupply);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, metadataWithSupply)=>{
        const metadatas = metadataWithSupply.map((a)=>a.metadata);
        const supplies = metadataWithSupply.map((a)=>a.supply);
        const uris = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage);
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to);
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = await Promise.all(uris.map(async (uri, index)=>contractEncoder.encode("mintTo", [
                resolvedAddress,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256,
                uri,
                supplies[index]
            ])));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
                if (events.length === 0 || events.length < metadatas.length) {
                    throw new Error("TokenMinted event not found, minting failed");
                }
                return events.map((e)=>{
                    const id = e.args.tokenIdMinted;
                    return {
                        id,
                        receipt,
                        data: ()=>this.erc1155.get(id)
                    };
                });
            }
        });
    });
}
/**
 * Mint ERC1155 NFTs
 * @remarks NFT minting functionality that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.edition.mint.to(walletAddress, nftMetadata);
 * ```
 * @public
 */ class Erc1155Mintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["di"].name;
    /**
   * Batch mint Tokens to many addresses
   */ constructor(erc1155, contractWrapper, storage){
        this.erc1155 = erc1155;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.batch = this.detectErc1155BatchMintable();
    }
    /**
   * Mint an NFT with a limited supply
   *
   * @remarks Mint an NFT with a limited supply to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   *
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }
   *
   * const metadataWithSupply = {
   *   metadata,
   *   supply: 1000, // The number of this NFT you want to mint
   * }
   *
   * const tx = await contract.edition.mint.to(toAddress, metadataWithSupply);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   *
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, metadataWithSupply)=>{
        const tx = await this.getMintTransaction(to, metadataWithSupply);
        tx.setParse((receipt)=>{
            const event = this.contractWrapper.parseLogs("TransferSingle", receipt?.logs);
            if (event.length === 0) {
                throw new Error("TransferSingleEvent event not found");
            }
            const id = event[0].args.id;
            return {
                id,
                receipt,
                data: ()=>this.erc1155.get(id.toString())
            };
        });
        return tx;
    });
    /**
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   */ async getMintTransaction(to, metadataWithSupply) {
        const uri = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(metadataWithSupply.metadata, this.storage);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintTo",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256,
                uri,
                metadataWithSupply.supply
            ]
        });
    }
    /**
   * Increase the supply of an existing NFT and mint it to a given wallet address
   *
   * @param to - the address to mint to
   * @param tokenId - the token id of the NFT to increase supply of
   * @param additionalSupply - the additional amount to mint
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   * const tokenId = 0;
   * const additionalSupply = 1000;
   *
   * const tx = await contract.edition.mint.additionalSupplyTo(toAddress, tokenId, additionalSupply);
   * ```
   */ additionalSupplyTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, tokenId, additionalSupply)=>{
        const metadata = await this.erc1155.getTokenMetadata(tokenId);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintTo",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                tokenId,
                metadata.uri,
                additionalSupply
            ],
            parse: (receipt)=>{
                return {
                    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId),
                    receipt,
                    data: ()=>this.erc1155.get(tokenId)
                };
            }
        });
    });
    detectErc1155BatchMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155BatchMintable")) {
            return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);
        }
    }
}
/**
 * Standard ERC1155 NFT functions
 * @remarks Basic functionality for a ERC1155 contract that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc1155.transfer(walletAddress, tokenId, quantity);
 * ```
 * @erc1155
 * @public
 */ class Erc1155 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dj"].name;
    get chainId() {
        return this._chainId;
    }
    constructor(contractWrapper, storage, chainId){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.query = this.detectErc1155Enumerable();
        this.mintable = this.detectErc1155Mintable();
        this.burnable = this.detectErc1155Burnable();
        this.lazyMintable = this.detectErc1155LazyMintable();
        this.signatureMintable = this.detectErc1155SignatureMintable();
        this.claimCustom = this.detectErc1155Claimable();
        this.claimWithConditions = this.detectErc1155ClaimableWithConditions();
        this._chainId = chainId;
    }
    /**
   * @internal
   */ onNetworkUpdated(network) {
        this.contractWrapper.updateSignerOrProvider(network);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    ////// Standard ERC1155 functions //////
    /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC1155
   */ async get(tokenId) {
        const [supply, metadata] = await Promise.all([
            this.contractWrapper.read("totalSupply", [
                tokenId
            ]).catch(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0)),
            this.getTokenMetadata(tokenId).catch(()=>({
                    id: tokenId.toString(),
                    uri: "",
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"]
                }))
        ]);
        return {
            owner: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero,
            metadata,
            type: "ERC1155",
            supply: supply.toString()
        };
    }
    /**
   * Get the total supply of a specific token
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc1155.totalSupply(tokenId);
   * ```
   * @param tokenId - The token ID to get the total supply of
   * @returns The total supply
   * @twfeature ERC1155
   */ async totalSupply(tokenId) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155Supply")) {
            return await this.contractWrapper.read("totalSupply", [
                tokenId
            ]);
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dk"]);
        }
    }
    /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * // Address of the wallet to check NFT balance
   * const walletAddress = "{{wallet_address}}";
   * const tokenId = 0; // Id of the NFT to check
   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);
   * ```
   * @twfeature ERC1155
   */ async balanceOf(address, tokenId) {
        return await this.contractWrapper.read("balanceOf", [
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address),
            tokenId
        ]);
    }
    /**
   * Get NFT balance for the currently connected wallet
   */ async balance(tokenId) {
        return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);
    }
    /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */ async isApproved(address, operator) {
        return await this.contractWrapper.read("isApprovedForAll", [
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address),
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(operator)
        ]);
    }
    /**
   * Transfer an NFT
   *
   * @remarks Transfer an NFT from the connected wallet to another wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to send the NFT to
   * const toAddress = "{{wallet_address}}";
   * const tokenId = "0"; // The token ID of the NFT you want to send
   * const amount = 3; // How many copies of the NFTs to transfer
   * await contract.erc1155.transfer(toAddress, tokenId, amount);
   * ```
   * @twfeature ERC1155
   */ transfer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this = this;
        return async function(to, tokenId, amount) {
            let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [
                0
            ];
            const from = await _this.contractWrapper.getSignerAddress();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: _this.contractWrapper,
                method: "safeTransferFrom",
                args: [
                    from,
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                    tokenId,
                    amount,
                    data
                ]
            });
        };
    })());
    /**
   * Transfer multiple NFTs
   *
   * @remarks Transfer multiple NFTs from the connected wallet to another wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to send the NFT to
   * const toAddress = "{{wallet_address}}";
   * // The token IDs of the NFTs you want to send
   * const tokenIds = [0, 1, 2];
   * // How many copies of the NFTs to transfer
   * const amounts = [1, 2, 3];
   * await contract.erc1155.transferBatch(toAddress, tokenIds, amounts);
   * ```
   *
   * @twfeature ERC1155BatchTransferable
   */ transferBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this2 = this;
        return async function(to, tokenIds, amounts, fromAddress) {
            let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [
                0
            ];
            const from = fromAddress ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(fromAddress) : await _this2.contractWrapper.getSignerAddress();
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: _this2.contractWrapper,
                method: "safeBatchTransferFrom",
                args: [
                    from,
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                    tokenIds,
                    amounts,
                    data
                ]
            });
        };
    })());
    /**
   * Transfer an NFT from a specific wallet
   *
   * @remarks Transfer an NFT from a specific wallet to another wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to send the NFT to
   * const toAddress = "{{wallet_address}}";
   * const tokenId = "0"; // The token ID of the NFT you want to send
   * const amount = 3; // How many copies of the NFTs to transfer
   * await contract.erc1155.transfer(toAddress, tokenId, amount);
   * ```
   * @twfeature ERC1155
   */ transferFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this3 = this;
        return async function(from, to, tokenId, amount) {
            let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [
                0
            ];
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: _this3.contractWrapper,
                method: "safeTransferFrom",
                args: [
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(from),
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                    tokenId,
                    amount,
                    data
                ]
            });
        };
    })());
    /**
   * Set approval for all NFTs
   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
   * @example
   * ```javascript
   * const operator = "{{wallet_address}}";
   * await contract.erc1155.setApprovalForAll(operator, true);
   * ```
   * @param operator - the operator's address
   * @param approved - whether to approve or remove
   * @twfeature ERC1155
   */ setApprovalForAll = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (operator, approved)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setApprovalForAll",
            args: [
                operator,
                approved
            ]
        });
    });
    /**
   * Airdrop multiple NFTs
   *
   * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.
   *
   * @example
   * ```javascript
   * // The token ID of the NFT you want to airdrop
   * const tokenId = "0";
   * // Array of objects of addresses and quantities to airdrop NFTs to
   * const addresses = [
   *  {
   *    address: "0x...",
   *    quantity: 2,
   *  },
   *  {
   *   address: "0x...",
   *    quantity: 3,
   *  },
   * ];
   * await contract.erc1155.airdrop(tokenId, addresses);
   *
   * // You can also pass an array of addresses, it will airdrop 1 NFT per address
   * const tokenId = "0";
   * const addresses = [
   *  "0x...", "0x...", "0x...",
   * ]
   * await contract.erc1155.airdrop(tokenId, addresses);
   * ```
   * @twfeature ERC1155BatchTransferable
   */ airdrop = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this4 = this;
        return async function(tokenId, addresses, fromAddress) {
            let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [
                0
            ];
            const from = fromAddress ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(fromAddress) : await _this4.contractWrapper.getSignerAddress();
            const balanceOf = await _this4.balanceOf(from, tokenId);
            const input = await AirdropInputSchema.parseAsync(addresses);
            const totalToAirdrop = input.reduce((prev, curr)=>{
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(prev).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(curr?.quantity || 1));
            }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0));
            if (balanceOf.lt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(totalToAirdrop))) {
                throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);
            }
            const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](_this4.contractWrapper);
            const encoded = input.map((_ref)=>{
                let { address: to, quantity } = _ref;
                return contractEncoder.encode("safeTransferFrom", [
                    from,
                    to,
                    tokenId,
                    quantity,
                    data
                ]);
            });
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: _this4.contractWrapper,
                method: "multicall",
                args: [
                    encoded
                ]
            });
        };
    })());
    /**
   * Return the next available token ID to mint
   * @internal
   */ async nextTokenIdToMint() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("nextTokenIdToMint", this.contractWrapper)) {
            return await this.contractWrapper.read("nextTokenIdToMint", []);
        } else {
            throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint");
        }
    }
    ////// ERC1155 Enumerable Extension //////
    /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc1155.getAll();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC1155Enumerable
   */ async getAll(queryParams) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["de"]).all(queryParams);
    }
    /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc1155.totalCount();
   * console.log(count);
   * ```
   * @returns The total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */ async totalCount() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["de"]).totalCount();
    }
    /**
   * Get the total supply of a specific NFT
   * @remarks This is **not** the sum of supply of all NFTs in the contract.
   *
   * @returns The total number of NFTs minted in this contract
   * @public
   * @twfeature ERC1155Enumerable
   */ async totalCirculatingSupply(tokenId) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["de"]).totalCirculatingSupply(tokenId);
    }
    /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc1155.getOwned(address);
   * ```
   *
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC1155Enumerable
   */ async getOwned(walletAddress, queryParams) {
        if (walletAddress) {
            walletAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["de"]).owned(walletAddress, queryParams);
    }
    ////// ERC1155 Mintable Extension //////
    /**
   * Mint an NFT
   *
   * @remarks Mint an NFT with a limited supply to the connected wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   *
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }
   *
   * const metadataWithSupply = {
   *   metadata,
   *   supply: 1000, // The number of this NFT you want to mint
   * }
   *
   * const tx = await contract.erc1155.mint(toAddress, metadataWithSupply);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   * @twfeature ERC1155Mintable
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadataWithSupply)=>{
        return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    });
    /**
   * Mint an NFT to a specific wallet
   *
   * @remarks Mint an NFT with a limited supply to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   *
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }
   *
   * const metadataWithSupply = {
   *   metadata,
   *   supply: 1000, // The number of this NFT you want to mint
   * }
   *
   * const tx = await contract.erc1155.mintTo(toAddress, metadataWithSupply);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   * @twfeature ERC1155Mintable
   */ mintTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, metadataWithSupply)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["di"]).to.prepare(receiver, metadataWithSupply);
    });
    /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadataWithSupply - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead
   * @twfeature ERC1155Mintable
   */ async getMintTransaction(receiver, metadataWithSupply) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["di"]).getMintTransaction(receiver, metadataWithSupply);
    }
    /**
   * Increase the supply of an existing NFT
   * @remarks Increase the supply of an existing NFT and mint it to the connected wallet address
   * @example
   * ```javascript
   * const tokenId = 0;
   * const additionalSupply = 1000;
   * await contract.erc1155.mintAdditionalSupply(tokenId, additionalSupply);
   * ```
   *
   * @param tokenId - the token id of the NFT to increase supply of
   * @param additionalSupply - the additional amount to mint
   * @twfeature ERC1155Mintable
   */ mintAdditionalSupply = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, additionalSupply)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["di"]).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);
    });
    /**
   * Increase the supply of an existing NFT and mint it to a given wallet address
   *
   * @param to - the address to mint to
   * @param tokenId - the token id of the NFT to increase supply of
   * @param additionalSupply - the additional amount to mint
   * @twfeature ERC1155Mintable
   */ mintAdditionalSupplyTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, tokenId, additionalSupply)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["di"]).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);
    });
    ////// ERC1155 BatchMintable Extension //////
    /**
   * Mint multiple NFTs at once
   *
   * @remarks Mint multiple different NFTs with limited supplies to the connected wallet.
   *
   * @example
   * ```javascript
   * // Custom metadata and supplies of your NFTs
   * const metadataWithSupply = [{
   *   supply: 50, // The number of this NFT you want to mint
   *   metadata: {
   *     name: "Cool NFT #1",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }, {
   *   supply: 100,
   *   metadata: {
   *     name: "Cool NFT #2",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }];
   *
   * const tx = await contract.erc1155.mintBatch(metadataWithSupply);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   * @twfeature ERC1155BatchMintable
   */ mintBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadataWithSupply)=>{
        return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);
    });
    /**
   * Mint multiple NFTs at once to a specific wallet
   *
   * @remarks Mint multiple different NFTs with limited supplies to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const toAddress = "{{wallet_address}}"
   *
   * // Custom metadata and supplies of your NFTs
   * const metadataWithSupply = [{
   *   supply: 50, // The number of this NFT you want to mint
   *   metadata: {
   *     name: "Cool NFT #1",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }, {
   *   supply: 100,
   *   metadata: {
   *     name: "Cool NFT #2",
   *     description: "This is a cool NFT",
   *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   *   },
   * }];
   *
   * const tx = await contract.erc1155.mintBatchTo(toAddress, metadataWithSupply);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   * @twfeature ERC1155BatchMintable
   */ mintBatchTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, metadataWithSupply)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable?.batch, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dh"]).to.prepare(receiver, metadataWithSupply);
    });
    ////// ERC1155 Burnable Extension //////
    /**
   * Burn NFTs
   *
   * @remarks Burn the specified NFTs from the connected wallet
   *
   * @param tokenId - the token Id to burn
   * @param amount - amount to burn
   *
   * @example
   * ```javascript
   * // The token ID to burn NFTs of
   * const tokenId = 0;
   * // The amount of the NFT you want to burn
   * const amount = 2;
   *
   * const result = await contract.erc1155.burn(tokenId, amount);
   * ```
   * @twfeature ERC1155Burnable
   */ burn = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, amount)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dd"]).tokens.prepare(tokenId, amount);
    });
    /**
   * Burn NFTs from a specific wallet
   *
   * @remarks Burn the specified NFTs from a specified wallet
   *
   * @param account - the address to burn NFTs from
   * @param tokenId - the tokenId to burn
   * @param amount - amount to burn
   *
   * @example
   * ```javascript
   * // The address of the wallet to burn NFTS from
   * const account = "0x...";
   * // The token ID to burn NFTs of
   * const tokenId = 0;
   * // The amount of this NFT you want to burn
   * const amount = 2;
   *
   * const result = await contract.erc1155.burnFrom(account, tokenId, amount);
   * ```
   * @twfeature ERC1155Burnable
   */ burnFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (account, tokenId, amount)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dd"]).from.prepare(account, tokenId, amount);
    });
    /**
   * Burn a batch of NFTs
   *
   * @remarks Burn the batch NFTs from the connected wallet
   *
   * @param tokenIds - the tokenIds to burn
   * @param amounts - amount of each token to burn
   *
   * @example
   * ```javascript
   * // The token IDs to burn NFTs of
   * const tokenIds = [0, 1];
   * // The amounts of each NFT you want to burn
   * const amounts = [2, 2];
   *
   * const result = await contract.erc1155.burnBatch(tokenIds, amounts);
   * ```
   * @twfeature ERC1155Burnable
   */ burnBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenIds, amounts)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dd"]).batch.prepare(tokenIds, amounts);
    });
    /**
   * Burn a batch of NFTs from a specific wallet
   *
   * @remarks Burn the batch NFTs from the specified wallet
   *
   * @param account - the address to burn NFTs from
   * @param tokenIds - the tokenIds to burn
   * @param amounts - amount of each token to burn
   *
   * @example
   * ```javascript
   * // The address of the wallet to burn NFTS from
   * const account = "0x...";
   * // The token IDs to burn NFTs of
   * const tokenIds = [0, 1];
   * // The amounts of each NFT you want to burn
   * const amounts = [2, 2];
   *
   * const result = await contract.erc1155.burnBatchFrom(account, tokenIds, amounts);
   * ```
   * @twfeature ERC1155Burnable
   */ burnBatchFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (account, tokenIds, amounts)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dd"]).batchFrom.prepare(account, tokenIds, amounts);
    });
    ////// ERC721 LazyMint Extension //////
    /**
   * Lazy mint NFTs
   *
   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.
   *
   * @example
   * ```javascript
   * // Custom metadata of the NFTs to create
   * const metadatas = [{
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   *
   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain
   * const firstTokenId = results[0].id; // token id of the first created NFT
   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
   * ```
   *
   * @param metadatas - The metadata to include in the batch.
   * @param options - optional upload progress callback
   * @twfeature ERC1155LazyMintableV1 | ERC1155LazyMintableV2
   */ lazyMint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas, options)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.lazyMintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["df"]).lazyMint.prepare(metadatas, options);
    });
    ////// ERC1155 Update Metadata Extension //////
    /**
   * Update the metadata of an NFT
   *
   * @remarks Update the metadata of an NFT in the connected wallet
   *
   * @example
   * ```javascript
   * // The token ID of the NFT you want to update
   * const tokenId = 0;
   * // The updated metadata of the NFT
   * const metadata = {
   *   name: "Updated NFT",
   *   description: "This is an updated NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }
   *
   * const result = await contract.erc1155.updateMetadata(tokenId, metadata);
   * ```
   * @twfeature ERC1155UpdateMetadata
   */ updateMetadata = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, metadata)=>{
        if (this.lazyMintable) {
            return this.lazyMintable.updateMetadata.prepare(tokenId, metadata);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155UpdatableMetadata")) {
            const uri = await this.storage.upload(metadata);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "setTokenURI",
                args: [
                    tokenId,
                    uri
                ]
            });
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dl"]);
        }
    });
    ////// ERC1155 Claimable Extension //////
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Optional claim verification data (e.g. price, currency, etc...)
   *
   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead
   */ async getClaimTransaction(destinationAddress, tokenId, quantity, options) {
        const claimWithConditions = this.claimWithConditions;
        const claim = this.claimCustom;
        if (claimWithConditions) {
            return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);
        }
        if (claim) {
            return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d9"]);
    }
    /**
   * Claim NFTs
   *
   * @remarks Let the connected wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const tokenId = 0; // the id of the NFT you want to claim
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc1155.claim(tokenId, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Optional claim verification data (e.g. price, currency, etc...)
   *
   * @returns  Receipt for the transaction
   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
   */ claim = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, quantity, options)=>{
        return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);
    });
    /**
   * Claim NFTs to a specific Wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const tokenId = 0; // the id of the NFT you want to claim
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Optional claim verification data (e.g. price, currency, etc...)
   *
   * @returns  Receipt for the transaction
   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
   */ claimTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, tokenId, quantity, options)=>{
        const claimWithConditions = this.claimWithConditions;
        const claim = this.claimCustom;
        if (claimWithConditions) {
            return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options);
        }
        if (claim) {
            return claim.to.prepare(destinationAddress, tokenId, quantity, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d9"]);
    });
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);
   * ```
   * @twfeature ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1
   */ get claimConditions() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.claimWithConditions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["da"]).conditions;
    }
    ////// ERC1155 SignatureMintable Extension //////
    /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation
   * const signedPayload = contract.erc1155.signature().generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc1155.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC1155SignatureMintable
   */ get signature() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.signatureMintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["db"]);
    }
    ////// ERC1155 DelayedReveal Extension //////
    /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc1155.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC1155Revealable
   */ get revealer() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.lazyMintable?.revealer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dg"]);
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * @internal
   * @param tokenId - the token Id to fetch
   */ async getTokenMetadata(tokenId) {
        const tokenUri = await this.contractWrapper.read("uri", [
            tokenId
        ]);
        if (!tokenUri) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"]();
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(tokenId, tokenUri, this.storage);
    }
    detectErc1155Enumerable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155Enumerable")) {
            return new Erc1155Enumerable(this, this.contractWrapper);
        }
    }
    detectErc1155Mintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155Mintable")) {
            return new Erc1155Mintable(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc1155Burnable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155Burnable")) {
            return new Erc1155Burnable(this.contractWrapper);
        }
        return undefined;
    }
    detectErc1155LazyMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155LazyMintableV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155LazyMintableV2")) {
            return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc1155SignatureMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155SignatureMintable")) {
            return new Erc1155SignatureMintable(this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc1155Claimable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155ClaimCustom")) {
            return new ERC1155Claimable(this.contractWrapper);
        }
        return undefined;
    }
    detectErc1155ClaimableWithConditions() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155ClaimConditionsV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155ClaimConditionsV2") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155ClaimPhasesV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155ClaimPhasesV2")) {
            return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);
        }
        return undefined;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-e6f2abbf.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "D": (()=>DropClaimConditions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-client] (ecmascript) <export * as constants>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
/**
 * Manages claim conditions for NFT Drop contracts
 * @erc721
 * @public
 */ class DropClaimConditions {
    constructor(contractWrapper, metadata, storage){
        this.storage = storage;
        this.contractWrapper = contractWrapper;
        this.metadata = metadata;
    }
    /** ***************************************
   * READ FUNCTIONS
   *****************************************/ /**
   * Get the currently active claim condition
   *
   * @returns The claim condition metadata
   */ async getActive(options) {
        const [cc, metadata, tokenDecimals] = await Promise.all([
            this.get(),
            this.metadata.get(),
            this.getTokenDecimals()
        ]);
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"])(cc, tokenDecimals, this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);
    }
    async get(conditionId) {
        if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            const contractModel = await this.contractWrapper.read("claimCondition", []);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["z"])(contractModel);
        } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
            const contractModel = await this.contractWrapper.read("getClaimConditionById", [
                id
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["z"])(contractModel);
        } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            const contractModel = await this.contractWrapper.read("claimCondition", []);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"])(contractModel);
        } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read("getActiveClaimConditionId", []);
            const contractModel = await this.contractWrapper.read("getClaimConditionById", [
                id
            ]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"])(contractModel);
        } else {
            throw new Error("Contract does not support claim conditions");
        }
    }
    /**
   * Get all the claim conditions
   *
   * @returns The claim conditions metadata
   */ async getAll(options) {
        if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
            const [currentStartId, countBn] = await this.contractWrapper.read("claimCondition", []);
            const startId = currentStartId.toNumber();
            const count = countBn.toNumber();
            const conditions = [];
            for(let i = startId; i < startId + count; i++){
                conditions.push(this.get(i));
            }
            const [metadata, decimals, ...fetchedConditions] = await Promise.all([
                this.metadata.get(),
                this.getTokenDecimals(),
                ...conditions
            ]);
            return Promise.all(fetchedConditions.map((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["y"])(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));
        } else {
            return [
                await this.getActive(options)
            ];
        }
    }
    /**
   * Can Claim
   *
   * @remarks Check if the drop can currently be claimed.
   *
   * @example
   * ```javascript
   * // Quantity of tokens to check claimability of
   * const quantity = 1;
   * const canClaim = await contract.canClaim(quantity);
   * ```
   */ async canClaim(quantity, addressToCheck) {
        // TODO switch to use verifyClaim
        if (addressToCheck) {
            addressToCheck = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressToCheck);
        }
        return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;
    }
    /**
   * For any claim conditions that a particular wallet is violating,
   * this function returns human readable information about the
   * breaks in the condition that can be used to inform the user.
   *
   * @param quantity - The desired quantity that would be claimed.
   * @param addressToCheck - The wallet address, defaults to the connected wallet.
   *
   */ async getClaimIneligibilityReasons(quantity, addressToCheck) {
        const reasons = [];
        let activeConditionIndex;
        let claimCondition;
        if (addressToCheck === undefined) {
            try {
                addressToCheck = await this.contractWrapper.getSignerAddress();
            } catch (err) {
                console.warn("failed to get signer address", err);
            }
        }
        // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason
        if (!addressToCheck) {
            return [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NoWallet
            ];
        }
        const [resolvedAddress, decimals] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(addressToCheck),
            this.getTokenDecimals()
        ]);
        const quantityWithDecimals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].parse(quantity), decimals);
        try {
            claimCondition = await this.getActive();
        } catch (err) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "!CONDITION") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "no active mint condition") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"])(err, "DropNoActiveCondition")) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NoClaimConditionSet);
                return reasons;
            }
            console.warn("failed to get active claim condition", err);
            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].Unknown);
            return reasons;
        }
        if (claimCondition.availableSupply !== "unlimited") {
            const supplyWithDecimals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(claimCondition.availableSupply, decimals);
            if (supplyWithDecimals.lt(quantityWithDecimals)) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughSupply);
                return reasons;
            }
        }
        // check for merkle root inclusion
        const merkleRootArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].stripZeros(claimCondition.merkleRootHash);
        const hasAllowList = merkleRootArray.length > 0;
        let allowListEntry = null;
        if (hasAllowList) {
            allowListEntry = await this.getClaimerProofs(resolvedAddress);
            if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {
                // exclusive allowlist behavior
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                return reasons;
            }
            if (allowListEntry) {
                try {
                    const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);
                    let validMerkleProof;
                    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
                        // legacy verifyClaimerMerkleProofs function
                        [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                            activeConditionIndex,
                            resolvedAddress,
                            quantity,
                            claimVerification.proofs,
                            claimVerification.maxClaimable
                        ]);
                        if (!validMerkleProof) {
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                            return reasons;
                        }
                    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                        [validMerkleProof] = await this.contractWrapper.read("verifyClaimMerkleProof", [
                            resolvedAddress,
                            quantity,
                            {
                                proof: claimVerification.proofs,
                                maxQuantityInAllowlist: claimVerification.maxClaimable
                            }
                        ]);
                        if (!validMerkleProof) {
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                            return reasons;
                        }
                    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
                        await this.contractWrapper.read("verifyClaim", [
                            resolvedAddress,
                            quantity,
                            claimVerification.currencyAddress,
                            claimVerification.price,
                            {
                                proof: claimVerification.proofs,
                                quantityLimitPerWallet: claimVerification.maxClaimable,
                                currency: claimVerification.currencyAddressInProof,
                                pricePerToken: claimVerification.priceInProof
                            }
                        ]);
                    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {
                        activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
                        await this.contractWrapper.read("verifyClaim", [
                            activeConditionIndex,
                            resolvedAddress,
                            quantity,
                            claimVerification.currencyAddress,
                            claimVerification.price,
                            {
                                proof: claimVerification.proofs,
                                quantityLimitPerWallet: claimVerification.maxClaimable,
                                currency: claimVerification.currencyAddressInProof,
                                pricePerToken: claimVerification.priceInProof
                            }
                        ]);
                    }
                } catch (e) {
                    console.warn("Merkle proof verification failed:", "reason" in e ? e.reason || e.errorName : e);
                    const reason = e.reason || e.errorName;
                    switch(reason){
                        case "!Qty":
                        case "DropClaimExceedLimit":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].OverMaxClaimablePerWallet);
                            break;
                        case "!PriceOrCurrency":
                        case "DropClaimInvalidTokenPrice":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].WrongPriceOrCurrency);
                            break;
                        case "!MaxSupply":
                        case "DropClaimExceedMaxSupply":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughSupply);
                            break;
                        case "cant claim yet":
                        case "DropClaimNotStarted":
                            reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].ClaimPhaseNotStarted);
                            break;
                        default:
                            {
                                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                                break;
                            }
                    }
                    return reasons;
                }
            }
        }
        if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {
            let claimedSupply = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
            let maxClaimable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"])(claimCondition.maxClaimablePerWallet, decimals);
            try {
                claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);
            } catch (e) {
            // no-op
            }
            if (allowListEntry) {
                maxClaimable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"])(allowListEntry.maxClaimable, decimals);
            }
            if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {
                reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].OverMaxClaimablePerWallet);
                return reasons;
            }
            // if there is no allowlist, or if there is an allowlist and the address is not in it
            // if maxClaimable is 0, we consider it as the address is not allowed
            if (!hasAllowList || hasAllowList && !allowListEntry) {
                if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AddressNotAllowed);
                    return reasons;
                }
            }
        }
        // check for claim timestamp between claims (ONLY FOR LEGACY)
        if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            let [lastClaimedTimestamp, timestampForNextClaim] = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0),
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0)
            ];
            if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
                activeConditionIndex = await this.contractWrapper.read("getActiveClaimConditionId", []);
                [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [
                    activeConditionIndex,
                    resolvedAddress
                ]);
            } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
                // check for claim timestamp between claims
                [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read("getClaimTimestamp", [
                    resolvedAddress
                ]);
            }
            const now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Date.now()).div(1000);
            if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {
                // contract will return MaxUint256 if user has already claimed and cannot claim again
                if (timestampForNextClaim.eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].MaxUint256)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].AlreadyClaimed);
                } else {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].WaitBeforeNextClaimTransaction);
                }
                return reasons;
            }
        }
        // if not within a browser context, check for wallet balance.
        // In browser context, let the wallet do that job
        if (claimCondition.price.gt(0) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d8"])()) {
            const totalPrice = claimCondition.price.mul(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(quantity));
            const provider = this.contractWrapper.getProvider();
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(claimCondition.currencyAddress)) {
                const balance = await provider.getBalance(resolvedAddress);
                if (balance.lt(totalPrice)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughTokens);
                }
            } else {
                const ERC20Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json (json, async loader)")(__turbopack_context__.i)).default;
                const erc20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);
                const balance = await erc20.read("balanceOf", [
                    resolvedAddress
                ]);
                if (balance.lt(totalPrice)) {
                    reasons.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].NotEnoughTokens);
                }
            }
        }
        return reasons;
    }
    /**
   * Returns allow list information and merkle proofs for the given address.
   * @param claimerAddress - the claimer address
   * @param claimConditionId - optional the claim condition id to get the proofs for
   */ async getClaimerProofs(claimerAddress, claimConditionId) {
        const claimCondition = await this.get(claimConditionId);
        const merkleRoot = claimCondition.merkleRoot;
        const merkleRootArray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].stripZeros(merkleRoot);
        if (merkleRootArray.length > 0) {
            const [metadata, resolvedAddress] = await Promise.all([
                this.metadata.get(),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(claimerAddress)
            ]);
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());
        } else {
            return null;
        }
    }
    /**
   * Get the total supply claimed by a specific wallet
   * @param walletAddress - the wallet address to check
   * @returns The total supply claimed
   */ async getSupplyClaimedByWallet(walletAddress) {
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress);
        if (this.isNewSinglePhaseDrop(this.contractWrapper)) {
            return await this.contractWrapper.read("getSupplyClaimedByWallet", [
                resolvedAddress
            ]);
        }
        if (this.isNewMultiphaseDrop(this.contractWrapper)) {
            const activeClaimConditionId = await this.contractWrapper.read("getActiveClaimConditionId", []);
            return await this.contractWrapper.read("getSupplyClaimedByWallet", [
                activeClaimConditionId,
                resolvedAddress
            ]);
        }
        throw new Error("This contract does not support the getSupplyClaimedByWallet function");
    }
    /** ***************************************
   * WRITE FUNCTIONS
   *****************************************/ /**
   * Set public mint conditions
   *
   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.
   *
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   *
   * // Optionally specify addresses that can claim
   * const snapshots = ['0x...', '0x...']
   *
   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim
   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]
   *
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: snapshots, // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   *
   * await dropContract.claimConditions.set(claimConditions);
   * ```
   *
   * @param claimConditionInputs - The claim conditions
   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])((()=>{
        var _this = this;
        return async function(claimConditionInputs) {
            let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            let claimConditionsProcessed = claimConditionInputs;
            if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {
                resetClaimEligibilityForAll = true;
                if (claimConditionInputs.length === 0) {
                    claimConditionsProcessed = [
                        {
                            startTime: new Date(0),
                            currencyAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero,
                            price: 0,
                            maxClaimableSupply: 0,
                            maxClaimablePerWallet: 0,
                            waitInSeconds: 0,
                            merkleRootHash: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].hexZeroPad([
                                0
                            ], 32),
                            snapshot: []
                        }
                    ];
                } else if (claimConditionInputs.length > 1) {
                    throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed");
                }
            }
            // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well
            if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {
                claimConditionsProcessed.forEach((cc)=>{
                    if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === "unlimited")) {
                        throw new Error("maxClaimablePerWallet must be set to a specific value when an allowlist is set.\n" + "Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\n" + "contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])");
                    }
                    if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === "0" && cc.snapshot.map((s)=>{
                        if (typeof s === "string") {
                            return 0;
                        } else {
                            return Number(s.maxClaimable?.toString() || 0);
                        }
                    }).reduce((acc, current)=>{
                        return acc + current;
                    }, 0) === 0) {
                        throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.");
                    }
                });
            }
            // process inputs
            const { snapshotInfos, sortedConditions } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["H"])(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());
            const merkleInfo = {};
            snapshotInfos.forEach((s)=>{
                merkleInfo[s.merkleRoot] = s.snapshotUri;
            });
            const metadata = await _this.metadata.get();
            const encoded = [];
            // upload new merkle roots to snapshot URIs if updated
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(metadata.merkle, merkleInfo)) {
                const mergedMetadata = await _this.metadata.parseInputMetadata({
                    ...metadata,
                    merkle: merkleInfo
                });
                // using internal method to just upload, avoids one contract call
                const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);
                // TODO (cc) we could write the merkle tree info on the claim condition metadata instead
                // TODO (cc) but we still need to maintain the behavior here for older contracts
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("setContractURI", _this.contractWrapper)) {
                    const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](_this.contractWrapper);
                    encoded.push(contractEncoder.encode("setContractURI", [
                        contractURI
                    ]));
                } else {
                    throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.");
                }
            }
            const cw = _this.contractWrapper;
            const baseContractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](cw);
            if (_this.isLegacySinglePhaseDrop(cw)) {
                const contractEncoderLegacy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](cw);
                encoded.push(contractEncoderLegacy.encode("setClaimConditions", [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"])(sortedConditions[0]),
                    resetClaimEligibilityForAll
                ]));
            } else if (_this.isLegacyMultiPhaseDrop(cw)) {
                encoded.push(baseContractEncoder.encode("setClaimConditions", [
                    sortedConditions.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"]),
                    resetClaimEligibilityForAll
                ]));
            } else if (_this.isNewSinglePhaseDrop(cw)) {
                encoded.push(baseContractEncoder.encode("setClaimConditions", [
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["J"])(sortedConditions[0]),
                    resetClaimEligibilityForAll
                ]));
            } else if (_this.isNewMultiphaseDrop(cw)) {
                encoded.push(baseContractEncoder.encode("setClaimConditions", [
                    sortedConditions.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["J"]),
                    resetClaimEligibilityForAll
                ]));
            } else {
                throw new Error("Contract does not support claim conditions");
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("multicall", _this.contractWrapper)) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                    contractWrapper: _this.contractWrapper,
                    method: "multicall",
                    args: [
                        encoded
                    ]
                });
            }
            throw new Error("Contract does not support multicall");
        };
    })());
    /**
   * Update a single claim condition with new data.
   *
   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`
   * @param claimConditionInput - the new data to update, previous data will be retained
   */ update = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (index, claimConditionInput)=>{
        const existingConditions = await this.getAll();
        const newConditionInputs = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["K"])(index, claimConditionInput, existingConditions);
        return await this.set.prepare(newConditionInputs);
    });
    /** ***************************************
   * PRIVATE FUNCTIONS
   *****************************************/ async getTokenDecimals() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20")) {
            return this.contractWrapper.read("decimals", []);
        } else {
            return Promise.resolve(0);
        }
    }
    /**
   * Returns proofs and the overrides required for the transaction.
   *
   * @returns  `overrides` and `proofs` as an object.
   * @internal
   */ async prepareClaim(quantity, checkERC20Allowance) {
        let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let address = arguments.length > 3 ? arguments[3] : undefined;
        const [addressToClaim, activeClaimConditions] = await Promise.all([
            address ? address : this.contractWrapper.getSignerAddress(),
            this.getActive()
        ]);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"])(addressToClaim, quantity, activeClaimConditions, async ()=>(await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());
    }
    async getClaimArguments(destinationAddress, quantity, claimVerification) {
        const resolvedAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(destinationAddress);
        if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {
            return [
                resolvedAddress,
                quantity,
                claimVerification.currencyAddress,
                claimVerification.price,
                claimVerification.proofs,
                claimVerification.maxClaimable
            ];
        } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {
            return [
                resolvedAddress,
                quantity,
                claimVerification.currencyAddress,
                claimVerification.price,
                {
                    proof: claimVerification.proofs,
                    maxQuantityInAllowlist: claimVerification.maxClaimable
                },
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
            ];
        }
        return [
            resolvedAddress,
            quantity,
            claimVerification.currencyAddress,
            claimVerification.price,
            {
                proof: claimVerification.proofs,
                quantityLimitPerWallet: claimVerification.maxClaimable,
                pricePerToken: claimVerification.priceInProof,
                currency: claimVerification.currencyAddressInProof
            },
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
        ];
    }
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - The address to claim to
   * @param quantity - The quantity to claim
   * @param options - Options to override the claim transaction
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */ async getClaimTransaction(destinationAddress, quantity, options) {
        // TODO: Transaction Sequence Pattern
        if (options?.pricePerToken) {
            throw new Error("Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`");
        }
        const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "claim",
            args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),
            overrides: claimVerification.overrides
        });
    }
    isNewSinglePhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC721ClaimConditionsV2") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC20ClaimConditionsV2");
    }
    isNewMultiphaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC721ClaimPhasesV2") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC20ClaimPhasesV2");
    }
    isLegacySinglePhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC721ClaimConditionsV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC20ClaimConditionsV1");
    }
    isLegacyMultiPhaseDrop(contractWrapper) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC721ClaimPhasesV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(contractWrapper, "ERC20ClaimPhasesV1");
    }
    getSnapshotFormatVersion() {
        return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"].V1 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"].V2;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/erc-20-9a18a51c.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "E": (()=>Erc20),
    "a": (()=>Erc20SignatureMintable),
    "n": (()=>normalizeAmount)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$drop$2d$claim$2d$conditions$2d$e6f2abbf$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-e6f2abbf.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * @internal
 */ async function normalizeAmount(contractWrapper, amount) {
    const decimals = await contractWrapper.read("decimals", []);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].parse(amount), decimals);
}
/**
 * @internal
 */ class Erc20Burnable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cD"].name;
    constructor(erc20, contractWrapper){
        this.erc20 = erc20;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Burn Tokens
   *
   * @remarks Burn tokens held by the connected wallet
   *
   * @example
   * ```javascript
   * // The amount of this token you want to burn
   * const amount = 1.2;
   *
   * await contract.token.burn.tokens(amount);
   * ```
   */ tokens = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "burn",
            args: [
                await this.erc20.normalizeAmount(amount)
            ]
        });
    });
    /**
   * Burn Tokens
   *
   * @remarks Burn tokens held by the specified wallet
   *
   * @example
   * ```javascript
   * // Address of the wallet sending the tokens
   * const holderAddress = "{{wallet_address}}";
   *
   * // The amount of this token you want to burn
   * const amount = 1.2;
   *
   * await contract.token.burn.from(holderAddress, amount);
   * ```
   */ from = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (holder, amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "burnFrom",
            args: await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(holder),
                this.erc20.normalizeAmount(amount)
            ])
        });
    });
}
/**
 * Configure and claim ERC20 tokens
 * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.drop.claim.to("0x...", quantity);
 * ```
 */ class Erc20ClaimableWithConditions {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cE"].name;
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.token.drop.claim.conditions.set(claimConditions);
   * ```
   */ constructor(erc20, contractWrapper, storage){
        this.erc20 = erc20;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        const metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
        this.conditions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$drop$2d$claim$2d$conditions$2d$e6f2abbf$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"](this.contractWrapper, metadata, this.storage);
    }
    /**
   * Claim a certain amount of tokens to a specific Wallet
   *
   * @remarks Let the specified wallet claim Tokens.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 42.69; // how many tokens you want to claim
   *
   * const tx = await contract.token.drop.claim.to(address, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param amount - Quantity of the tokens you want to claim
   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
   * @param claimData - Optional, data to pass to the claim function
   * @returns  The transaction receipt
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, amount, options)=>{
        const quantity = await this.erc20.normalizeAmount(amount);
        return await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
    });
}
/**
 * Configure and claim ERC20 tokens
 * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.drop.claim.to("0x...", quantity);
 * ```
 */ class Erc20Droppable {
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.nft.drop.claim.conditions.set(claimConditions);
   * ```
   */ constructor(erc20, contractWrapper, storage){
        this.erc20 = erc20;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);
    }
}
/**
 * Mint Many ERC20 Tokens at once
 * @remarks Token batch minting functionality that handles unit parsing for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.token.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);
 * ```
 * @internal
 */ class Erc20BatchMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cF"].name;
    constructor(erc20, contractWrapper){
        this.erc20 = erc20;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Mint Tokens To Many Wallets
   *
   * @remarks Mint tokens to many wallets in one transaction.
   *
   * @example
   * ```javascript
   * // Data of the tokens you want to mint
   * const data = [
   *   {
   *     toAddress: "{{wallet_address}}", // Address to mint tokens to
   *     amount: 0.2, // How many tokens to mint to specified address
   *   },
   *  {
   *    toAddress: "0x...",
   *    amount: 1.4,
   *  }
   * ]
   *
   * await contract.token.mint.batch(data);
   * ```
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (args)=>{
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const _items = await Promise.all(args.map((item)=>Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(item.toAddress),
                this.erc20.normalizeAmount(item.amount)
            ])));
        const encoded = _items.map((_ref)=>{
            let [address, amount] = _ref;
            return contractEncoder.encode("mintTo", [
                address,
                amount
            ]);
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ]
        });
    });
}
/**
 * Mint ERC20 Tokens
 * @remarks Token minting functionality that handles unit parsing for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.nft.mint.to(walletAddress, nftMetadata);
 * ```
 * @public
 */ class Erc20Mintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cG"].name;
    /**
   * Batch mint Tokens to many addresses
   */ constructor(erc20, contractWrapper){
        this.erc20 = erc20;
        this.contractWrapper = contractWrapper;
        this.batch = this.detectErc20BatchMintable();
    }
    /**
   * Mint Tokens
   *
   * @remarks Mint tokens to a specified address.
   *
   * @example
   * ```javascript
   * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
   * const amount = "1.5"; // The amount of this token you want to mint
   * await contract.token.mint.to(toAddress, amount);
   * ```
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, amount)=>{
        return await this.getMintTransaction(to, amount);
    });
    /**
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   */ async getMintTransaction(to, amount) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintTo",
            args: await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                this.erc20.normalizeAmount(amount)
            ])
        });
    }
    detectErc20BatchMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20BatchMintable")) {
            return new Erc20BatchMintable(this.erc20, this.contractWrapper);
        }
        return undefined;
    }
}
/**
 * Enables generating ERC20 Tokens with rules and an associated signature, which can then be minted by anyone securely
 * @erc20
 * @public
 */ // TODO consolidate into a single class
class Erc20SignatureMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cH"].name;
    constructor(contractWrapper, roles){
        this.contractWrapper = contractWrapper;
        this.roles = roles;
    }
    /**
   * Mint tokens from a signature
   *
   * @remarks Mint a certain amount of tokens from a previously generated signature.
   *
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `generate()` documentation
   * const signedPayload = contract.erc20.signature.generate(payload);
   *
   * // Use the signed payload to mint the tokens
   * const tx = contract.erc20.signature.mint(signedPayload);
   * ```
   * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}
   * @twfeature ERC20SignatureMintable
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayload)=>{
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        const [message, overrides] = await Promise.all([
            this.mapPayloadToContractStruct(mintRequest),
            this.contractWrapper.getCallOverrides()
        ]);
        // TODO: Transaction Sequence Pattern
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(message.price), mintRequest.currencyAddress, overrides);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintWithSignature",
            args: [
                message,
                signature
            ],
            overrides
        });
    });
    /**
   * Mint any number of generated tokens signatures at once
   * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
   * @param signedPayloads - the array of signed payloads to mint
   * @twfeature ERC20SignatureMintable
   */ mintBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayloads)=>{
        const messages = await Promise.all(signedPayloads.map((s)=>this.mapPayloadToContractStruct(s.payload)));
        const contractPayloads = signedPayloads.map((s, index)=>{
            const message = messages[index];
            const signature = s.signature;
            const price = s.payload.price;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(price).gt(0)) {
                throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
            }
            return {
                message,
                signature
            };
        });
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = contractPayloads.map((p)=>{
            return contractEncoder.encode("mintWithSignature", [
                p.message,
                p.signature
            ]);
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ]
        });
    });
    /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC20SignatureMintable
   *
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc20.signature.verify(signedPayload);
   * ```
   */ async verify(signedPayload) {
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        const message = await this.mapPayloadToContractStruct(mintRequest);
        const verification = await this.contractWrapper.read("verify", [
            message,
            signature
        ]);
        return verification[0];
    }
    /**
   * Generate a signature that can be used to mint a certain amount of tokens
   *
   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   quantity: 4.2, // The quantity of tokens to be minted
   *   to: {{wallet_address}}, // Who will receive the tokens
   *   price: 0.5, // the price to pay for minting those tokens
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now,
   *   primarySaleRecipient: "0x...", // custom sale recipient for this token mint
   * };
   *
   * const signedPayload = await contract.erc20.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns The signed payload and the corresponding signature
   * @twfeature ERC20SignatureMintable
   */ async generate(mintRequest) {
        return (await this.generateBatch([
            mintRequest
        ]))[0];
    }
    /**
   * Generate a batch of signatures that can be used to mint many token signatures.
   *
   * @remarks See {@link Erc20SignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns An array of payloads and signatures
   * @twfeature ERC20SignatureMintable
   */ async generateBatch(payloadsToSign) {
        await this.roles?.verify([
            "minter"
        ], await this.contractWrapper.getSignerAddress());
        const [chainId, name, parsedRequests] = await Promise.all([
            this.contractWrapper.getChainID(),
            this.contractWrapper.read("name", []),
            // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.
            Promise.all(payloadsToSign.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["S"].parseAsync(m)))
        ]);
        const signer = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(signer, "No signer available");
        const finalPayloads = await Promise.all(parsedRequests.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"].parseAsync(m)));
        const contractStructs = await Promise.all(finalPayloads.map((payload)=>this.mapPayloadToContractStruct(payload)));
        const signatures = await Promise.all(contractStructs.map((struct)=>this.contractWrapper.signTypedData(signer, {
                name,
                version: "1",
                chainId,
                verifyingContract: this.contractWrapper.address
            }, {
                MintRequest: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["M"]
            }, struct)));
        return parsedRequests.map((m, index)=>{
            const finalPayload = finalPayloads[index];
            const signature = signatures[index];
            return {
                payload: finalPayload,
                signature: signature.toString()
            };
        });
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns  The mapped payload.
   */ async mapPayloadToContractStruct(mintRequest) {
        const [normalizedPrice, decimals] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress),
            this.contractWrapper.read("decimals", [])
        ]);
        const amountWithDecimals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseUnits(mintRequest.quantity, decimals);
        return {
            to: mintRequest.to,
            primarySaleRecipient: mintRequest.primarySaleRecipient,
            quantity: amountWithDecimals,
            price: normalizedPrice,
            currency: mintRequest.currencyAddress,
            validityEndTimestamp: mintRequest.mintEndTime,
            validityStartTimestamp: mintRequest.mintStartTime,
            uid: mintRequest.uid
        };
    }
}
/**
 * Standard ERC20 Token functions
 * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc20.transfer(walletAddress, amount);
 * ```
 * @erc20
 * @public
 */ class Erc20 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cI"].name;
    /**
   * Mint tokens
   */ get chainId() {
        return this._chainId;
    }
    constructor(contractWrapper, storage, chainId){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.mintable = this.detectErc20Mintable();
        this.burnable = this.detectErc20Burnable();
        this.droppable = this.detectErc20Droppable();
        this.signatureMintable = this.detectErc20SignatureMintable();
        this._chainId = chainId;
    }
    /**
   * @internal
   */ onNetworkUpdated(network) {
        this.contractWrapper.updateSignerOrProvider(network);
    }
    /**
   * @internal
   */ getAddress() {
        return this.contractWrapper.address;
    }
    ////// Standard ERC20 Extension //////
    /**
   * Get the token metadata
   * @remarks name, symbol, etc...
   * @example
   * ```javascript
   * const token = await contract.erc20.get();
   * ```
   * @returns The token metadata
   * @twfeature ERC20
   */ async get() {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(this.contractWrapper.getProvider(), this.getAddress());
    }
    /**
   * Get token balance for the currently connected wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const balance = await contract.erc20.balance();
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */ async balance() {
        return await this.balanceOf(await this.contractWrapper.getSignerAddress());
    }
    /**
   * Get token balance for a specific wallet
   *
   * @remarks Get a wallets token balance.
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc20.balanceOf(walletAddress);
   * ```
   *
   * @returns The balance of a specific wallet.
   * @twfeature ERC20
   */ async balanceOf(address) {
        return this.getValue(await this.contractWrapper.read("balanceOf", [
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address)
        ]));
    }
    /**
   * Get the total supply for this token
   * @remarks Get how much supply has been minted
   * @example
   * ```javascript
   * const balance = await contract.erc20.totalSupply();
   * ```
   * @twfeature ERC20
   */ async totalSupply() {
        return await this.getValue(await this.contractWrapper.read("totalSupply", []));
    }
    /**
   * Get token allowance
   *
   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to check token allowance
   * const spenderAddress = "0x...";
   * const allowance = await contract.erc20.allowance(spenderAddress);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */ async allowance(spender) {
        const [owner, spenderAddress] = await Promise.all([
            this.contractWrapper.getSignerAddress(),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(spender)
        ]);
        return await this.allowanceOf(owner, spenderAddress);
    }
    /**
   * Get token allowance of a specific wallet
   *
   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet who owns the funds
   * const owner = "{{wallet_address}}";
   * // Address of the wallet to check token allowance
   * const spender = "0x...";
   * const allowance = await contract.erc20.allowanceOf(owner, spender);
   * ```
   *
   * @returns The allowance of one wallet over anothers funds.
   * @twfeature ERC20
   */ async allowanceOf(owner, spender) {
        const args = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(owner),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(spender)
        ]);
        return await this.getValue(await this.contractWrapper.read("allowance", args));
    }
    /**
   * Transfer tokens
   *
   * @remarks Transfer tokens from the connected wallet to another wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to send the tokens to
   * const toAddress = "0x...";
   * // The amount of tokens you want to send
   * const amount = 0.1;
   * await contract.erc20.transfer(toAddress, amount);
   * ```
   * @twfeature ERC20
   */ transfer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "transfer",
            args: await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                this.normalizeAmount(amount)
            ])
        });
    });
    /**
   * Transfer tokens from a specific address
   *
   * @remarks Transfer tokens from one wallet to another
   *
   * @example
   * ```javascript
   * // Address of the wallet sending the tokens
   * const fromAddress = "{{wallet_address}}";
   * // Address of the wallet you want to send the tokens to
   * const toAddress = "0x...";
   * // The number of tokens you want to send
   * const amount = 1.2
   * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress
   * await contract.erc20.transferFrom(fromAddress, toAddress, amount);
   * ```
   * @twfeature ERC20
   */ transferFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (from, to, amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "transferFrom",
            args: await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(from),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to),
                this.normalizeAmount(amount)
            ])
        });
    });
    /**
   * Set token allowance
   * @remarks Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet
   * @example
   * ```javascript
   * // Address of the wallet to allow transfers from
   * const spenderAddress = "0x...";
   * // The number of tokens to give as allowance
   * const amount = 100
   * await contract.erc20.setAllowance(spenderAddress, amount);
   * ```
   * @twfeature ERC20
   */ setAllowance = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (spender, amount)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approve",
            args: await Promise.all([
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(spender),
                this.normalizeAmount(amount)
            ])
        });
    });
    /**
   * Transfer tokens to many wallets
   *
   * @remarks Mint tokens from the connected wallet to many wallets
   *
   * @example
   * ```javascript
   * // Data of the tokens you want to mint
   * const data = [
   *   {
   *     toAddress: "{{wallet_address}}", // Address to mint tokens to
   *     amount: 100, // How many tokens to mint to specified address
   *   },
   *  {
   *    toAddress: "0x...",
   *    amount: 100,
   *  }
   * ]
   *
   * await contract.erc20.transferBatch(data);
   * ```
   */ transferBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (args)=>{
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = (await Promise.all(args.map((arg)=>Promise.all([
                this.normalizeAmount(arg.amount),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(arg.toAddress)
            ])))).map((_ref)=>{
            let [amountWithDecimals, address] = _ref;
            return contractEncoder.encode("transfer", [
                address,
                amountWithDecimals
            ]);
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ]
        });
    });
    ////// ERC20 Mintable Extension //////
    /**
   * Mint tokens
   *
   * @remarks Mint tokens to the connected wallet.
   *
   * @example
   * ```javascript
   * const amount = "1.5"; // The amount of this token you want to mint
   * await contract.erc20.mint(amount);
   * ```
   * @twfeature ERC20Mintable
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (amount)=>{
        return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);
    });
    /**
   * Mint tokens to a specific wallet
   *
   * @remarks Mint tokens to a specified address.
   *
   * @example
   * ```javascript
   * const toAddress = "{{wallet_address}}"; // Address of the wallet you want to mint the tokens to
   * const amount = "1.5"; // The amount of this token you want to mint
   * await contract.erc20.mintTo(toAddress, amount);
   * ```
   * @twfeature ERC20Mintable
   */ mintTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, amount)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cG"]).to.prepare(receiver, amount);
    });
    /**
   * Construct a mint transaction without executing it
   * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param amount - The amount of tokens you want to mint
   *
   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead
   * @twfeature ERC20Mintable
   */ async getMintTransaction(receiver, amount) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cG"]).getMintTransaction(receiver, amount);
    }
    ////// ERC20 BatchMintable Extension //////
    /**
   * Mint tokens to many wallets
   *
   * @remarks Mint tokens to many wallets in one transaction.
   *
   * @example
   * ```javascript
   * // Data of the tokens you want to mint
   * const data = [
   *   {
   *     toAddress: "{{wallet_address}}", // Address to mint tokens to
   *     amount: 0.2, // How many tokens to mint to specified address
   *   },
   *  {
   *    toAddress: "0x...",
   *    amount: 1.4,
   *  }
   * ]
   *
   * await contract.mintBatchTo(data);
   * ```
   * @twfeature ERC20BatchMintable
   */ mintBatchTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (args)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable?.batch, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cF"]).to.prepare(args);
    });
    ////// ERC20 Burnable Extension //////
    /**
   * Burn tokens
   *
   * @remarks Burn tokens held by the connected wallet
   *
   * @example
   * ```javascript
   * // The amount of this token you want to burn
   * const amount = 1.2;
   *
   * await contract.erc20.burn(amount);
   * ```
   * @twfeature ERC20Burnable
   */ burn = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (amount)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cD"]).tokens.prepare(amount);
    });
    /**
   * Burn tokens from a specific wallet
   *
   * @remarks Burn tokens held by the specified wallet
   *
   * @example
   * ```javascript
   * // Address of the wallet sending the tokens
   * const holderAddress = "{{wallet_address}}";
   *
   * // The amount of this token you want to burn
   * const amount = 1.2;
   *
   * await contract.erc20.burnFrom(holderAddress, amount);
   * ```
   * @twfeature ERC20Burnable
   */ burnFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (holder, amount)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cD"]).from.prepare(holder, amount);
    });
    ////// ERC20 Claimable Extension //////
    /**
   * Claim tokens
   *
   * @remarks Let the specified wallet claim Tokens.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 42.69; // how many tokens you want to claim
   *
   * const tx = await contract.erc20.claim(address, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param amount - Quantity of the tokens you want to claim
   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
   * @param claimData - Optional, claim data
   * @returns  The transaction receipt
   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
   */ claim = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (amount, options)=>{
        return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options);
    });
    /**
   * Claim tokens to a specific wallet
   *
   * @remarks Let the specified wallet claim Tokens.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 42.69; // how many tokens you want to claim
   *
   * const tx = await contract.erc20.claim(address, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param amount - Quantity of the tokens you want to claim
   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer
   * @param claimData - Optional, claim data
   * @returns  The transaction receipt
   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
   */ claimTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, amount, options)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.droppable?.claim, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cE"]).to.prepare(destinationAddress, amount, options);
    });
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc20.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1
   */ get claimConditions() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.droppable?.claim, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cE"]).conditions;
    }
    ////// ERC20 SignatureMint Extension //////
    /**
   * Mint with signature
   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation
   * const signedPayload = contract.erc20.signature().generate(payload);
   *
   * // now the payload can be used to mint tokens
   * const tx = contract.erc20.signature.mint(signedPayload);
   * ```
   * @twfeature ERC20SignatureMintable
   */ get signature() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.signatureMintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cH"]);
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * returns the wei amount from a token amount
   * @internal
   * @param amount - The token amount
   */ async normalizeAmount(amount) {
        return normalizeAmount(this.contractWrapper, amount);
    }
    /**
   * @internal
   */ async getValue(value) {
        return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), this.getAddress(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(value));
    }
    detectErc20Mintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20")) {
            return new Erc20Mintable(this, this.contractWrapper);
        }
        return undefined;
    }
    detectErc20Burnable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20Burnable")) {
            return new Erc20Burnable(this, this.contractWrapper);
        }
        return undefined;
    }
    detectErc20Droppable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20ClaimConditionsV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20ClaimConditionsV2") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20ClaimPhasesV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20ClaimPhasesV2")) {
            return new Erc20Droppable(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc20SignatureMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20SignatureMintable")) {
            return new Erc20SignatureMintable(this.contractWrapper);
        }
        return undefined;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/erc-721-27306550.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "E": (()=>Erc721),
    "a": (()=>Erc721WithQuantitySignatureMintable),
    "t": (()=>toWei)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-client] (ecmascript) <export * as constants>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$drop$2d$claim$2d$conditions$2d$e6f2abbf$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/drop-claim-conditions-e6f2abbf.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$storage$2f$dist$2f$thirdweb$2d$dev$2d$storage$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/signature-d3ea643d.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class Erc721Burnable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cL"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Burn NFTs
   *
   * @remarks Burn NFTs held by the connected wallet
   *
   * @example
   * ```javascript
   * // The token ID of the NFT you want to burn
   * const tokenId = 0;
   *
   * await contract.nft.burn.token(tokenId);
   * ```
   */ token = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "burn",
            args: [
                tokenId
            ]
        });
    });
}
/**
 * Configure and claim ERC721 NFTs
 * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc721.claim(quantity);
 * await contract.erc721.claimConditions.getActive();
 * ```
 */ class Erc721ClaimableWithConditions {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cM"].name;
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   */ constructor(erc721, contractWrapper, storage){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        const metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
        this.conditions = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$drop$2d$claim$2d$conditions$2d$e6f2abbf$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"](this.contractWrapper, metadata, this.storage);
    }
    /**
   * Claim unique NFTs to a specific Wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 1; // how many unique NFTs you want to claim
   *
   * const tx = await contract.erc721.claimTo(address, quantity);
   * const receipt = tx[0].receipt; // the transaction receipt
   * const claimedTokenId = tx[0].id; // the id of the first NFT claimed
   * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - (optional) Options to configure the claim
   * @returns  an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, quantity, options)=>{
        // TODO: Transaction Sequence Pattern
        const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);
        tx.setParse((receipt)=>{
            const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
            const startingIndex = event[0].args.startTokenId;
            const endingIndex = startingIndex.add(quantity);
            const results = [];
            for(let id = startingIndex; id.lt(endingIndex); id = id.add(1)){
                results.push({
                    id,
                    receipt,
                    data: ()=>this.erc721.get(id)
                });
            }
            return results;
        });
        return tx;
    });
}
function toWei(amount) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].parseEther(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"].parse(amount));
}
/**
 * Claim ERC721 NFTs from a Zora Drop
 * @remarks Purchase NFTs on a Zora Drop
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc721.claim(tokenId, quantity);
 * ```
 */ class Erc721ClaimableZora {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cN"].name;
    constructor(erc721, contractWrapper){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Claim NFT
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc721.claimTo(address, quantity);
   * const receipt = tx[0].receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to, needs to be the connected wallet address
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Not applicable
   *
   * @returns  Receipt for the transaction
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, quantity, options)=>{
        // TODO validation on destinationAddr / options
        const signerAddress = await this.contractWrapper.getSigner()?.getAddress();
        if (destinationAddress !== signerAddress) {
            throw new Error("Zora Drop: Destination address must match connected wallet address");
        }
        if (options?.pricePerToken) {
            throw new Error("Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated");
        }
        const saleDetails = await this.getSaleDetails();
        const price = saleDetails.publicSalePrice;
        const zoraFee = toWei("0.000777");
        const totalPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(price).add(zoraFee).mul(quantity);
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "purchase",
            args: [
                quantity
            ],
            overrides: {
                value: totalPrice
            }
        });
        tx.setParse((receipt)=>{
            const event = this.contractWrapper.parseLogs("Sale", receipt?.logs);
            const startingIndex = event[0].args.firstPurchasedTokenId;
            const endingIndex = startingIndex.add(quantity);
            const results = [];
            for(let id = startingIndex; id.lt(endingIndex); id = id.add(1)){
                results.push({
                    id,
                    receipt,
                    data: ()=>this.erc721.get(id)
                });
            }
            return results;
        });
        return tx;
    });
    async getSaleDetails() {
        return this.contractWrapper.read("saleDetails", []);
    }
}
/**
 * Configure and claim ERC721 NFTs
 * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc721.claim(tokenId, quantity);
 * ```
 */ class Erc721Claimable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cO"].name;
    constructor(erc721, contractWrapper){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param tokenId - Id of the token you want to claim
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   */ async getClaimTransaction(destinationAddress, quantity, options) {
        // TODO: Transaction Sequence Pattern
        let overrides = {};
        if (options && options.pricePerToken) {
            overrides = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "claim",
            args: [
                destinationAddress,
                quantity
            ],
            overrides
        });
    }
    /**
   * Claim NFTs to a specific Wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 1; // how many NFTs you want to claim
   *
   * const tx = await contract.erc721.claimTo(address, quantity);
   * const receipt = tx[0].receipt; // the transaction receipt
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - Options for claiming the NFTs
   *
   * @returns  Receipt for the transaction
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, quantity, options)=>{
        // TODO: Transaction Sequence Pattern
        const tx = await this.getClaimTransaction(destinationAddress, quantity, options);
        tx.setParse((receipt)=>{
            const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
            const startingIndex = event[0].args.startTokenId;
            const endingIndex = startingIndex.add(quantity);
            const results = [];
            for(let id = startingIndex; id.lt(endingIndex); id = id.add(1)){
                results.push({
                    id,
                    receipt,
                    data: ()=>this.erc721.get(id)
                });
            }
            return results;
        });
        return tx;
    });
}
/**
 * Lazily mint and claim ERC721 NFTs
 * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.drop.claim(quantity);
 * ```
 */ class Erc721LazyMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cP"].name;
    /**
   * Delayed reveal
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.nft.drop.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   */ constructor(erc721, contractWrapper, storage){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.revealer = this.detectErc721Revealable();
    }
    /**
   * Create a batch of unique NFTs to be claimed in the future
   *
   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.
   *
   * @example
   * ```javascript
   * // Custom metadata of the NFTs to create
   * const metadatas = [{
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   *
   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain
   * const firstTokenId = results[0].id; // token id of the first created NFT
   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
   * ```
   *
   * @param metadatas - The metadata to include in the batch.
   * @param options - optional upload progress callback
   */ lazyMint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas, options)=>{
        const startFileNumber = await this.erc721.nextTokenIdToMint();
        const batch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage, startFileNumber.toNumber(), options);
        // ensure baseUri is the same for the entire batch
        const baseUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(batch);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "lazyMint",
            args: [
                batch.length,
                baseUri.endsWith("/") ? baseUri : `${baseUri}/`,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
                const startingIndex = event[0].args.startTokenId;
                const endingIndex = event[0].args.endTokenId;
                const results = [];
                for(let id = startingIndex; id.lte(endingIndex); id = id.add(1)){
                    results.push({
                        id,
                        receipt,
                        data: ()=>this.erc721.getTokenMetadata(id)
                    });
                }
                return results;
            }
        });
    });
    updateMetadata = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, metadata, options)=>{
        const batchCount = await this.contractWrapper.read("getBaseURICount", []);
        if (batchCount.eq(0)) {
            throw new Error("No base URI set. Please set a base URI before updating metadata");
        }
        const targetTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(tokenId);
        let startTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        let endTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        let batchIndex = 0;
        for(let i = 0; i < batchCount.toNumber(); i++){
            batchIndex = i;
            endTokenId = await this.contractWrapper.read("getBatchIdAtIndex", [
                batchIndex
            ]);
            if (endTokenId.gt(targetTokenId)) {
                break;
            }
            startTokenId = endTokenId;
        }
        // for the entire batch,
        // 1. download all of the metadata as a list of nft metadata
        const range = Array.from({
            length: endTokenId.sub(startTokenId).toNumber()
        }, (v, k)=>k + startTokenId.toNumber());
        const metadatas = await Promise.all(range.map((id)=>this.erc721.getTokenMetadata(id)));
        // 2. replace the metadata of the tokenId desired
        const newMetadatas = [];
        for(let i = 0; i < metadatas.length; i++){
            const { id, uri, ...rest } = metadatas[i];
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(targetTokenId).eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(id))) {
                newMetadatas.push(metadata);
            } else {
                newMetadatas.push(rest);
            }
        }
        // 3. re-upload the entire batch with the correct starting number
        const batch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(newMetadatas, this.storage, startTokenId.toNumber(), options);
        const baseUri = batch[0].substring(0, batch[0].lastIndexOf("/"));
        // 4. update the base uri for the entire batch
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            // TODO contract detection
            method: "updateBatchBaseURI",
            args: [
                batchIndex,
                `${baseUri.endsWith("/") ? baseUri : `${baseUri}/`}`
            ]
        });
    });
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ detectErc721Revealable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721Revealable")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"](this.contractWrapper, this.storage, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cQ"].name, ()=>this.erc721.nextTokenIdToMint());
        }
        return undefined;
    }
}
class Erc721LoyaltyCard {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cR"].name;
    constructor(contractWrapper){
        this.contractWrapper = contractWrapper;
    }
    /**
   * Cancel loyalty card NFTs
   *
   * @remarks Cancel loyalty card NFTs held by the connected wallet
   *
   * @example
   * ```javascript
   * // The token ID of the loyalty card you want to cancel
   * const tokenId = 0;
   *
   * await contract.nft.loyaltyCard.cancel(tokenId);
   * ```
   */ cancel = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "cancel",
            args: [
                tokenId
            ]
        });
    });
    /**
   * Revoke loyalty card NFTs
   *
   * @remarks Revoke loyalty card NFTs held by some owner.
   *
   * @example
   * ```javascript
   * // The token ID of the loyalty card you want to revoke
   * const tokenId = 0;
   *
   * await contract.nft.loyaltyCard.revoke(tokenId);
   * ```
   */ revoke = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "revoke",
            args: [
                tokenId
            ]
        });
    });
}
class Erc721UpdatableMetadata {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cS"].name;
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Update the metadata of an NFT
   *
   * @remarks Update the metadata of an NFT
   *
   * @example
   * ```javascript
   * // The token ID of the NFT whose metadata you want to update
   * const tokenId = 0;
   * // The new metadata
   * const metadata = { name: "My NFT", description: "My NFT description" }
   *
   * await contract.nft.metadata.update(tokenId, metadata);
   * ```
   */ update = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, metadata)=>{
        const uri = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(metadata, this.storage);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setTokenURI",
            args: [
                tokenId,
                uri
            ]
        });
    });
}
/**
 * Mint Many ERC721 NFTs at once
 * @remarks NFT batch minting functionality that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.nft.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);
 * ```
 * @public
 */ class Erc721BatchMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cT"].name;
    constructor(erc721, contractWrapper, storage){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Mint Many unique NFTs
   *
   * @remarks Mint many unique NFTs at once to a specified wallet.
   *
   * @example
   * ```typescript
   * // Address of the wallet you want to mint the NFT to
   * const walletAddress = "{{wallet_address}}";
   *
   * // Custom metadata of the NFTs you want to mint.
   * const metadatas = [{
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT #2",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/other/image.png"),
   * }];
   *
   * const tx = await contract.mint.batch.to(walletAddress, metadatas);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, metadatas)=>{
        const [uris, resolvedAddress] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to)
        ]);
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = uris.map((uri)=>contractEncoder.encode("mintTo", [
                resolvedAddress,
                uri
            ]));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                encoded
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("TokensMinted", receipt.logs);
                if (events.length === 0 || events.length < metadatas.length) {
                    throw new Error("TokenMinted event not found, minting failed");
                }
                return events.map((e)=>{
                    const id = e.args.tokenIdMinted;
                    return {
                        id,
                        receipt,
                        data: ()=>this.erc721.get(id)
                    };
                });
            }
        });
    });
}
/**
 * Mint ERC721 NFTs
 * @remarks NFT minting functionality that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.nft.mint.to(walletAddress, nftMetadata);
 * ```
 * @public
 */ class Erc721Mintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cU"].name;
    constructor(erc721, contractWrapper, storage){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.batch = this.detectErc721BatchMintable();
    }
    /**
   * Mint a unique NFT
   *
   * @remarks Mint a unique NFT to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const walletAddress = "{{wallet_address}}";
   *
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const tx = await contract.nft.mint.to(walletAddress, metadata);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   */ to = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, metadata)=>{
        const [uri, toAddress] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(metadata, this.storage),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to)
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "mintTo",
            args: [
                toAddress,
                uri
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("Transfer", receipt?.logs);
                if (event.length === 0) {
                    throw new Error("TransferEvent event not found");
                }
                const id = event[0].args.tokenId;
                return {
                    id,
                    receipt,
                    data: ()=>this.erc721.get(id)
                };
            }
        });
    });
    /**
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   */ async getMintTransaction(to, metadata) {
        return this.to.prepare(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to), metadata);
    }
    detectErc721BatchMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721BatchMintable")) {
            return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);
        }
        return undefined;
    }
}
/**
 * Set shared metadata for ERC721 NFTs (Open Edition)
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc721.sharedMetadata.set(metadata);
 * ```
 */ class Erc721SharedMetadata {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cV"].name;
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Get Shared Metadata
   *
   * @remarks Get the shared metadata for the Open Edition NFTs.
   *
   * @example
   * ```javascript
   * const contract = await sdk.getContract("{{contract_address}}");
   *
   * const tx = await contract.erc721.sharedMetadata.get();
   * ```
   *
   * @returns  The shared metadata for the Open Edition NFTs.
   */ async get() {
        const metadata = await this.contractWrapper.read("sharedMetadata", []);
        if (metadata.every((value)=>value === "")) {
            return undefined;
        }
        return {
            name: metadata.name,
            description: metadata.description,
            image: metadata.imageURI,
            animation_url: metadata.animationURI
        };
    }
    /**
   * Set Shared Metadata
   *
   * @remarks Set the shared metadata for the Open Edition NFTs.
   *
   * @example
   * ```javascript
   * const metadata = {
   *  name: "My NFT",
   *  description: "This is my NFT",
   *  image: ...
   *  animation_url: ...
   * };
   *
   * const contract = await sdk.getContract("{{contract_address}}");
   *
   * const tx = await contract.erc721.sharedMetadata.set(metadata);
   * ```
   *
   * @param metadata - The metadata you want to set for the shared metadata.
   *
   * @returns  Receipt for the transaction
   */ set = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadata)=>{
        const parsedMetadata = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"].parse(metadata);
        // cleanup description
        parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);
        // take the input and upload image and animation if it is not a URI already
        const batch = [];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$storage$2f$dist$2f$thirdweb$2d$dev$2d$storage$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFileOrBuffer"])(parsedMetadata.image)) {
            batch.push(this.storage.upload(parsedMetadata.image));
        } else if (typeof parsedMetadata.image === "string") {
            batch.push(Promise.resolve(parsedMetadata.image));
        } else {
            batch.push(Promise.resolve(undefined));
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$storage$2f$dist$2f$thirdweb$2d$dev$2d$storage$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isFileOrBuffer"])(parsedMetadata.animation_url)) {
            batch.push(this.storage.upload(parsedMetadata.animation_url));
        } else if (typeof parsedMetadata.animation_url === "string") {
            batch.push(Promise.resolve(parsedMetadata.animation_url));
        } else {
            batch.push(Promise.resolve(undefined));
        }
        const [imageUri, animationUri] = await Promise.all(batch);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setSharedMetadata",
            args: [
                {
                    name: `${parsedMetadata.name || ""}`,
                    description: parsedMetadata.description || "",
                    imageURI: imageUri || "",
                    animationURI: animationUri || ""
                }
            ]
        });
    });
    sanitizeJSONString(val) {
        if (!val) {
            return val;
        }
        const sanitized = JSON.stringify(val);
        return sanitized.slice(1, sanitized.length - 1);
    }
}
/**
 * List owned ERC721 NFTs
 * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const walletAddress = "0x...";
 * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);
 * ```
 * @public
 */ class Erc721Enumerable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cW"].name;
    constructor(erc721, contractWrapper){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.nft.query.owned.all(address);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs in the contract.
   */ async all(walletAddress, queryParams) {
        let tokenIds = await this.tokenIds(walletAddress);
        if (queryParams) {
            const start = queryParams?.start || 0;
            const count = queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
            tokenIds = tokenIds.slice(start, start + count);
        }
        return await Promise.all(tokenIds.map((tokenId)=>this.erc721.get(tokenId.toString())));
    }
    /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */ async tokenIds(walletAddress) {
        const address = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress || await this.contractWrapper.getSignerAddress());
        const balance = await this.contractWrapper.read("balanceOf", [
            address
        ]);
        const indices = Array.from(Array(balance.toNumber()).keys());
        return await Promise.all(indices.map((i)=>this.contractWrapper.read("tokenOfOwnerByIndex", [
                address,
                i
            ])));
    }
}
/**
 * List owned ERC721 NFTs
 * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const walletAddress = "0x...";
 * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);
 * ```
 * @public
 */ class Erc721AQueryable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cX"].name;
    constructor(erc721, contractWrapper){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
    }
    /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.nft.query.owned.all(address);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @returns The NFT metadata for all NFTs in the contract.
   */ async all(walletAddress, queryParams) {
        let tokenIds = await this.tokenIds(walletAddress);
        if (queryParams) {
            const start = queryParams?.start || 0;
            const count = queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
            tokenIds = tokenIds.slice(start, start + count);
        }
        return await Promise.all(tokenIds.map((tokenId)=>this.erc721.get(tokenId.toString())));
    }
    /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */ async tokenIds(walletAddress) {
        const address = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress || await this.contractWrapper.getSignerAddress());
        return await this.contractWrapper.read("tokensOfOwner", [
            address
        ]);
    }
}
/**
 * List ERC721 NFTs
 * @remarks Easily list all the NFTs in a ERC721 contract.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * const nfts = await contract.nft.query.all();
 * ```
 * @public
 */ class Erc721Supply {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cY"].name;
    constructor(erc721, contractWrapper){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.owned = this.detectErc721Owned();
    }
    /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.nft.query.all();
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   */ async all(queryParams) {
        let startTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("startTokenId", this.contractWrapper)) {
            startTokenId = await this.contractWrapper.read("startTokenId", []);
        }
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(queryParams?.start || 0).add(startTokenId).toNumber();
        const count = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"]).toNumber();
        const maxSupply = await this.erc721.nextTokenIdToMint();
        const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);
        return await Promise.all([
            ...Array(maxId - start).keys()
        ].map((i)=>this.erc721.get((start + i).toString())));
    }
    /**
   * Return all the owners of each token id in this contract
   * @returns
   */ async allOwners(queryParams) {
        let totalCount;
        let startTokenId = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("startTokenId", this.contractWrapper)) {
            startTokenId = await this.contractWrapper.read("startTokenId", []);
        }
        try {
            totalCount = await this.erc721.totalClaimedSupply();
        } catch (e) {
            totalCount = await this.totalCount();
        }
        totalCount = totalCount.add(startTokenId);
        // TODO use multicall3 if available
        // TODO can't call toNumber() here, this can be a very large number
        let arr = [
            ...new Array(totalCount.toNumber()).keys()
        ];
        if (queryParams) {
            const start = queryParams?.start || 0;
            const count = queryParams?.count || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
            arr = arr.slice(start, start + count);
        }
        const owners = await Promise.all(arr.map((i)=>this.erc721.ownerOf(i).catch(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero)));
        return arr.map((i)=>({
                tokenId: i,
                owner: owners[i]
            })).filter((o)=>o.owner !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero);
    }
    /**
   * Get the number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   *
   * @returns The total number of NFTs minted in this contract
   * @public
   */ async totalCount() {
        return await this.erc721.nextTokenIdToMint();
    }
    /**
   * Get the number of NFTs of this contract currently owned by end users
   * @returns The total number of NFTs of this contract in circulation (minted & not burned)
   * @public
   */ async totalCirculatingSupply() {
        return await this.contractWrapper.read("totalSupply", []);
    }
    detectErc721Owned() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721Enumerable")) {
            return new Erc721Enumerable(this.erc721, this.contractWrapper);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721AQueryable")) {
            return new Erc721AQueryable(this.erc721, this.contractWrapper);
        }
        return undefined;
    }
}
/**
 * @internal
 */ const TieredDropPayloadSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["B"].extend({
        tierPriority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
        royaltyRecipient: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero),
        royaltyBps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cC"].default(0),
        quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b5"].default(1)
    }))();
/**
 * @public
 */ /**
 * @internal
 */ /**
 * @internal
 */ const GenericRequest = [
    {
        name: "validityStartTimestamp",
        type: "uint128"
    },
    {
        name: "validityEndTimestamp",
        type: "uint128"
    },
    {
        name: "uid",
        type: "bytes32"
    },
    {
        name: "data",
        type: "bytes"
    }
];
class Erc721TieredDrop {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cZ"].name;
    constructor(erc721, contractWrapper, storage){
        this.erc721 = erc721;
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    async getMetadataInTier(tier) {
        const tiers = await this.contractWrapper.read("getMetadataForAllTiers", []);
        const batches = tiers.find((t)=>t.tier === tier);
        if (!batches) {
            throw new Error("Tier not found in contract.");
        }
        const nfts = await Promise.all(batches.ranges.map((range, i)=>{
            const nftsInRange = [];
            const baseUri = batches.baseURIs[i];
            for(let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++){
                const uri = baseUri.endsWith("/") ? `${baseUri}${j}` : `${baseUri}/${j}`;
                const metadata = this.storage.downloadJSON(uri);
                nftsInRange.push(metadata);
            }
            return nftsInRange;
        }).flat());
        return nfts;
    }
    async getTokensInTier(tier) {
        const endIndex = await this.contractWrapper.read("getTokensInTierLen", []);
        if (endIndex.eq(0)) {
            return [];
        }
        const ranges = await this.contractWrapper.read("getTokensInTier", [
            tier,
            0,
            endIndex
        ]);
        const nfts = await Promise.all(ranges.map((range)=>{
            const nftsInRange = [];
            for(let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++){
                nftsInRange.push(this.erc721.get(i));
            }
            return nftsInRange;
        }).flat());
        return nfts;
    }
    createBatchWithTier = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas, tier, options)=>{
        // TODO: Change this to on extension
        const startFileNumber = await this.erc721.nextTokenIdToMint();
        const batch = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage, startFileNumber.toNumber(), options);
        const baseUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(batch);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "lazyMint",
            args: [
                batch.length,
                baseUri.endsWith("/") ? baseUri : `${baseUri}/`,
                tier,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes("")
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
                const startingIndex = event[0].args[1];
                const endingIndex = event[0].args[2];
                const results = [];
                for(let id = startingIndex; id.lte(endingIndex); id = id.add(1)){
                    results.push({
                        id,
                        receipt,
                        data: ()=>this.erc721.getTokenMetadata(id)
                    });
                }
                return results;
            }
        });
    });
    createDelayedRevealBatchWithTier = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (placeholder, metadatas, password, tier, options)=>{
        if (!password) {
            throw new Error("Password is required");
        }
        const placeholderUris = await this.storage.uploadBatch([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(placeholder)
        ], {
            rewriteFileNames: {
                fileStartNumber: 0
            }
        });
        const placeholderUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(placeholderUris);
        const startFileNumber = await this.erc721.nextTokenIdToMint();
        const uris = await this.storage.uploadBatch(metadatas.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"].parse(m)), {
            onProgress: options?.onProgress,
            rewriteFileNames: {
                fileStartNumber: startFileNumber.toNumber()
            }
        });
        const baseUri = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(uris);
        const baseUriId = await this.contractWrapper.read("getBaseURICount", []);
        const chainId = await this.contractWrapper.getChainID();
        const hashedPassword = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
            "string",
            "uint256",
            "uint256",
            "address"
        ], [
            password,
            chainId,
            baseUriId,
            this.contractWrapper.address
        ]);
        const encryptedBaseUri = await this.contractWrapper.read("encryptDecrypt", [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes(baseUri),
            hashedPassword
        ]);
        const provenanceHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
            "bytes",
            "bytes",
            "uint256"
        ], [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].toUtf8Bytes(baseUri),
            hashedPassword,
            chainId
        ]);
        const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].defaultAbiCoder.encode([
            "bytes",
            "bytes32"
        ], [
            encryptedBaseUri,
            provenanceHash
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "lazyMint",
            args: [
                uris.length,
                placeholderUri.endsWith("/") ? placeholderUri : `${placeholderUri}/`,
                tier,
                data
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("TokensLazyMinted", receipt?.logs);
                const startingIndex = event[0].args[1];
                const endingIndex = event[0].args[2];
                const results = [];
                for(let id = startingIndex; id.lte(endingIndex); id = id.add(1)){
                    results.push({
                        id,
                        receipt,
                        data: ()=>this.erc721.getTokenMetadata(id)
                    });
                }
                return results;
            }
        });
    });
    reveal = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (batchId, password)=>{
        if (!password) {
            throw new Error("Password is required");
        }
        const chainId = await this.contractWrapper.getChainID();
        const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].solidityKeccak256([
            "string",
            "uint256",
            "uint256",
            "address"
        ], [
            password,
            chainId,
            batchId,
            this.contractWrapper.address
        ]);
        // performing the reveal locally to make sure it'd succeed before sending the transaction
        try {
            const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);
            // basic sanity check for making sure decryptedUri is valid
            // this is optional because invalid decryption key would result in non-utf8 bytes and
            // ethers would throw when trying to decode it
            if (!decryptedUri.includes("://") || !decryptedUri.endsWith("/")) {
                throw new Error("invalid password");
            }
        } catch (e) {
            throw new Error("invalid password");
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "reveal",
            args: [
                batchId,
                key
            ]
        });
    });
    async generate(payloadToSign) {
        const [payload] = await this.generateBatch([
            payloadToSign
        ]);
        return payload;
    }
    async generateBatch(payloadsToSign) {
        const parsedPayloads = await Promise.all(payloadsToSign.map((payload)=>TieredDropPayloadSchema.parseAsync(payload)));
        const chainId = await this.contractWrapper.getChainID();
        const signer = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(signer, "No signer available");
        return await Promise.all(parsedPayloads.map(async (payload)=>{
            const signature = await this.contractWrapper.signTypedData(signer, {
                name: "SignatureAction",
                version: "1",
                chainId,
                verifyingContract: this.contractWrapper.address
            }, {
                GenericRequest: GenericRequest
            }, await this.mapPayloadToContractStruct(payload));
            return {
                payload,
                signature: signature.toString()
            };
        }));
    }
    async verify(signedPayload) {
        const message = await this.mapPayloadToContractStruct(signedPayload.payload);
        const verification = await this.contractWrapper.read("verify", [
            message,
            signedPayload.signature
        ]);
        return verification[0];
    }
    async claimWithSignature(signedPayload) {
        const message = await this.mapPayloadToContractStruct(signedPayload.payload);
        const normalizedTotalPrice = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);
        const overrides = await this.contractWrapper.getCallOverrides();
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);
        const receipt = await this.contractWrapper.sendTransaction("claimWithSignature", [
            message,
            signedPayload.signature
        ], overrides);
        const event = this.contractWrapper.parseLogs("TokensClaimed", receipt?.logs);
        const startingIndex = event[0].args.startTokenId;
        const endingIndex = startingIndex.add(event[0].args.quantityClaimed);
        const results = [];
        for(let id = startingIndex; id.lt(endingIndex); id = id.add(1)){
            results.push({
                id,
                receipt,
                data: ()=>this.erc721.get(id)
            });
        }
        return results;
    }
    async mapPayloadToContractStruct(payload) {
        const normalizedTotalPrice = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);
        const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].defaultAbiCoder.encode([
            "string[]",
            "address",
            "address",
            "uint256",
            "address",
            "uint256",
            "uint256",
            "address"
        ], [
            payload.tierPriority,
            payload.to,
            payload.royaltyRecipient,
            payload.royaltyBps,
            payload.primarySaleRecipient,
            payload.quantity,
            normalizedTotalPrice,
            payload.currencyAddress
        ]);
        return {
            uid: payload.uid,
            validityStartTimestamp: payload.mintStartTime,
            validityEndTimestamp: payload.mintEndTime,
            data
        };
    }
}
/**
 * Enables generating dynamic ERC721 NFTs with rules and an associated signature, which can then be minted by anyone securely
 * @erc721
 * @public
 */ class Erc721WithQuantitySignatureMintable {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c_"].name;
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
    }
    /**
   * Mint a dynamically generated NFT
   *
   * @remarks Mint a dynamic NFT with a previously generated signature.
   *
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `generate()` documentation
   * const signedPayload = contract.erc721.signature.generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = contract.erc721.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}
   * @twfeature ERC721SignatureMint
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayload)=>{
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        const overrides = await this.contractWrapper.getCallOverrides();
        const parse = (receipt)=>{
            const t = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
            if (t.length === 0) {
                throw new Error("No MintWithSignature event found");
            }
            const id = t[0].args.tokenIdMinted;
            return {
                id,
                receipt
            };
        };
        if (await this.isLegacyNFTContract()) {
            const message = await this.mapLegacyPayloadToContractStruct(mintRequest);
            const price = message.price;
            // TODO: Transaction Sequence Pattern
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "mintWithSignature",
                args: [
                    message,
                    signature
                ],
                overrides,
                parse
            });
        } else {
            const message = await this.mapPayloadToContractStruct(mintRequest);
            const price = message.pricePerToken.mul(message.quantity);
            // TODO: Transaction Sequence Pattern
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, price, mintRequest.currencyAddress, overrides);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "mintWithSignature",
                args: [
                    message,
                    signature
                ],
                overrides,
                parse
            });
        }
    });
    /**
   * Mint any number of dynamically generated NFT at once
   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)
   * @param signedPayloads - the array of signed payloads to mint
   * @twfeature ERC721SignatureMint
   */ mintBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (signedPayloads)=>{
        const isLegacyNFTContract = await this.isLegacyNFTContract();
        const contractPayloads = (await Promise.all(signedPayloads.map((s)=>isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index)=>{
            const s = signedPayloads[index];
            const signature = s.signature;
            const price = s.payload.price;
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(price).gt(0)) {
                throw new Error("Can only batch free mints. For mints with a price, use regular mint()");
            }
            return {
                message,
                signature
            };
        });
        const contractEncoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        const encoded = contractPayloads.map((p)=>{
            if (isLegacyNFTContract) {
                return contractEncoder.encode("mintWithSignature", [
                    p.message,
                    p.signature
                ]);
            } else {
                return contractEncoder.encode("mintWithSignature", [
                    p.message,
                    p.signature
                ]);
            }
        });
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("multicall", this.contractWrapper)) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "multicall",
                args: [
                    encoded
                ],
                parse: (receipt)=>{
                    const events = this.contractWrapper.parseLogs("TokensMintedWithSignature", receipt.logs);
                    if (events.length === 0) {
                        throw new Error("No MintWithSignature event found");
                    }
                    return events.map((log)=>({
                            id: log.args.tokenIdMinted,
                            receipt
                        }));
                }
            });
        } else {
            throw new Error("Multicall not available on this contract!");
        }
    });
    /**
   * Verify that a payload is correctly signed
   * @param signedPayload - the payload to verify
   * @twfeature ERC721SignatureMint
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // Now you can verify if the signed payload is valid
   * const isValid = await contract.erc721.signature.verify(signedPayload);
   * ```
   */ async verify(signedPayload) {
        const isLegacyNFTContract = await this.isLegacyNFTContract();
        const mintRequest = signedPayload.payload;
        const signature = signedPayload.signature;
        let message;
        let verification;
        if (isLegacyNFTContract) {
            message = await this.mapLegacyPayloadToContractStruct(mintRequest);
            verification = await this.contractWrapper.read("verify", [
                message,
                signature
            ]);
        } else {
            message = await this.mapPayloadToContractStruct(mintRequest);
            verification = await this.contractWrapper.read("verify", [
                message,
                signature
            ]);
        }
        return verification[0];
    }
    /**
   * Generate a signature that can be used to mint a dynamic NFT
   *
   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.
   *
   * @example
   * ```javascript
   * const nftMetadata = {
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const startTime = new Date();
   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const payload = {
   *   metadata: nftMetadata, // The NFT to mint
   *   to: {{wallet_address}}, // Who will receive the NFT
   *   quantity: 2, // the quantity of NFTs to mint
   *   price: 0.5, // the price per NFT
   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with
   *   mintStartTime: startTime, // can mint anytime from now
   *   mintEndTime: endTime, // to 24h from now
   *   royaltyRecipient: "0x...", // custom royalty recipient for this NFT
   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)
   *   primarySaleRecipient: "0x...", // custom sale recipient for this NFT
   * };
   *
   * const signedPayload = await contract.erc721.signature.generate(payload);
   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`
   * ```
   * @param mintRequest - the payload to sign
   * @returns The signed payload and the corresponding signature
   * @twfeature ERC721SignatureMint
   */ async generate(mintRequest) {
        return (await this.generateBatch([
            mintRequest
        ]))[0];
    }
    /**
   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.
   *
   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}
   *
   * @param payloadsToSign - the payloads to sign
   * @returns An array of payloads and signatures
   * @twfeature ERC721SignatureMint
   */ async generateBatch(payloadsToSign) {
        const isLegacyNFTContract = await this.isLegacyNFTContract();
        const parsedRequests = await Promise.all(payloadsToSign.map((m)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["t"].parseAsync(m)));
        const metadatas = parsedRequests.map((r)=>r.metadata);
        const uris = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"])(metadatas, this.storage);
        const chainId = await this.contractWrapper.getChainID();
        const signer = this.contractWrapper.getSigner();
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(signer, "No signer available");
        return await Promise.all(parsedRequests.map(async (m, i)=>{
            const uri = uris[i];
            const finalPayload = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["u"].parseAsync({
                ...m,
                uri
            });
            let signature;
            if (isLegacyNFTContract) {
                signature = await this.contractWrapper.signTypedData(signer, {
                    name: "TokenERC721",
                    version: "1",
                    chainId,
                    verifyingContract: this.contractWrapper.address
                }, {
                    MintRequest: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["v"]
                }, await this.mapLegacyPayloadToContractStruct(finalPayload));
            } else {
                signature = await this.contractWrapper.signTypedData(signer, {
                    name: "SignatureMintERC721",
                    version: "1",
                    chainId,
                    verifyingContract: await this.contractWrapper.address
                }, {
                    MintRequest: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$signature$2d$d3ea643d$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"]
                }, // TYPEHASH
                await this.mapPayloadToContractStruct(finalPayload));
            }
            return {
                payload: finalPayload,
                signature: signature.toString()
            };
        }));
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Maps a payload to the format expected by the contract
   *
   * @internal
   *
   * @param mintRequest - The payload to map.
   * @returns  The mapped payload.
   */ async mapPayloadToContractStruct(mintRequest) {
        const normalizedPricePerToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
        return {
            to: mintRequest.to,
            royaltyRecipient: mintRequest.royaltyRecipient,
            royaltyBps: mintRequest.royaltyBps,
            primarySaleRecipient: mintRequest.primarySaleRecipient,
            uri: mintRequest.uri,
            quantity: mintRequest.quantity,
            pricePerToken: normalizedPricePerToken,
            currency: mintRequest.currencyAddress,
            validityStartTimestamp: mintRequest.mintStartTime,
            validityEndTimestamp: mintRequest.mintEndTime,
            uid: mintRequest.uid
        };
    }
    async mapLegacyPayloadToContractStruct(mintRequest) {
        const normalizedPricePerToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);
        return {
            to: mintRequest.to,
            price: normalizedPricePerToken,
            uri: mintRequest.uri,
            currency: mintRequest.currencyAddress,
            validityEndTimestamp: mintRequest.mintEndTime,
            validityStartTimestamp: mintRequest.mintStartTime,
            uid: mintRequest.uid,
            royaltyRecipient: mintRequest.royaltyRecipient,
            royaltyBps: mintRequest.royaltyBps,
            primarySaleRecipient: mintRequest.primarySaleRecipient
        };
    }
    async isLegacyNFTContract() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721SignatureMintV1");
    }
}
/**
 * Standard ERC721 NFT functions
 * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.
 * @example
 * ```javascript
 * const contract = await sdk.getContract("{{contract_address}}");
 * await contract.erc721.transfer(walletAddress, tokenId);
 * ```
 * @erc721
 * @public
 */ class Erc721 {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c$"].name;
    get chainId() {
        return this._chainId;
    }
    constructor(contractWrapper, storage, chainId){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.query = this.detectErc721Enumerable();
        this.mintable = this.detectErc721Mintable();
        this.burnable = this.detectErc721Burnable();
        this.lazyMintable = this.detectErc721LazyMintable();
        this.tieredDropable = this.detectErc721TieredDrop();
        this.signatureMintable = this.detectErc721SignatureMintable();
        this.claimWithConditions = this.detectErc721ClaimableWithConditions();
        this.claimCustom = this.detectErc721Claimable();
        this.claimZora = this.detectErc721ClaimableZora();
        this.erc721SharedMetadata = this.detectErc721SharedMetadata();
        this.loyaltyCard = this.detectErc721LoyaltyCard();
        this.updatableMetadata = this.detectErc721UpdatableMetadata();
        this._chainId = chainId;
    }
    /**
   * @internal
   */ onNetworkUpdated(network) {
        this.contractWrapper.updateSignerOrProvider(network);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    ////// Standard ERC721 Extension //////
    /**
   * Get a single NFT
   *
   * @example
   * ```javascript
   * const tokenId = 0;
   * const nft = await contract.erc721.get(tokenId);
   * ```
   * @param tokenId - the tokenId of the NFT to retrieve
   * @returns The NFT metadata
   * @twfeature ERC721
   */ async get(tokenId) {
        const [owner, metadata] = await Promise.all([
            this.ownerOf(tokenId).catch(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero),
            this.getTokenMetadata(tokenId).catch(()=>({
                    id: tokenId.toString(),
                    uri: "",
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["F"]
                }))
        ]);
        return {
            owner,
            metadata,
            type: "ERC721",
            supply: "1"
        };
    }
    /**
   * Get the current owner of an NFT
   *
   * @param tokenId - the tokenId of the NFT
   * @returns The address of the owner
   * @twfeature ERC721
   */ async ownerOf(tokenId) {
        return await this.contractWrapper.read("ownerOf", [
            tokenId
        ]);
    }
    /**
   * Get NFT balance of a specific wallet
   *
   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const balance = await contract.erc721.balanceOf(walletAddress);
   * console.log(balance);
   * ```
   * @twfeature ERC721
   */ async balanceOf(address) {
        return await this.contractWrapper.read("balanceOf", [
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address)
        ]);
    }
    /**
   * Get NFT balance for the currently connected wallet
   */ async balance() {
        return await this.balanceOf(await this.contractWrapper.getSignerAddress());
    }
    /**
   * Get whether this wallet has approved transfers from the given operator
   * @param address - the wallet address
   * @param operator - the operator address
   */ async isApproved(address, operator) {
        const [_address, _operator] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(address),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(operator)
        ]);
        return await this.contractWrapper.read("isApprovedForAll", [
            _address,
            _operator
        ]);
    }
    /**
   * Transfer an NFT
   *
   * @remarks Transfer an NFT from the connected wallet to another wallet.
   *
   * @example
   * ```javascript
   * const walletAddress = "{{wallet_address}}";
   * const tokenId = 0;
   * await contract.erc721.transfer(walletAddress, tokenId);
   * ```
   * @twfeature ERC721
   */ transfer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (to, tokenId)=>{
        const [from, _to] = await Promise.all([
            this.contractWrapper.getSignerAddress(),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to)
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "transferFrom(address,address,uint256)",
            args: [
                from,
                _to,
                tokenId
            ]
        });
    });
    /**
   * Transfer an NFT from a specific wallet
   *
   * @remarks Transfer an NFT from the given wallet to another wallet.
   *
   * @example
   * ```javascript
   * const fromWalletAddress = "{{wallet_address}}";
   * const toWalletAddress = "{{wallet_address}}";
   * const tokenId = 0;
   * await contract.erc721.transferFrom(fromWalletAddress, toWalletAddress, tokenId);
   * ```
   * @twfeature ERC721
   */ transferFrom = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (from, to, tokenId)=>{
        const [fromAddress, toAddress] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(from),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(to)
        ]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "transferFrom(address,address,uint256)",
            args: [
                fromAddress,
                toAddress,
                tokenId
            ]
        });
    });
    /**
   * Set approval for all NFTs
   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.
   * @example
   * ```javascript
   * const operator = "{{wallet_address}}";
   * await contract.erc721.setApprovalForAll(operator, true);
   * ```
   * @param operator - the operator's address
   * @param approved - whether to approve or remove
   * @twfeature ERC721
   */ setApprovalForAll = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (operator, approved)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "setApprovalForAll",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(operator),
                approved
            ]
        });
    });
    /**
   * Set approval for a single NFT
   * @remarks Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.
   * @example
   * ```javascript
   * const operator = "{{wallet_address}}";
   * const tokenId = 0;
   * await contract.erc721.setApprovalForToken(operator, tokenId);
   * ```
   * @param operator - the operator's address
   * @param tokenId - the tokenId to give approval for
   *
   * @internal
   */ setApprovalForToken = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (operator, tokenId)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approve",
            args: [
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(operator),
                tokenId
            ]
        });
    });
    ////// ERC721 Supply Extension //////
    /**
   * Get all NFTs
   *
   * @remarks Get all the data associated with every NFT in this contract.
   *
   * By default, returns the first 100 NFTs, use queryParams to fetch more.
   *
   * @example
   * ```javascript
   * const nfts = await contract.erc721.getAll();
   * console.log(nfts);
   * ```
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs queried.
   * @twfeature ERC721Supply | ERC721Enumerable
   */ async getAll(queryParams) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cY"]).all(queryParams);
    }
    /**
   * Get all NFT owners
   * @example
   * ```javascript
   * const owners = await contract.erc721.getAllOwners();
   * console.log(owners);
   * ```
   * @returns An array of token ids and owners
   * @twfeature ERC721Supply | ERC721Enumerable
   */ async getAllOwners(queryParams) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cY"]).allOwners(queryParams);
    }
    /**
   * Get the total number of NFTs minted
   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.
   * @example
   * ```javascript
   * const count = await contract.erc721.totalCount();
   * console.log(count);
   * ```
   *
   * @returns The total number of NFTs minted in this contract
   * @public
   */ async totalCount() {
        return this.nextTokenIdToMint();
    }
    /**
   * Get the total count NFTs minted in this contract
   * @twfeature ERC721Supply | ERC721Enumerable
   */ async totalCirculatingSupply() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.query, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cY"]).totalCirculatingSupply();
    }
    ////// ERC721 Enumerable Extension //////
    /**
   * Get all NFTs owned by a specific wallet
   *
   * @remarks Get all the data associated with the NFTs owned by a specific wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet to get the NFTs of
   * const address = "{{wallet_address}}";
   * const nfts = await contract.erc721.getOwned(address);
   * console.log(nfts);
   * ```
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   * @param queryParams - optional filtering to only fetch a subset of results.
   * @returns The NFT metadata for all NFTs in the contract.
   * @twfeature ERC721Supply | ERC721Enumerable
   */ async getOwned(walletAddress, queryParams) {
        if (walletAddress) {
            walletAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress);
        }
        if (this.query?.owned) {
            return this.query.owned.all(walletAddress, queryParams);
        } else {
            const [address, allOwners] = await Promise.all([
                walletAddress || this.contractWrapper.getSignerAddress(),
                this.getAllOwners(queryParams)
            ]);
            const ownedTokens = (allOwners || []).filter((i)=>address?.toLowerCase() === i.owner?.toLowerCase());
            return await Promise.all(ownedTokens.map(async (i)=>this.get(i.tokenId)));
        }
    }
    /**
   * Get all token ids of NFTs owned by a specific wallet.
   * @param walletAddress - the wallet address to query, defaults to the connected wallet
   */ async getOwnedTokenIds(walletAddress) {
        if (walletAddress) {
            walletAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(walletAddress);
        }
        if (this.query?.owned) {
            return this.query.owned.tokenIds(walletAddress);
        } else {
            const [address, allOwners] = await Promise.all([
                walletAddress || this.contractWrapper.getSignerAddress(),
                this.getAllOwners()
            ]);
            return (allOwners || []).filter((i)=>address?.toLowerCase() === i.owner?.toLowerCase()).map((i)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(i.tokenId));
        }
    }
    ////// ERC721 Mintable Extension //////
    /**
   * Mint an NFT
   *
   * @remarks Mint an NFT to the connected wallet.
   *
   * @example
   * ```javascript
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const tx = await contract.erc721.mint(metadata);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   * @twfeature ERC721Mintable
   */ mint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadata)=>{
        return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);
    });
    /**
   * Mint an NFT to a specific wallet
   *
   * @remarks Mint a unique NFT to a specified wallet.
   *
   * @example
   * ```javascript
   * // Address of the wallet you want to mint the NFT to
   * const walletAddress = "{{wallet_address}}";
   *
   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
   * const metadata = {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * };
   *
   * const tx = await contract.erc721.mintTo(walletAddress, metadata);
   * const receipt = tx.receipt; // the transaction receipt
   * const tokenId = tx.id; // the id of the NFT minted
   * const nft = await tx.data(); // (optional) fetch details of minted NFT
   * ```
   * @twfeature ERC721Mintable
   */ mintTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, metadata)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cU"]).to.prepare(receiver, metadata);
    });
    /**
   * Construct a mint transaction without executing it.
   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param receiver - Address you want to send the token to
   * @param metadata - The metadata of the NFT you want to mint
   *
   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead
   * @twfeature ERC721Mintable
   */ async getMintTransaction(receiver, metadata) {
        return this.mintTo.prepare(receiver, metadata);
    }
    ////// ERC721 Batch Mintable Extension //////
    /**
   * Mint many NFTs
   *
   * @remarks Mint many unique NFTs at once to the connected wallet
   *
   * @example
   * ```typescript
   * // Custom metadata of the NFTs you want to mint.
   * const metadatas = [{
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT #2",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/other/image.png"),
   * }];
   *
   * const tx = await contract.erc721.mintBatch(metadatas);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   * @twfeature ERC721BatchMintable
   */ mintBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas)=>{
        return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);
    });
    /**
   * Mint many NFTs to a specific wallet
   *
   * @remarks Mint many unique NFTs at once to a specified wallet.
   *
   * @example
   * ```typescript
   * // Address of the wallet you want to mint the NFT to
   * const walletAddress = "{{wallet_address}}";
   *
   * // Custom metadata of the NFTs you want to mint.
   * const metadatas = [{
   *   name: "Cool NFT #1",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT #2",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/other/image.png"),
   * }];
   *
   * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);
   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs
   * const firstTokenId = tx[0].id; // token id of the first minted NFT
   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT
   * ```
   * @twfeature ERC721BatchMintable
   */ mintBatchTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (receiver, metadatas)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.mintable?.batch, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cT"]).to.prepare(receiver, metadatas);
    });
    ////// ERC721 Burnable Extension //////
    /**
   * Burn a single NFT
   * @param tokenId - the token Id to burn
   *
   * @example
   * ```javascript
   * const result = await contract.erc721.burn(tokenId);
   * ```
   * @twfeature ERC721Burnable
   */ burn = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.burnable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cL"]).token.prepare(tokenId);
    });
    ////// ERC721 Loyalty Card Extension //////
    /**
   * Cancel loyalty card NFTs
   *
   * @remarks Cancel loyalty card NFTs held by the connected wallet
   *
   * @example
   * ```javascript
   * // The token ID of the loyalty card you want to cancel
   * const tokenId = 0;
   *
   * const result = await contract.erc721.cancel(tokenId);
   * ```
   * @twfeature ERC721LoyaltyCard
   */ cancel = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.loyaltyCard, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cR"]).cancel.prepare(tokenId);
    });
    /**
   * Revoke loyalty card NFTs
   *
   * @remarks Revoke loyalty card NFTs held by some owner.
   *
   * @example
   * ```javascript
   * // The token ID of the loyalty card you want to revoke
   * const tokenId = 0;
   *
   * const result = await contract.erc721.revoke(tokenId);
   * ```
   * @twfeature ERC721LoyaltyCard
   */ revoke = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.loyaltyCard, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cR"]).revoke.prepare(tokenId);
    });
    ////// ERC721 LazyMint Extension //////
    /**
   * Lazy mint NFTs
   *
   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.
   *
   * @example
   * ```javascript
   * // Custom metadata of the NFTs to create
   * const metadatas = [{
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
   * }, {
   *   name: "Cool NFT",
   *   description: "This is a cool NFT",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   *
   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain
   * const firstTokenId = results[0].id; // token id of the first created NFT
   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT
   * ```
   *
   * @param metadatas - The metadata to include in the batch.
   * @param options - optional upload progress callback
   * @twfeature ERC721LazyMintable
   */ lazyMint = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (metadatas, options)=>{
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.lazyMintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cP"]).lazyMint.prepare(metadatas, options);
    });
    ////// ERC721 Metadata Extension //////
    /**
   * Update the metadata of an NFT
   *
   * @remarks Update the metadata of an NFT
   *
   * @example
   * ```javascript
   * // The token ID of the NFT whose metadata you want to update
   * const tokenId = 0;
   * // The new metadata
   * const metadata = { name: "My NFT", description: "My NFT description" }
   *
   * await contract.erc721.update(tokenId, metadata);
   * ```
   * @twfeature ERC721UpdatableMetadata
   */ updateMetadata = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (tokenId, metadata)=>{
        if (this.lazyMintable) {
            return this.lazyMintable.updateMetadata.prepare(tokenId, metadata);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.updatableMetadata, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cS"]).update.prepare(tokenId, metadata);
    });
    // alias for backwards compat
    async update(tokenId, metadata) {
        return this.updateMetadata(tokenId, metadata);
    }
    ////// ERC721 Claimable Extension //////
    /**
   * Claim NFTs
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const quantity = 1; // how many unique NFTs you want to claim
   *
   * const tx = await contract.erc721.claim(quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * const claimedTokenId = tx.id; // the id of the NFT claimed
   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata
   * ```
   *
   * @param quantity - Quantity of the tokens you want to claim
   *
   * @returns  an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora
   */ claim = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (quantity, options)=>{
        return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);
    });
    /**
   * Claim NFTs to a specific wallet
   *
   * @remarks Let the specified wallet claim NFTs.
   *
   * @example
   * ```javascript
   * const address = "{{wallet_address}}"; // address of the wallet you want to claim the NFTs
   * const quantity = 1; // how many unique NFTs you want to claim
   *
   * const tx = await contract.erc721.claimTo(address, quantity);
   * const receipt = tx.receipt; // the transaction receipt
   * const claimedTokenId = tx.id; // the id of the NFT claimed
   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata
   * ```
   *
   * @param destinationAddress - Address you want to send the token to
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - optional claim options
   * @returns  an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora
   */ claimTo = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (destinationAddress, quantity, options)=>{
        const claimWithConditions = this.claimWithConditions;
        const claim = this.claimCustom;
        const claimZora = this.claimZora;
        if (claimWithConditions) {
            return claimWithConditions.to.prepare(destinationAddress, quantity, options);
        }
        if (claim) {
            return claim.to.prepare(destinationAddress, quantity, options);
        }
        if (claimZora) {
            return claimZora.to.prepare(destinationAddress, quantity, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cO"]);
    });
    /**
   * Construct a claim transaction without executing it.
   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.
   * @param destinationAddress - Address you want to send the token to
   * @param quantity - Quantity of the tokens you want to claim
   * @param options - optional claim options
   *
   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */ async getClaimTransaction(destinationAddress, quantity, options) {
        const claimWithConditions = this.claimWithConditions;
        const claim = this.claimCustom;
        if (claimWithConditions) {
            return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);
        }
        if (claim) {
            return claim.getClaimTransaction(destinationAddress, quantity, options);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cO"]);
    }
    /**
   * Get the claimed supply
   *
   * @remarks Get the number of claimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const claimedNFTCount = await contract.totalClaimedSupply();
   * console.log(`NFTs claimed: ${claimedNFTCount}`);
   * ```
   * @returns The unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */ async totalClaimedSupply() {
        const contract = this.contractWrapper;
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("totalMinted", contract)) {
            return this.contractWrapper.read("totalMinted", []);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("nextTokenIdToClaim", contract)) {
            return this.contractWrapper.read("nextTokenIdToClaim", []);
        }
        throw new Error("No function found on contract to get total claimed supply");
    }
    /**
   * Get the unclaimed supply
   *
   * @remarks Get the number of unclaimed NFTs in this Drop.
   *
   * * @example
   * ```javascript
   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();
   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);
   * ```
   * @returns The unclaimed supply
   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */ async totalUnclaimedSupply() {
        const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([
            this.nextTokenIdToMint(),
            this.totalClaimedSupply()
        ]);
        return nextTokenIdToMint.sub(totalClaimedSupply);
    }
    /**
   * Configure claim conditions
   * @remarks Define who can claim NFTs in the collection, when and how many.
   * @example
   * ```javascript
   * const presaleStartTime = new Date();
   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);
   * const claimConditions = [
   *   {
   *     startTime: presaleStartTime, // start the presale now
   *     maxClaimableSupply: 2, // limit how many mints for this presale
   *     price: 0.01, // presale price
   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses
   *   },
   *   {
   *     startTime: publicSaleStartTime, // 24h after presale, start public sale
   *     price: 0.08, // public sale price
   *   }
   * ]);
   * await contract.erc721.claimConditions.set(claimConditions);
   * ```
   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1
   */ get claimConditions() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.claimWithConditions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cM"]).conditions;
    }
    ////// ERC721 Tiered Drop Extension //////
    /**
   * Tiered Drop
   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.
   * @twfeature ERC721TieredDrop
   */ get tieredDrop() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.tieredDropable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cZ"]);
    }
    ////// ERC721 SignatureMint Extension //////
    /**
   * Mint with signature
   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.
   * @example
   * ```javascript
   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation
   * const signedPayload = await contract.erc721.signature.generate(payload);
   *
   * // now anyone can mint the NFT
   * const tx = await contract.erc721.signature.mint(signedPayload);
   * const receipt = tx.receipt; // the mint transaction receipt
   * const mintedId = tx.id; // the id of the NFT minted
   * ```
   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2
   */ get signature() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.signatureMintable, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c_"]);
    }
    ////// ERC721 DelayedReveal Extension //////
    /**
   * Mint delayed reveal NFTs
   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.
   * @example
   * ```javascript
   * // the real NFTs, these will be encrypted until you reveal them
   * const realNFTs = [{
   *   name: "Common NFT #1",
   *   description: "Common NFT, one of many.",
   *   image: fs.readFileSync("path/to/image.png"),
   * }, {
   *   name: "Super Rare NFT #2",
   *   description: "You got a Super Rare NFT!",
   *   image: fs.readFileSync("path/to/image.png"),
   * }];
   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time
   * const placeholderNFT = {
   *   name: "Hidden NFT",
   *   description: "Will be revealed next week!"
   * };
   * // Create and encrypt the NFTs
   * await contract.erc721.revealer.createDelayedRevealBatch(
   *   placeholderNFT,
   *   realNFTs,
   *   "my secret password",
   * );
   * // Whenever you're ready, reveal your NFTs at any time
   * const batchId = 0; // the batch to reveal
   * await contract.erc721.revealer.reveal(batchId, "my secret password");
   * ```
   * @twfeature ERC721Revealable
   */ get revealer() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.lazyMintable?.revealer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cQ"]);
    }
    ////// ERC721 Shared Metadata Extension (Open Edition) //////
    /**
   * Set shared metadata for all NFTs
   * @remarks Set shared metadata for all NFTs in the collection. (Open Edition)
   * @example
   * ```javascript
   * // defiine the metadata
   * const metadata = {
   *  name: "Shared Metadata",
   *  description: "Every NFT in this collection will share this metadata."
   * };
   *
   *
   * const tx = contract.erc721.sharedMetadata.set(metadata);
   * ```
   * @twfeature ERC721SharedMetadata
   */ get sharedMetadata() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.erc721SharedMetadata, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cV"]);
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * @internal
   */ async getTokenMetadata(tokenId) {
        const tokenUri = await this.contractWrapper.read("tokenURI", [
            tokenId
        ]);
        if (!tokenUri) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"]();
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(tokenId, tokenUri, this.storage);
    }
    /**
   * Return the next available token ID to mint
   * @internal
   */ async nextTokenIdToMint() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("nextTokenIdToMint", this.contractWrapper)) {
            let nextTokenIdToMint = await this.contractWrapper.read("nextTokenIdToMint", []);
            // handle open editions and contracts with startTokenId
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("startTokenId", this.contractWrapper)) {
                nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read("startTokenId", []));
            }
            return nextTokenIdToMint;
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("totalSupply", this.contractWrapper)) {
            return await this.contractWrapper.read("totalSupply", []);
        } else {
            throw new Error("Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint");
        }
    }
    detectErc721Enumerable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721Supply") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])("nextTokenIdToMint", this.contractWrapper)) {
            return new Erc721Supply(this, this.contractWrapper);
        }
        return undefined;
    }
    detectErc721Mintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721Mintable")) {
            return new Erc721Mintable(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721Burnable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721Burnable")) {
            return new Erc721Burnable(this.contractWrapper);
        }
        return undefined;
    }
    detectErc721LazyMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721LazyMintable")) {
            return new Erc721LazyMintable(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721TieredDrop() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721TieredDrop")) {
            return new Erc721TieredDrop(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721SignatureMintable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721SignatureMintV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721SignatureMintV2")) {
            return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721ClaimableWithConditions() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimConditionsV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimConditionsV2") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimPhasesV1") || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimPhasesV2")) {
            return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721Claimable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimCustom")) {
            return new Erc721Claimable(this, this.contractWrapper);
        }
        return undefined;
    }
    detectErc721ClaimableZora() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721ClaimZora")) {
            return new Erc721ClaimableZora(this, this.contractWrapper);
        }
        return undefined;
    }
    detectErc721SharedMetadata() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721SharedMetadata")) {
            return new Erc721SharedMetadata(this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectErc721LoyaltyCard() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721LoyaltyCard")) {
            return new Erc721LoyaltyCard(this.contractWrapper);
        }
        return undefined;
    }
    detectErc721UpdatableMetadata() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721UpdatableMetadata")) {
            return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);
        }
        return undefined;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/cleanCurrencyAddress-ded19cfe.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "c": (()=>cleanCurrencyAddress)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
;
;
/**
 * @internal
 */ function cleanCurrencyAddress(currencyAddress) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(currencyAddress)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"];
    }
    return currencyAddress;
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/marketplace-e3129e2f.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "a": (()=>isWinningBid),
    "g": (()=>getAllInBatches),
    "h": (()=>handleTokenApproval),
    "i": (()=>isTokenApprovedForTransfer),
    "m": (()=>mapOffer),
    "v": (()=>validateNewListingParam)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * This method checks if the given token is approved for the transferrerContractAddress contract.
 * This is particularly useful for contracts that need to transfer NFTs on the users' behalf
 *
 * @internal
 * @param provider - The connected provider
 * @param transferrerContractAddress - The address of the marketplace contract
 * @param assetContract - The address of the asset contract.
 * @param tokenId - The token id of the token.
 * @param owner - The address of the account that owns the token.
 * @returns  True if the transferrerContractAddress is approved on the token, false otherwise.
 */ async function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {
    try {
        const ERC165Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json (json, async loader)")(__turbopack_context__.i)).default;
        const erc165 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](assetContract, ERC165Abi, provider);
        const [isERC721, isERC1155] = await Promise.all([
            erc165.supportsInterface(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"]),
            erc165.supportsInterface(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])
        ]);
        if (isERC721) {
            const ERC721Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json (json, async loader)")(__turbopack_context__.i)).default;
            const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](assetContract, ERC721Abi, provider);
            const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);
            if (approved) {
                return true;
            }
            // Handle reverts in case of non-existent tokens
            let approvedAddress;
            try {
                approvedAddress = await asset.getApproved(tokenId);
            } catch (e) {}
            return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();
        } else if (isERC1155) {
            const ERC1155Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json (json, async loader)")(__turbopack_context__.i)).default;
            const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](assetContract, ERC1155Abi, provider);
            return await asset.isApprovedForAll(owner, transferrerContractAddress);
        } else {
            console.error("Contract does not implement ERC 1155 or ERC 721.");
            return false;
        }
    } catch (err) {
        console.error("Failed to check if token is approved", err);
        return false;
    }
}
/**
 * Checks if the marketplace is approved to make transfers on the assetContract
 * If not, it tries to set the approval.
 * @param contractWrapper - The contract wrapper to use
 * @param marketplaceAddress - The address of the marketplace contract
 * @param assetContract - The address of the asset contract.
 * @param tokenId - The token id of the token.
 * @param from - The address of the account that owns the token.
 */ async function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {
    const ERC165Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json (json, async loader)")(__turbopack_context__.i)).default;
    const erc165 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);
    const [isERC721, isERC1155] = await Promise.all([
        erc165.read("supportsInterface", [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"]
        ]),
        erc165.read("supportsInterface", [
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"]
        ])
    ]);
    // check for token approval
    if (isERC721) {
        const ERC721Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json (json, async loader)")(__turbopack_context__.i)).default;
        const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);
        const approved = await asset.read("isApprovedForAll", [
            from,
            marketplaceAddress
        ]);
        if (!approved) {
            const isTokenApproved = (await asset.read("getApproved", [
                tokenId
            ])).toLowerCase() === marketplaceAddress.toLowerCase();
            if (!isTokenApproved) {
                await asset.sendTransaction("setApprovalForAll", [
                    marketplaceAddress,
                    true
                ]);
            }
        }
    } else if (isERC1155) {
        const ERC1155Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json (json, async loader)")(__turbopack_context__.i)).default;
        const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);
        const approved = await asset.read("isApprovedForAll", [
            from,
            marketplaceAddress
        ]);
        if (!approved) {
            await asset.sendTransaction("setApprovalForAll", [
                marketplaceAddress,
                true
            ]);
        }
    } else {
        throw Error("Contract must implement ERC 1155 or ERC 721.");
    }
}
/**
 * Used to verify fields in new listing.
 * @internal
 */ // TODO this should be done in zod
function validateNewListingParam(param) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.assetContractAddress !== undefined && param.assetContractAddress !== null, "Asset contract address is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, "Buyout price is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, "Listing duration is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.startTimestamp !== undefined && param.startTimestamp !== null, "Start time is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.tokenId !== undefined && param.tokenId !== null, "Token ID is required");
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.quantity !== undefined && param.quantity !== null, "Quantity is required");
    switch(param.type){
        case "NewAuctionListing":
            {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, "Reserve price is required");
            }
    }
}
/**
 * Maps a contract offer to the strict interface
 *
 * @internal
 * @param offer - The offer to map
 * @returns  An `Offer` object
 */ async function mapOffer(provider, listingId, offer) {
    return {
        quantity: offer.quantityDesired,
        pricePerToken: offer.pricePerToken,
        currencyContractAddress: offer.currency,
        buyerAddress: offer.offeror,
        quantityDesired: offer.quantityWanted,
        currencyValue: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),
        listingId
    };
}
function isWinningBid(winningPrice, newBidPrice, bidBuffer) {
    bidBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(bidBuffer);
    winningPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(winningPrice);
    newBidPrice = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(newBidPrice);
    if (winningPrice.eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0))) {
        return false;
    }
    const buffer = newBidPrice.sub(winningPrice).mul(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dE"]).div(winningPrice);
    return buffer.gte(bidBuffer);
}
async function getAllInBatches(start, end, fn) {
    const batches = [];
    while(end - start > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"]){
        batches.push(fn(start, start + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"] - 1));
        start += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
    }
    batches.push(fn(start, end - 1));
    return await Promise.all(batches);
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/marketplacev3-offers-ce1f096b.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "M": (()=>MarketplaceV3DirectListings),
    "S": (()=>Status),
    "a": (()=>MarketplaceV3EnglishAuctions),
    "b": (()=>MarketplaceV3Offers)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/bignumber/lib.esm/bignumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__ = __turbopack_context__.i("[project]/node_modules/@ethersproject/constants/lib.esm/index.js [app-client] (ecmascript) <export * as constants>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils.js [app-client] (ecmascript) <export * as utils>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$cleanCurrencyAddress$2d$ded19cfe$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/cleanCurrencyAddress-ded19cfe.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/normalizePriceValue-9851c0eb.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/setErc20Allowance-7f76f677.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/marketplace-e3129e2f.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/QueryParams-32a56510.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/v3/external.js [app-client] (ecmascript) <export * as z>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-interceptor-d7b164a7.browser.esm.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @internal
 */ const DirectListingInputParamsSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        /**
   * The address of the asset being listed.
   */ assetContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"],
        /**
   * The ID of the token to list.
   */ tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"],
        /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */ quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(1),
        /**
   * The address of the currency to accept for the listing.
   */ currencyContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]),
        /**
   * The price to pay per unit of NFTs listed.
   */ pricePerToken: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"],
        /**
   * The start time of the listing.
   */ startTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["R"].default(new Date()),
        /**
   * The end time of the listing.
   */ endTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"],
        /**
   * Whether the listing is reserved to be bought from a specific set of buyers.
   */ isReservedListing: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false)
    }))();
/**
 * @public
 */ let Status = /*#__PURE__*/ function(Status) {
    Status[Status["UNSET"] = 0] = "UNSET";
    Status[Status["Created"] = 1] = "Created";
    Status[Status["Completed"] = 2] = "Completed";
    Status[Status["Cancelled"] = 3] = "Cancelled";
    Status[Status["Active"] = 4] = "Active";
    Status[Status["Expired"] = 5] = "Expired";
    return Status;
}({});
/**
 * Handles direct listings
 * @public
 */ class MarketplaceV3DirectListings {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dA"].name;
    // utilities
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        this.encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.interceptor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.estimator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"](this.contractWrapper);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * READ FUNCTIONS
   *******************************/ /**
   * Get the total number of direct listings
   *
   * @returns Returns the total number of direct listings created.
   * @public
   *
   * @example
   * ```javascript
   * const totalListings = await contract.directListings.getTotalCount();
   * ```
   * @twfeature DirectListings
   */ async getTotalCount() {
        return await this.contractWrapper.read("totalListings", []);
    }
    /**
   * Get all direct listings
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Direct listing object array
   * @twfeature DirectListings
   */ async getAll(filter) {
        const totalListings = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalListings.toNumber();
        if (end === 0) {
            throw new Error(`No listings exist on the contract.`);
        }
        let rawListings = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllListings", [
                startId,
                endId
            ]));
        rawListings = batches.flat();
        const filteredListings = await this.applyFilter(rawListings, filter);
        return await Promise.all(filteredListings.map((listing)=>this.mapListing(listing)));
    }
    /**
   * Get all valid direct listings
   *
   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Direct listing object array
   * @twfeature DirectListings
   */ async getAllValid(filter) {
        const totalListings = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalListings.toNumber();
        if (end === 0) {
            throw new Error(`No listings exist on the contract.`);
        }
        let rawListings = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllValidListings", [
                startId,
                endId
            ]));
        rawListings = batches.flat();
        const filteredListings = await this.applyFilter(rawListings, filter);
        return await Promise.all(filteredListings.map((listing)=>this.mapListing(listing)));
    }
    /**
   * Get a single direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   *
   * @param listingId - the listing id
   * @returns The Direct listing object
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   * @twfeature DirectListings
   */ async getListing(listingId) {
        const listing = await this.contractWrapper.read("getListing", [
            listingId
        ]);
        return await this.mapListing(listing);
    }
    /**
   * Check if a buyer is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, "{{wallet_address}}");
   * ```
   *
   * @param listingId - the listing id
   * @param buyer - buyer address
   * @twfeature DirectListings
   */ async isBuyerApprovedForListing(listingId, buyer) {
        const listing = await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        if (!listing.isReservedListing) {
            throw new Error(`Listing ${listingId} is not a reserved listing.`);
        }
        return await this.contractWrapper.read("isBuyerApprovedForListing", [
            listingId,
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(buyer)
        ]);
    }
    /**
   * Check if a currency is approved for a specific direct listing
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currency - currency address
   * @twfeature DirectListings
   */ async isCurrencyApprovedForListing(listingId, currency) {
        await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        return await this.contractWrapper.read("isCurrencyApprovedForListing", [
            listingId,
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(currency)
        ]);
    }
    /**
   * Check price per token for an approved currency
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const currencyContractAddress = '0x1234';
   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - the listing id
   * @param currencyContractAddress - currency contract address
   * @twfeature DirectListings
   */ async currencyPriceForListing(listingId, currencyContractAddress) {
        const listing = await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        const resolvedCurrencyAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(currencyContractAddress);
        if (resolvedCurrencyAddress === listing.currencyContractAddress) {
            return listing.pricePerToken;
        }
        const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);
        if (!isApprovedCurrency) {
            throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);
        }
        return await this.contractWrapper.read("currencyPriceForListing", [
            listingId,
            resolvedCurrencyAddress
        ]);
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Create new direct listing
   *
   * @remarks Create a new listing on the marketplace where people can buy an asset directly.
   *
   * @example
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   * ```
   * @twfeature DirectListings
   */ createListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listing)=>{
        const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
        const normalizedPricePerToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
        const block = await this.contractWrapper.getProvider().getBlock("latest");
        const blockTime = block.timestamp;
        if (parsedListing.startTimestamp.lt(blockTime)) {
            parsedListing.startTimestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(blockTime);
        }
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createListing",
            args: [
                {
                    assetContract: parsedListing.assetContractAddress,
                    tokenId: parsedListing.tokenId,
                    quantity: parsedListing.quantity,
                    currency: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$cleanCurrencyAddress$2d$ded19cfe$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(parsedListing.currencyContractAddress),
                    pricePerToken: normalizedPricePerToken,
                    startTimestamp: parsedListing.startTimestamp,
                    endTimestamp: parsedListing.endTimestamp,
                    reserved: parsedListing.isReservedListing
                }
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
                return {
                    id: event[0].args.listingId,
                    receipt
                };
            }
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Create a batch of new listings
   *
   * @remarks Create a batch of new listings on the marketplace
   *
   * @example
   * ```javascript
   * const listings = [...];
   * const tx = await contract.directListings.createListingsBatch(listings);
   * ```
   */ createListingsBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listings)=>{
        const data = (await Promise.all(listings.map((listing)=>this.createListing.prepare(listing)))).map((tx)=>tx.encode());
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                data
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
                return events.map((event)=>{
                    return {
                        id: event.args.listingId,
                        receipt
                    };
                });
            }
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Update a direct listing
   *
   * @param listing - the new listing information
   *
   * @example
   * ```javascript
   * // Data of the listing you want to update
   *
   * const listingId = 0; // ID of the listing you want to update
   *
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...", // should be same as original listing
   *   // token ID of the asset you want to list
   *   tokenId: "0", // should be same as original listing
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.updateListing(listingId, listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   * ```
   * @twfeature DirectListings
   */ updateListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, listing)=>{
        const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
        const normalizedPricePerToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "updateListing",
            args: [
                listingId,
                {
                    assetContract: parsedListing.assetContractAddress,
                    tokenId: parsedListing.tokenId,
                    quantity: parsedListing.quantity,
                    currency: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$cleanCurrencyAddress$2d$ded19cfe$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(parsedListing.currencyContractAddress),
                    pricePerToken: normalizedPricePerToken,
                    startTimestamp: parsedListing.startTimestamp,
                    endTimestamp: parsedListing.endTimestamp,
                    reserved: parsedListing.isReservedListing
                }
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("UpdatedListing", receipt?.logs);
                return {
                    id: event[0].args.listingId,
                    receipt
                };
            }
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Cancel Direct Listing
   *
   * @remarks Cancel a direct listing on the marketplace
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to cancel
   * const listingId = 0;
   *
   * await contract.directListings.cancelListing(listingId);
   * ```
   * @twfeature DirectListings
   */ cancelListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId)=>{
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "cancelListing",
            args: [
                listingId
            ]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Buy direct listing for a specific wallet
   *
   * @remarks Buy from a specific direct listing from the marketplace.
   *
   * @example
   * ```javascript
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired, "{{wallet_address}}");
   * ```
   *
   * @param listingId - The listing id to buy
   * @param quantityDesired - the quantity to buy
   * @param receiver - optional receiver of the bought listing if different from the connected wallet
   * @twfeature DirectListings
   */ buyFromListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, quantityDesired, receiver)=>{
        if (receiver) {
            receiver = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(receiver);
        }
        const listing = await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        const { valid, error } = await this.isStillValidListing(listing, quantityDesired);
        if (!valid) {
            throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
        }
        const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
        const quantity = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(quantityDesired);
        const value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listing.pricePerToken).mul(quantity);
        const overrides = await this.contractWrapper.getCallOverrides() || {};
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, value, listing.currencyContractAddress, overrides);
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "buyFromListing",
            args: [
                listingId,
                buyFor,
                quantity,
                listing.currencyContractAddress,
                value
            ],
            overrides
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Approve buyer for a reserved direct listing
   *
   * @remarks Approve a buyer to buy from a reserved listing.
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to approve buyer for
   * const listingId = "0";
   *
   * await contract.directListings.approveBuyerForReservedListing(listingId, "{{wallet_address}}");
   * ```
   *
   * @param listingId - The listing id to buy
   * @param buyer - Address of buyer being approved
   * @twfeature DirectListings
   */ approveBuyerForReservedListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, buyer)=>{
        const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
        if (!isApproved) {
            const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "approveBuyerForListing",
                args: [
                    listingId,
                    buyer,
                    true
                ]
            });
            tx.setGasLimitMultiple(1.2);
            return tx;
        } else {
            throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);
        }
    });
    /**
   * Revoke approval of a buyer for a reserved direct listing
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to approve buyer for
   * const listingId = "0";
   *
   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, "{{wallet_address}}");
   * ```
   *
   * @param listingId - The listing id to buy
   * @param buyer - Address of buyer being approved
   */ revokeBuyerApprovalForReservedListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, buyer)=>{
        const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
        if (isApproved) {
            const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "approveBuyerForListing",
                args: [
                    listingId,
                    buyer,
                    false
                ]
            });
            tx.setGasLimitMultiple(1.2);
            return tx;
        } else {
            throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);
        }
    });
    /**
   * Approve a currency for a direct listing
   *
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to approve currency for
   * const listingId = "0";
   *
   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param currencyContractAddress - Address of currency being approved
   * @param pricePerTokenInCurrency - Price per token in the currency
   * @twfeature DirectListings
   */ approveCurrencyForListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, currencyContractAddress, pricePerTokenInCurrency)=>{
        const listing = await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        const resolvedCurrencyAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(currencyContractAddress);
        if (resolvedCurrencyAddress === listing.currencyContractAddress) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pricePerTokenInCurrency === listing.pricePerToken, "Approving listing currency with a different price.");
        }
        const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [
            listingId,
            resolvedCurrencyAddress
        ]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(pricePerTokenInCurrency === currencyPrice, "Currency already approved with this price.");
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [
                listingId,
                resolvedCurrencyAddress,
                pricePerTokenInCurrency
            ]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Revoke approval of a currency for a direct listing
   *
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to revoke currency for
   * const listingId = "0";
   *
   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param currencyContractAddress - Address of currency
   * @twfeature DirectListings
   */ revokeCurrencyApprovalForListing = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listingId, currencyContractAddress)=>{
        const listing = await this.validateListing(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listingId));
        const resolvedCurrencyAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(currencyContractAddress);
        if (resolvedCurrencyAddress === listing.currencyContractAddress) {
            throw new Error(`Can't revoke approval for main listing currency.`);
        }
        const currencyPrice = await this.contractWrapper.read("currencyPriceForListing", [
            listingId,
            resolvedCurrencyAddress
        ]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(!currencyPrice.isZero(), "Currency not approved.");
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "approveCurrencyForListing",
            args: [
                listingId,
                resolvedCurrencyAddress,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0)
            ]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Throws error if listing could not be found
   *
   * @param listingId - Listing to check for
   */ async validateListing(listingId) {
        try {
            return await this.getListing(listingId);
        } catch (err) {
            console.error(`Error getting the listing with id ${listingId}`);
            throw err;
        }
    }
    /**
   * Helper method maps the auction listing to the direct listing interface.
   *
   * @internal
   * @param listing - The listing to map, as returned from the contract.
   * @returns  The mapped interface.
   */ async mapListing(listing) {
        let status = Status.UNSET;
        const block = await this.contractWrapper.getProvider().getBlock("latest");
        const blockTime = block.timestamp;
        switch(listing.status){
            case 1:
                status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listing.startTimestamp).gt(blockTime) ? Status.Created : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
                break;
            case 2:
                status = Status.Completed;
                break;
            case 3:
                status = Status.Cancelled;
                break;
        }
        return {
            assetContractAddress: listing.assetContract,
            currencyContractAddress: listing.currency,
            pricePerToken: listing.pricePerToken.toString(),
            currencyValuePerToken: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),
            id: listing.listingId.toString(),
            tokenId: listing.tokenId.toString(),
            quantity: listing.quantity.toString(),
            startTimeInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listing.startTimestamp).toNumber(),
            asset: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
            endTimeInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(listing.endTimestamp).toNumber(),
            creatorAddress: listing.listingCreator,
            isReservedListing: listing.reserved,
            status: status
        };
    }
    /**
   * Use this method to check if a direct listing is still valid.
   *
   * Ways a direct listing can become invalid:
   * 1. The asset holder transferred the asset to another wallet
   * 2. The asset holder burned the asset
   * 3. The asset holder removed the approval on the marketplace
   *
   * @internal
   * @param listing - The listing to check.
   * @returns  True if the listing is valid, false otherwise.
   */ async isStillValidListing(listing, quantity) {
        const approved = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);
        if (!approved) {
            return {
                valid: false,
                error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
            };
        }
        const provider = this.contractWrapper.getProvider();
        const ERC165Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC165.json (json, async loader)")(__turbopack_context__.i)).default;
        const erc165 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](listing.assetContractAddress, ERC165Abi, provider);
        const isERC721 = await erc165.supportsInterface(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["I"]);
        const isERC1155 = await erc165.supportsInterface(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"]);
        if (isERC721) {
            const ERC721Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json (json, async loader)")(__turbopack_context__.i)).default;
            const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](listing.assetContractAddress, ERC721Abi, provider);
            // Handle reverts in case of non-existent tokens
            let owner;
            try {
                owner = await asset.ownerOf(listing.tokenId);
            } catch (e) {}
            const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();
            return {
                valid,
                error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
            };
        } else if (isERC1155) {
            const ERC1155Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json (json, async loader)")(__turbopack_context__.i)).default;
            const asset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$contracts$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Contract"](listing.assetContractAddress, ERC1155Abi, provider);
            const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);
            const valid = balance.gte(quantity || listing.quantity);
            return {
                valid,
                error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
            };
        } else {
            return {
                valid: false,
                error: "Contract does not implement ERC 1155 or ERC 721."
            };
        }
    }
    async applyFilter(listings, filter) {
        let rawListings = [
            ...listings
        ];
        if (filter) {
            if (filter.seller) {
                const resolvedSeller = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.seller);
                rawListings = rawListings.filter((seller)=>seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
            }
            if (filter.tokenContract) {
                const resolvedToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.tokenContract);
                rawListings = rawListings.filter((tokenContract)=>tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
            }
            if (filter.tokenId !== undefined) {
                rawListings = rawListings.filter((tokenContract)=>tokenContract.tokenId.toString() === filter?.tokenId?.toString());
            }
        }
        return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;
    }
}
/**
 * @internal
 */ const EnglishAuctionInputParamsSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        /**
   * The address of the asset being auctioned.
   */ assetContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"],
        /**
   * The ID of the token to auction.
   */ tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"],
        /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */ quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(1),
        /**
   * The address of the currency to accept for the listing.
   */ currencyContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]),
        /**
   * The minimum price that a bid must be in order to be accepted.
   */ minimumBidAmount: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"],
        /**
   * The buyout price of the auction.
   */ buyoutBidAmount: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"],
        /**
   * This is a buffer e.g. x seconds.
   *
   * If a new winning bid is made less than x seconds before expirationTimestamp, the
   * expirationTimestamp is increased by x seconds.
   */ timeBufferInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(900),
        // 15 minutes by default
        /**
   * This is a buffer in basis points e.g. x%.
   *
   * To be considered as a new winning bid, a bid must be at least x% greater than
   * the current winning bid.
   */ bidBufferBps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(500),
        // 5% by default
        /**
   * The start time of the auction.
   */ startTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["R"].default(new Date()),
        /**
   * The end time of the auction.
   */ endTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"]
    }))();
/**
 * @public
 */ /**
 * Handles auctions
 * @public
 */ class MarketplaceV3EnglishAuctions {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dB"].name;
    // utilities
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        this.encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.interceptor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.estimator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"](this.contractWrapper);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * READ FUNCTIONS
   *******************************/ /**
   * Get the total number of english auctions
   *
   * @returns Returns the total number of auctions created.
   * @public
   *
   * @example
   * ```javascript
   * const totalAuctions = await contract.englishAuctions.getTotalCount();
   * ```
   * @twfeature EnglishAuctions
   */ async getTotalCount() {
        return await this.contractWrapper.read("totalAuctions", []);
    }
    /**
   * Get all english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Auction object array
   * @twfeature EnglishAuctions
   */ async getAll(filter) {
        const totalAuctions = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalAuctions.toNumber();
        if (end === 0) {
            throw new Error(`No auctions exist on the contract.`);
        }
        let rawAuctions = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllAuctions", [
                startId,
                endId
            ]));
        rawAuctions = batches.flat();
        const filteredAuctions = await this.applyFilter(rawAuctions, filter);
        return await Promise.all(filteredAuctions.map((auction)=>this.mapAuction(auction)));
    }
    /**
   * Get all valid english auctions
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Auction object array
   * @twfeature EnglishAuctions
   */ async getAllValid(filter) {
        const totalAuctions = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalAuctions.toNumber();
        if (end === 0) {
            throw new Error(`No auctions exist on the contract.`);
        }
        let rawAuctions = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllValidAuctions", [
                startId,
                endId
            ]));
        rawAuctions = batches.flat();
        const filteredAuctions = await this.applyFilter(rawAuctions, filter);
        return await Promise.all(filteredAuctions.map((auction)=>this.mapAuction(auction)));
    }
    /**
   * Get a single english auction
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const auction = await contract.englishAuctions.getAuction(auctionId);
   * ```
   *
   * @param auctionId - the auction Id
   * @returns The Auction object
   * @twfeature EnglishAuctions
   */ async getAuction(auctionId) {
        const auction = await this.contractWrapper.read("getAuction", [
            auctionId
        ]);
        return await this.mapAuction(auction);
    }
    /**
   * Get winning bid of an english auction
   *
   * @remarks Get the current highest bid of an active auction.
   *
   * @example
   * ```javascript
   * // The ID of the auction
   * const auctionId = 0;
   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @twfeature EnglishAuctions
   */ async getWinningBid(auctionId) {
        await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        const bid = await this.contractWrapper.read("getWinningBid", [
            auctionId
        ]);
        if (bid._bidder === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero) {
            return undefined;
        }
        return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());
    }
    /**
   * Check if a bid is or will be a winning bid
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const bidAmount = 100;
   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);
   * ```
   *
   * @param auctionId - Auction Id
   * @param bidAmount - Amount to bid
   * @returns true if the bid is or will be a winning bid
   * @twfeature EnglishAuctions
   */ async isWinningBid(auctionId, bidAmount) {
        return await this.contractWrapper.read("isNewWinningBid", [
            auctionId,
            bidAmount
        ]);
    }
    /**
   * Get the winner for a specific english auction
   *
   * @remarks Get the winner of the auction after an auction ends.
   *
   * @example
   * ```javascript
   * // The auction ID of a closed english auction
   * const auctionId = 0;
   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);
   * ```
   * @param auctionId - the auction Id
   * @returns The address of the auction winner
   * @twfeature EnglishAuctions
   */ async getWinner(auctionId) {
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        const bid = await this.contractWrapper.read("getWinningBid", [
            auctionId
        ]);
        const now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Math.floor(Date.now() / 1000));
        const endTime = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.endTimeInSeconds);
        // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner
        if (now.gt(endTime) && bid._bidder !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$constants$2f$lib$2e$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__constants$3e$__["constants"].AddressZero) {
            return bid._bidder;
        }
        // otherwise fall back to query filter things
        // TODO this should be via indexer or direct contract call
        const contractEvent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        const closedAuctions = await contractEvent.getEvents("AuctionClosed");
        const closed = closedAuctions.find((a)=>a.data.auctionId.eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId)));
        if (!closed) {
            throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);
        }
        return closed.data.winningBidder;
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Create an english auction
   *
   * @remarks Create a new auction where people can bid on an asset.
   *
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "900", // 15 minutes by default
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "500", // 5% by default
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   * ```
   * @param auction - the auction data
   * @returns The transaction hash and the auction id
   * @twfeature EnglishAuctions
   */ createAuction = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auction)=>{
        const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());
        const normalizedBuyoutAmount = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);
        const normalizedMinBidAmount = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);
        const block = await this.contractWrapper.getProvider().getBlock("latest");
        const blockTime = block.timestamp;
        if (parsedAuction.startTimestamp.lt(blockTime)) {
            parsedAuction.startTimestamp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(blockTime);
        }
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "createAuction",
            args: [
                {
                    assetContract: parsedAuction.assetContractAddress,
                    tokenId: parsedAuction.tokenId,
                    quantity: parsedAuction.quantity,
                    currency: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$cleanCurrencyAddress$2d$ded19cfe$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(parsedAuction.currencyContractAddress),
                    minimumBidAmount: normalizedMinBidAmount,
                    buyoutBidAmount: normalizedBuyoutAmount,
                    timeBufferInSeconds: parsedAuction.timeBufferInSeconds,
                    bidBufferBps: parsedAuction.bidBufferBps,
                    startTimestamp: parsedAuction.startTimestamp,
                    endTimestamp: parsedAuction.endTimestamp
                }
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("NewAuction", receipt.logs)[0];
                return {
                    id: event.args.auctionId,
                    receipt
                };
            }
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Create a batch of new auctions
   *
   * @remarks Create a batch of new auctions on the marketplace
   *
   * @example
   * ```javascript
   * const auctions = [...];
   * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);
   * ```
   */ createAuctionsBatch = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (listings)=>{
        const data = (await Promise.all(listings.map((listing)=>this.createAuction.prepare(listing)))).map((tx)=>tx.encode());
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "multicall",
            args: [
                data
            ],
            parse: (receipt)=>{
                const events = this.contractWrapper.parseLogs("NewAuction", receipt?.logs);
                return events.map((event)=>{
                    return {
                        id: event.args.auctionId,
                        receipt
                    };
                });
            }
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Buyout an english auction
   *
   * @remarks Buy a specific auction from the marketplace.
   *
   * @example
   * ```javascript
   * // The auction ID you want to buy
   * const auctionId = 0;
   *
   * await contract.englishAuctions.buyoutAuction(auctionId);
   * ```
   * @param auctionId - the auction id
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ buyoutAuction = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId)=>{
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        const currencyMetadata = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(this.contractWrapper.getProvider(), auction.currencyContractAddress);
        return this.makeBid.prepare(auctionId, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__utils$3e$__["utils"].formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));
    });
    /**
   * Bid on an english auction
   *
   * @remarks Make a bid on an auction
   *
   * @example
   * ```javascript
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   * @param auctionId - the auction id
   * @param bidAmount - the amount you are willing to bid
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ makeBid = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId, bidAmount)=>{
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        const normalizedBidAmount = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);
        if (normalizedBidAmount.eq(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(0))) {
            throw new Error("Cannot make a bid with 0 value");
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {
            throw new Error("Bid amount must be less than or equal to buyoutBidAmount");
        }
        const winningBid = await this.getWinningBid(auctionId);
        if (winningBid) {
            const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
        } else {
            const tokenPrice = normalizedBidAmount;
            const minimumBidAmount = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.minimumBidAmount);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(tokenPrice.gte(minimumBidAmount), "Bid price is too low based on minimum bid amount");
        }
        const overrides = await this.contractWrapper.getCallOverrides() || {};
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "bidInAuction",
            overrides,
            args: [
                auctionId,
                normalizedBidAmount
            ]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Cancel an english auction
   *
   * @remarks Cancel an auction on the marketplace
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to cancel
   * const auctionId = "0";
   *
   * await contract.englishAuctions.cancelAuction(auctionId);
   * ```
   * @param auctionId - the auction id
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ cancelAuction = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId)=>{
        const winningBid = await this.getWinningBid(auctionId);
        if (winningBid) {
            throw new Error(`Bids already made.`);
        }
        const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "cancelAuction",
            args: [
                auctionId
            ]
        });
        tx.setGasLimitMultiple(1.2);
        return tx;
    });
    /**
   * Close the english auction for the bidder
   *
   * @remarks Closes the Auction and executes the sale for the buyer.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auction = "0";
   * await contract.englishAuctions.closeAuctionForBidder(auctionId);
   * ```
   *
   * @param auctionId - the auction id to close
   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ closeAuctionForBidder = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId, closeFor)=>{
        if (!closeFor) {
            closeFor = await this.contractWrapper.getSignerAddress();
        }
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        try {
            const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "collectAuctionTokens",
                args: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId)
                ]
            });
            tx.setGasLimitMultiple(1.2);
            return tx;
        } catch (err) {
            if (err.message.includes("Marketplace: auction still active.")) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["w"](auctionId.toString(), auction.endTimeInSeconds.toString());
            } else {
                throw err;
            }
        }
    });
    /**
   * Close the english auction for the seller
   *
   * @remarks Closes the Auction and executes the sale for the seller.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auctionId = "0";
   * await contract.englishAuctions.closeAuctionForSeller(auctionId);
   * ```
   *
   * @param auctionId - the auction id to close
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ closeAuctionForSeller = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId)=>{
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        try {
            const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "collectAuctionPayout",
                args: [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId)
                ]
            });
            tx.setGasLimitMultiple(1.2);
            return tx;
        } catch (err) {
            if (err.message.includes("Marketplace: auction still active.")) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["w"](auctionId.toString(), auction.endTimeInSeconds.toString());
            } else {
                throw err;
            }
        }
    });
    /**
   * Close the english auction for both the seller and the bidder
   *
   * @remarks Closes the Auction and executes the sale for both parties.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auction = "0";
   * await contract.englishAuctions.executeSale(auctionId);
   * ```
   *
   * @param auctionId - the auction to close
   * @returns The transaction result
   * @twfeature EnglishAuctions
   */ executeSale = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (auctionId)=>{
        const auction = await this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId));
        try {
            const winningBid = await this.getWinningBid(auctionId);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(winningBid, "No winning bid found");
            const closeForSeller = this.encoder.encode("collectAuctionPayout", [
                auctionId
            ]);
            const closeForBuyer = this.encoder.encode("collectAuctionTokens", [
                auctionId
            ]);
            const tx = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
                contractWrapper: this.contractWrapper,
                method: "multicall",
                args: [
                    [
                        closeForSeller,
                        closeForBuyer
                    ]
                ]
            });
            tx.setGasLimitMultiple(1.2);
            return tx;
        } catch (err) {
            if (err.message.includes("Marketplace: auction still active.")) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["w"](auctionId.toString(), auction.endTimeInSeconds.toString());
            } else {
                throw err;
            }
        }
    });
    /**
   * Get the buffer for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the buffer for
   * const auctionId = "0";
   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);
   * ```
   *
   * @param auctionId - id of the auction
   * @returns The buffer in basis points
   * @twfeature EnglishAuctions
   */ async getBidBufferBps(auctionId) {
        return (await this.getAuction(auctionId)).bidBufferBps;
    }
    /**
   * Get the minimum next bid for an english auction
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to get the minimum next bid for
   * const auctionId = "0";
   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);
   * ```
   *
   * @returns The minimum bid a user can place to outbid the previous highest bid
   * @param auctionId - id of the auction
   * @twfeature EnglishAuctions
   */ async getMinimumNextBid(auctionId) {
        // we can fetch all of these at the same time using promise.all
        const [currentBidBufferBps, winningBid, auction] = await Promise.all([
            this.getBidBufferBps(auctionId),
            this.getWinningBid(auctionId),
            this.validateAuction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auctionId))
        ]);
        const currentBidOrReservePrice = winningBid ? // if there is a winning bid use the value of it
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(winningBid.bidAmount) : // if there is no winning bid use the reserve price
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.minimumBidAmount);
        const minimumNextBid = currentBidOrReservePrice.add(// the addition of the current bid and the buffer
        // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))
        currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));
        // it's more useful to return a currency value here
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);
    }
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Throws error if auction could not be found
   *
   * @param auctionId - Auction to check for
   */ async validateAuction(auctionId) {
        try {
            return await this.getAuction(auctionId);
        } catch (err) {
            console.error(`Error getting the auction with id ${auctionId}`);
            throw err;
        }
    }
    /**
   * Helper method maps the auction to the auction interface.
   *
   * @internal
   * @param auction - The auction to map, as returned from the contract.
   * @returns  The mapped interface.
   */ async mapAuction(auction) {
        let status = Status.UNSET;
        const block = await this.contractWrapper.getProvider().getBlock("latest");
        const blockTime = block.timestamp;
        switch(auction.status){
            case 1:
                status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.startTimestamp).gt(blockTime) ? Status.Created : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
                break;
            case 2:
                status = Status.Completed;
                break;
            case 3:
                status = Status.Cancelled;
                break;
        }
        return {
            id: auction.auctionId.toString(),
            creatorAddress: auction.auctionCreator,
            assetContractAddress: auction.assetContract,
            tokenId: auction.tokenId.toString(),
            quantity: auction.quantity.toString(),
            currencyContractAddress: auction.currency,
            minimumBidAmount: auction.minimumBidAmount.toString(),
            minimumBidCurrencyValue: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),
            buyoutBidAmount: auction.buyoutBidAmount.toString(),
            buyoutCurrencyValue: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),
            timeBufferInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.timeBufferInSeconds).toNumber(),
            bidBufferBps: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.bidBufferBps).toNumber(),
            startTimeInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.startTimestamp).toNumber(),
            endTimeInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(auction.endTimestamp).toNumber(),
            asset: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),
            status: status
        };
    }
    /**
   * Maps an auction-bid to the strict interface
   *
   * @internal
   * @param bid - The bid to map, as returned from the contract.
   * @returns  A `Bid` object
   */ async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {
        const resolvedBidderAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(bidderAddress);
        const resolvedCurrencyAddress = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(currencyContractAddress);
        return {
            auctionId,
            bidderAddress: resolvedBidderAddress,
            currencyContractAddress: resolvedCurrencyAddress,
            bidAmount,
            bidAmountCurrencyValue: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)
        };
    }
    async applyFilter(auctions, filter) {
        let rawAuctions = [
            ...auctions
        ];
        if (filter) {
            if (filter.seller) {
                const resolvedSeller = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.seller);
                rawAuctions = rawAuctions.filter((seller)=>seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());
            }
            if (filter.tokenContract) {
                const resolvedToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.tokenContract);
                rawAuctions = rawAuctions.filter((tokenContract)=>tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
            }
            if (filter.tokenId !== undefined) {
                rawAuctions = rawAuctions.filter((tokenContract)=>tokenContract.tokenId.toString() === filter?.tokenId?.toString());
            }
        }
        return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;
    }
}
/**
 * @internal
 */ const OfferInputParamsSchema = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$v3$2f$external$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        /**
   * The address of the asset being sought.
   */ assetContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"],
        /**
   * The ID of the token.
   */ tokenId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"],
        /**
   * The quantity of tokens to buy.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */ quantity: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b6"].default(1),
        /**
   * The address of the currency offered for the NFTs.
   */ currencyContractAddress: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b9"].default(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aV"]),
        /**
   * The total offer amount for the NFTs.
   */ totalPrice: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cw"],
        /**
   * The end time of the offer.
   */ endTimestamp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"]
    }))();
/**
 * @public
 */ /**
 * Handles marketplace offers
 * @public
 */ class MarketplaceV3Offers {
    featureName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dC"].name;
    // utilities
    constructor(contractWrapper, storage){
        this.contractWrapper = contractWrapper;
        this.storage = storage;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        this.encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.interceptor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.estimator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"](this.contractWrapper);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /** ******************************
   * READ FUNCTIONS
   *******************************/ /**
   * Get the total number of offers
   *
   * @returns Returns the total number of offers created.
   * @public
   *
   * @example
   * ```javascript
   * const totalOffers = await contract.offers.getTotalCount();
   * ```
   * @twfeature Offers
   */ async getTotalCount() {
        return await this.contractWrapper.read("totalOffers", []);
    }
    /**
   * Get all offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Offer object array
   * @twfeature Offers
   */ async getAll(filter) {
        const totalOffers = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalOffers.toNumber();
        if (end === 0) {
            throw new Error(`No offers exist on the contract.`);
        }
        let rawOffers = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllOffers", [
                startId,
                endId
            ]));
        rawOffers = batches.flat();
        const filteredOffers = await this.applyFilter(rawOffers, filter);
        return await Promise.all(filteredOffers.map((offer)=>this.mapOffer(offer)));
    }
    /**
   * Get all valid offers
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns The Offer object array
   * @twfeature Offers
   */ async getAllValid(filter) {
        const totalOffers = await this.getTotalCount();
        const start = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(filter?.start || 0).toNumber();
        const end = totalOffers.toNumber();
        if (end === 0) {
            throw new Error(`No offers exist on the contract.`);
        }
        let rawOffers = [];
        const batches = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["g"])(start, end, (startId, endId)=>this.contractWrapper.read("getAllValidOffers", [
                startId,
                endId
            ]));
        rawOffers = batches.flat();
        const filteredOffers = await this.applyFilter(rawOffers, filter);
        return await Promise.all(filteredOffers.map((offer)=>this.mapOffer(offer)));
    }
    /**
   * Get a single offer
   *
   * @example
   * ```javascript
   * const offerId = 0;
   * const offer = await contract.offers.getOffer(offerId);
   * ```
   *
   * @param offerId - the listing id
   * @returns The Direct listing object
   * @twfeature Offers
   */ async getOffer(offerId) {
        const offer = await this.contractWrapper.read("getOffer", [
            offerId
        ]);
        return await this.mapOffer(offer);
    }
    /** ******************************
   * WRITE FUNCTIONS
   *******************************/ /**
   * Make an offer
   *
   * @remarks Make an offer on the marketplace for an asset.
   *
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   * ```
   * @param offer - the offer data
   * @returns The transaction receipt and the id of the newly created offer
   * @twfeature Offers
   */ makeOffer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (offer)=>{
        const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);
        const chainId = await this.contractWrapper.getChainID();
        const currency = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(parsedOffer.currencyContractAddress) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aW"][chainId].wrapped.address : parsedOffer.currencyContractAddress;
        const normalizedTotalPrice = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$normalizePriceValue$2d$9851c0eb$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);
        const overrides = await this.contractWrapper.getCallOverrides();
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$setErc20Allowance$2d$7f76f677$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(this.contractWrapper, normalizedTotalPrice, currency, overrides);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "makeOffer",
            args: [
                {
                    assetContract: parsedOffer.assetContractAddress,
                    tokenId: parsedOffer.tokenId,
                    quantity: parsedOffer.quantity,
                    currency: currency,
                    totalPrice: normalizedTotalPrice,
                    expirationTimestamp: parsedOffer.endTimestamp
                }
            ],
            parse: (receipt)=>{
                const event = this.contractWrapper.parseLogs("NewOffer", receipt?.logs);
                return {
                    id: event[0].args.offerId,
                    receipt
                };
            }
        });
    });
    /**
   * Cancel an offer
   *
   * @remarks Cancel an offer on the marketplace
   *
   * @example
   * ```javascript
   * // The ID of the offer you want to cancel
   * const offerId = "0";
   *
   * await contract.offers.cancelOffer(offerId);
   * ```
   * @param offerId - the offer id
   * @returns The transaction receipt
   * @twfeature Offers
   */ cancelOffer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (offerId)=>{
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "cancelOffer",
            args: [
                offerId
            ]
        });
    });
    /**
   * Accept an offer
   *
   * @example
   * ```javascript
   * // The ID of the offer you want to accept
   * const offerId = 0;
   *
   * await contract.offers.acceptOffer(offerId);
   * ```
   *
   * @param offerId - The offer id
   * @returns The transaction receipt
   * @twfeature Offers
   */ acceptOffer = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(async (offerId)=>{
        const offer = await this.validateOffer(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(offerId));
        const { valid, error } = await this.isStillValidOffer(offer);
        if (!valid) {
            throw new Error(`Offer ${offerId} is no longer valid. ${error}`);
        }
        const overrides = await this.contractWrapper.getCallOverrides() || {};
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplace$2d$e3129e2f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["h"])(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method: "acceptOffer",
            args: [
                offerId
            ],
            overrides
        });
    });
    /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/ /**
   * Throws error if offer could not be found
   *
   * @param offerId - offer to check for
   */ async validateOffer(offerId) {
        try {
            return await this.getOffer(offerId);
        } catch (err) {
            console.error(`Error getting the offer with id ${offerId}`);
            throw err;
        }
    }
    /**
   * Helper method maps the offer to the offer interface.
   *
   * @internal
   * @param offer - The offer to map, as returned from the contract.
   * @returns  The mapped interface.
   */ async mapOffer(offer) {
        let status = Status.UNSET;
        const block = await this.contractWrapper.getProvider().getBlock("latest");
        const blockTime = block.timestamp;
        switch(offer.status){
            case 1:
                status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;
                break;
            case 2:
                status = Status.Completed;
                break;
            case 3:
                status = Status.Cancelled;
                break;
        }
        return {
            id: offer.offerId.toString(),
            offerorAddress: offer.offeror,
            assetContractAddress: offer.assetContract,
            currencyContractAddress: offer.currency,
            tokenId: offer.tokenId.toString(),
            quantity: offer.quantity.toString(),
            totalPrice: offer.totalPrice.toString(),
            currencyValue: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),
            asset: await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$QueryParams$2d$32a56510$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),
            endTimeInSeconds: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(offer.expirationTimestamp).toNumber(),
            status: status
        };
    }
    /**
   * Use this method to check if an offer is still valid.
   *
   * Ways an offer can become invalid:
   * 1. The offer has expired
   * 2. The offeror doesn't have enough balance of currency tokens
   * 3. The offeror removed the approval of currency tokens on the marketplace
   *
   * @internal
   * @param offer - The offer to check.
   * @returns  True if the offer is valid, false otherwise.
   */ async isStillValidOffer(offer) {
        const now = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ethersproject$2f$bignumber$2f$lib$2e$esm$2f$bignumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BigNumber"].from(Math.floor(Date.now() / 1000));
        if (now.gt(offer.endTimeInSeconds)) {
            return {
                valid: false,
                error: `Offer with ID ${offer.id} has expired`
            };
        }
        const chainId = await this.contractWrapper.getChainID();
        const currency = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["i"])(offer.currencyContractAddress) ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aW"][chainId].wrapped.address : offer.currencyContractAddress;
        const provider = this.contractWrapper.getProvider();
        const ERC20Abi = (await __turbopack_context__.r("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json (json, async loader)")(__turbopack_context__.i)).default;
        const erc20 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](provider, currency, ERC20Abi, {}, this.storage);
        const offerorBalance = await erc20.read("balanceOf", [
            offer.offerorAddress
        ]);
        if (offerorBalance.lt(offer.totalPrice)) {
            return {
                valid: false,
                error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`
            };
        }
        const offerorAllowance = await erc20.read("allowance", [
            offer.offerorAddress,
            this.getAddress()
        ]);
        if (offerorAllowance.lt(offer.totalPrice)) {
            return {
                valid: false,
                error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`
            };
        }
        return {
            valid: true,
            error: ""
        };
    }
    async applyFilter(offers, filter) {
        let rawOffers = [
            ...offers
        ];
        if (filter) {
            if (filter.offeror) {
                const resolvedOfferor = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.offeror);
                rawOffers = rawOffers.filter((offeror)=>offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());
            }
            if (filter.tokenContract) {
                const resolvedToken = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aL"])(filter.tokenContract);
                rawOffers = rawOffers.filter((tokenContract)=>tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());
            }
            if (filter.tokenId !== undefined) {
                rawOffers = rawOffers.filter((tokenContract)=>tokenContract.tokenId.toString() === filter?.tokenId?.toString());
            }
        }
        return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;
    }
}
;
}}),
"[project]/node_modules/@thirdweb-dev/sdk/dist/smart-contract-ac432d60.browser.esm.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "SmartContract": (()=>SmartContract)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/assertEnabled-d1700f0b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-appuri-5c40af52.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/index-33cd3415.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/airdrop-erc1155-f9016b81.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/fetchCurrencyValue-32d08b05.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-interceptor-d7b164a7.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-owner-49e75547.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$platform$2d$fee$2d$e756e68f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-platform-fee-e756e68f.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$roles$2d$71988d2e$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-roles-71988d2e.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$sales$2d$918c7cb8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/contract-sales-918c7cb8.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$1155$2d$7ce9bee1$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/erc-1155-7ce9bee1.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$20$2d$9a18a51c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/erc-20-9a18a51c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$721$2d$27306550$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/erc-721-27306550.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplacev3$2d$offers$2d$ce1f096b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/marketplacev3-offers-ce1f096b.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/sdk/dist/transactions-72f9603c.browser.esm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tiny$2d$invariant$2f$dist$2f$esm$2f$tiny$2d$invariant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tiny-invariant/dist/esm/tiny-invariant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bn.js/lib/bn.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IBurnableERC20$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDrop$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropERC20_V2$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropSinglePhase$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropSinglePhase_V1$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC20$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC20Permit$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IMintableERC20$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IMulticall$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IMulticall.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ISignatureMintERC20$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC20Metadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IBurnableERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IClaimableERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDelayedReveal$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropERC721_V3$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC721Enumerable$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC721AQueryableUpgradeable$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC721Supply$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ILazyMint$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IMintableERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ISignatureMintERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ISignatureMintERC721_V1$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$LazyMintWithTier_V1$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier_V1.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$SharedMetadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$zora_IERC721Drop$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ILoyaltyCard$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$INFTMetadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC721Metadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IBurnableERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IClaimableERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDrop1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropERC1155_V2$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropSinglePhase1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDropSinglePhase1155_V1$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC1155Metadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC1155Supply$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC1155Enumerable$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IMintableERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$ISignatureMintERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IERC2771Context$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAppURI$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAppURI.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IContractMetadata$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IDirectListings$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IEnglishAuctions$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IOffers$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IOffers.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IPackVRFDirect$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IPermissions$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissions.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IPermissionsEnumerable$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IPlatformFee$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IPrimarySale$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IRoyalty$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$Ownable$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/Ownable.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAirdropERC20$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAirdropERC721$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAirdropERC1155$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAccountFactoryCore$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAccountPermissions$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAccountPermissions_V1$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions_V1.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$contracts$2d$js$2f$dist$2f$abis$2f$IAccount$2e$json__$28$json$29$__ = __turbopack_context__.i("[project]/node_modules/@thirdweb-dev/contracts-js/dist/abis/IAccount.json (json)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$deep$2d$equal$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * Custom contract dynamic class with feature detection
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@thirdweb-dev/sdk";
 *
 * const sdk = new ThirdwebSDK(provider);
 * const contract = await sdk.getContract("{{contract_address}}");
 *
 * // call any function in your contract
 * await contract.call("myCustomFunction", [param1, param2]);
 *
 * // if your contract follows an ERC standard, contract.ercXYZ will be present
 * const allNFTs = await contract.erc721.getAll()
 *
 * // if your contract extends a particular contract extension, the corresponding function will be available
 * const tx = await contract.erc721.mint({
 *     name: "Cool NFT",
 *     image: readFileSync("some_image.png"),
 *   });
 * ```
 *
 * @contract
 * @public
 */ class SmartContract {
    // utilities
    get abi() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bj"].parse(this.contractWrapper.abi || []);
    }
    /**
   * Handle royalties
   */ get royalties() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectRoyalties(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d5"]);
    }
    /**
   * Handle permissions
   */ get roles() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectRoles(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d4"]);
    }
    /**
   * Handle primary sales
   */ get sales() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectPrimarySales(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d7"]);
    }
    /**
   * Handle platform fees
   */ get platformFees() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectPlatformFees(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["du"]);
    }
    /**
   * Set and get the owner of the contract
   */ get owner() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectOwnable(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d6"]);
    }
    /**
   * Auto-detects ERC20 standard functions.
   */ get erc20() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectErc20(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cI"]);
    }
    /**
   * Auto-detects ERC721 standard functions.
   */ get erc721() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectErc721(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c$"]);
    }
    /**
   * Auto-detects ERC1155 standard functions.
   */ get erc1155() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectErc1155(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dj"]);
    }
    /**
   * Auto-detects AppURI standard functions.
   */ get app() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectApp(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cK"]);
    }
    /**
   * Direct listings
   * @remarks Create and manage direct listings in your marketplace.
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   *
   * // And on the buyers side:
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired);
   * ```
   */ get directListings() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectDirectListings(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dA"]);
    }
    /**
   * Auctions
   * @remarks Create and manage auctions in your marketplace.
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "1000",
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "100", // 100 bps stands for 1%
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   *
   * // And on the buyers side:
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   */ get englishAuctions() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectEnglishAuctions(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dB"]);
    }
    /**
   * Offers
   * @remarks Make and manage offers.
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   *
   * // And on the seller's side:
   * // The ID of the offer you want to accept
   * const offerId = 0;
   * await contract.offers.acceptOffer(offerId);
   * ```
   */ get offers() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectOffers(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dC"]);
    }
    get airdrop20() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectAirdrop20(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dr"]);
    }
    get airdrop721() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectAirdrop721(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ds"]);
    }
    get airdrop1155() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectAirdrop1155(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dt"]);
    }
    /**
   * Account Factory
   *
   * @remarks Create accounts and fetch data about them.
   * @example
   * ```javascript
   *
   * // Predict the address of the account that will be created for an admin.
   * const deterministicAddress = await contract.accountFactory.predictAccountAddress(admin, extraData);
   *
   * // Create accounts
   * const tx = await contract.accountFactory.createAccount(admin, extraData);
   * // the same as `deterministicAddress`
   * const accountAddress = tx.address;
   *
   * // Get all accounts created by the factory
   * const allAccounts = await contract.accountFactory.getAllAccounts();
   *
   * // Get all accounts on which a signer has been given authority.
   * const associatedAccounts = await contract.accountFactory.getAssociatedAccounts(signer);
   *
   * // Get all signers who have been given authority on a account.
   * const associatedSigners = await contract.accountFactory.getAssociatedSigners(accountAddress);
   *
   * // Check whether a account has already been created for a given admin.
   * const isAccountDeployed = await contract.accountFactory.isAccountDeployed(admin, extraData);
   * ```
   */ get accountFactory() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectAccountFactory(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dp"]);
    }
    // TODO documentation
    get account() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectAccount(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dn"]);
    }
    get extensions() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$assertEnabled$2d$d1700f0b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(this.detectBaseRouter(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dq"]);
    }
    get chainId() {
        return this._chainId;
    }
    constructor(network, address, abi, storage){
        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
        let chainId = arguments.length > 5 ? arguments[5] : undefined;
        let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cs"](network, address, abi, options, storage);
        this._chainId = chainId;
        this.storage = storage;
        this.contractWrapper = contractWrapper;
        this.events = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        this.encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$fetchCurrencyValue$2d$32d08b05$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.interceptor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$interceptor$2d$d7b164a7$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        this.estimator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"](this.contractWrapper);
        this.publishedMetadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, this.storage);
        this.metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
    }
    onNetworkUpdated(network) {
        this.contractWrapper.updateSignerOrProvider(network);
    }
    getAddress() {
        return this.contractWrapper.address;
    }
    /**
   * Prepare a transaction for sending
   */ prepare(method, args, overrides) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$transactions$2d$72f9603c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["T"].fromContractWrapper({
            contractWrapper: this.contractWrapper,
            method,
            args,
            overrides
        });
    }
    /**
   * Call any function on this contract
   * @example
   * ```javascript
   * // read functions will return the data from the contract
   * const myValue = await contract.call("myReadFunction");
   * console.log(myValue);
   *
   * // write functions will return the transaction receipt
   * const tx = await contract.call("myWriteFunction", [arg1, arg2]);
   * const receipt = tx.receipt;
   *
   * // Optionally override transaction options
   * await contract.call("myWriteFunction", [arg1, arg2], {
   *  gasLimit: 1000000, // override default gas limit
   *  value: ethers.utils.parseEther("0.1"), // send 0.1 ether with the contract call
   * };
   * ```
   * @param functionName - the name of the function to call
   * @param args - the arguments of the function
   */ async call(functionName, args, overrides) {
        return this.contractWrapper.call(functionName, args, overrides);
    }
    /** ********************
   * FEATURE DETECTION
   * ********************/ detectRoyalties() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "Royalty")) {
            // ContractMetadata is stateless, it's fine to create a new one here
            // This also makes it not order dependent in the feature detection process
            const metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, metadata);
        }
        return undefined;
    }
    detectRoles() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "Permissions")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$roles$2d$71988d2e$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["G"]);
        }
        return undefined;
    }
    detectPrimarySales() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "PrimarySale")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$sales$2d$918c7cb8$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        }
        return undefined;
    }
    detectPlatformFees() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "PlatformFee")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$platform$2d$fee$2d$e756e68f$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper);
        }
        return undefined;
    }
    detectErc20() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC20")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$20$2d$9a18a51c$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"](this.contractWrapper, this.storage, this.chainId);
        }
        return undefined;
    }
    detectErc721() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC721")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$721$2d$27306550$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"](this.contractWrapper, this.storage, this.chainId);
        }
        return undefined;
    }
    detectErc1155() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ERC1155")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$erc$2d$1155$2d$7ce9bee1$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"](this.contractWrapper, this.storage, this.chainId);
        }
        return undefined;
    }
    detectOwnable() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "Ownable")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$owner$2d$49e75547$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        }
        return undefined;
    }
    detectApp() {
        const metadata = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["C"](this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bg"], this.storage);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AppURI")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"](this.contractWrapper, metadata, this.storage);
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "ContractMetadata")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"](this.contractWrapper, metadata, this.storage);
        }
        return undefined;
    }
    detectDirectListings() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "DirectListings")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplacev3$2d$offers$2d$ce1f096b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["M"](this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectEnglishAuctions() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "EnglishAuctions")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplacev3$2d$offers$2d$ce1f096b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectOffers() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "Offers")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$marketplacev3$2d$offers$2d$ce1f096b$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"](this.contractWrapper, this.storage);
        }
        return undefined;
    }
    detectBaseRouter() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dq"].name)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["E"](this.contractWrapper);
        }
        return undefined;
    }
    detectAirdrop20() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AirdropERC20")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"](this.contractWrapper);
        }
        return undefined;
    }
    detectAirdrop721() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AirdropERC721")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"](this.contractWrapper);
        }
        return undefined;
    }
    detectAirdrop1155() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, "AirdropERC1155")) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"](this.contractWrapper);
        }
        return undefined;
    }
    // ========== Account features ==========
    detectAccountFactory() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dp"].name)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"](this.contractWrapper);
        }
        return undefined;
    }
    detectAccount() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$contract$2d$appuri$2d$5c40af52$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(this.contractWrapper, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$index$2d$33cd3415$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dn"].name)) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$thirdweb$2d$dev$2f$sdk$2f$dist$2f$airdrop$2d$erc1155$2d$f9016b81$2e$browser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["A"](this.contractWrapper);
        }
        return undefined;
    }
}
;
}}),
}]);

//# sourceMappingURL=node_modules_db7db69d._.js.map