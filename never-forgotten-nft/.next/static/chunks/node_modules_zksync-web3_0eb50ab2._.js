(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/zksync-web3/build/src/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AccountNonceOrdering = exports.AccountAbstractionVersion = exports.TransactionStatus = exports.PriorityOpTree = exports.PriorityQueueType = exports.Network = void 0;
// Ethereum network
var Network;
(function(Network) {
    Network[Network["Mainnet"] = 1] = "Mainnet";
    Network[Network["Ropsten"] = 3] = "Ropsten";
    Network[Network["Rinkeby"] = 4] = "Rinkeby";
    Network[Network["Goerli"] = 5] = "Goerli";
    Network[Network["Localhost"] = 9] = "Localhost";
})(Network = exports.Network || (exports.Network = {}));
var PriorityQueueType;
(function(PriorityQueueType) {
    PriorityQueueType[PriorityQueueType["Deque"] = 0] = "Deque";
    PriorityQueueType[PriorityQueueType["HeapBuffer"] = 1] = "HeapBuffer";
    PriorityQueueType[PriorityQueueType["Heap"] = 2] = "Heap";
})(PriorityQueueType = exports.PriorityQueueType || (exports.PriorityQueueType = {}));
var PriorityOpTree;
(function(PriorityOpTree) {
    PriorityOpTree[PriorityOpTree["Full"] = 0] = "Full";
    PriorityOpTree[PriorityOpTree["Rollup"] = 1] = "Rollup";
})(PriorityOpTree = exports.PriorityOpTree || (exports.PriorityOpTree = {}));
var TransactionStatus;
(function(TransactionStatus) {
    TransactionStatus["NotFound"] = "not-found";
    TransactionStatus["Processing"] = "processing";
    TransactionStatus["Committed"] = "committed";
    TransactionStatus["Finalized"] = "finalized";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
var AccountAbstractionVersion;
(function(AccountAbstractionVersion) {
    AccountAbstractionVersion[AccountAbstractionVersion["None"] = 0] = "None";
    AccountAbstractionVersion[AccountAbstractionVersion["Version1"] = 1] = "Version1";
})(AccountAbstractionVersion = exports.AccountAbstractionVersion || (exports.AccountAbstractionVersion = {}));
var AccountNonceOrdering;
(function(AccountNonceOrdering) {
    AccountNonceOrdering[AccountNonceOrdering["Sequential"] = 0] = "Sequential";
    AccountNonceOrdering[AccountNonceOrdering["Arbitrary"] = 1] = "Arbitrary";
})(AccountNonceOrdering = exports.AccountNonceOrdering || (exports.AccountNonceOrdering = {}));
}}),
"[project]/node_modules/zksync-web3/build/typechain/IZkSyncFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IZkSyncFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IZkSyncFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IZkSyncFactory = IZkSyncFactory;
const _abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
            }
        ],
        name: "BlockCommit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "blockNumber",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "blockHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "commitment",
                type: "bytes32"
            }
        ],
        name: "BlockExecution",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksCommitted",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksVerified",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "totalBlocksExecuted",
                type: "uint256"
            }
        ],
        name: "BlocksRevert",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "previousLastVerifiedBlock",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "currentLastVerifiedBlock",
                type: "uint256"
            }
        ],
        name: "BlocksVerification",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32"
            }
        ],
        name: "CancelUpgradeProposal",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "EthWithdrawalFinalized",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32"
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "proposalSalt",
                type: "bytes32"
            }
        ],
        name: "ExecuteUpgrade",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [],
        name: "Freeze",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "bool",
                name: "isPorterAvailable",
                type: "bool"
            }
        ],
        name: "IsPorterAvailableStatusUpdate",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldGovernor",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "newGovernor",
                type: "address"
            }
        ],
        name: "NewGovernor",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousBytecodeHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newBytecodeHash",
                type: "bytes32"
            }
        ],
        name: "NewL2BootloaderBytecodeHash",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "bytes32",
                name: "previousBytecodeHash",
                type: "bytes32"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "newBytecodeHash",
                type: "bytes32"
            }
        ],
        name: "NewL2DefaultAccountBytecodeHash",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldPendingGovernor",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "newPendingGovernor",
                type: "address"
            }
        ],
        name: "NewPendingGovernor",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "txId",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32"
            },
            {
                indexed: false,
                internalType: "uint64",
                name: "expirationTimestamp",
                type: "uint64"
            },
            {
                components: [
                    {
                        internalType: "uint256",
                        name: "txType",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "from",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "to",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "gasLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "gasPerPubdataByteLimit",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "maxPriorityFeePerGas",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "paymaster",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "nonce",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256",
                        name: "value",
                        type: "uint256"
                    },
                    {
                        internalType: "uint256[4]",
                        name: "reserved",
                        type: "uint256[4]"
                    },
                    {
                        internalType: "bytes",
                        name: "data",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "signature",
                        type: "bytes"
                    },
                    {
                        internalType: "uint256[]",
                        name: "factoryDeps",
                        type: "uint256[]"
                    },
                    {
                        internalType: "bytes",
                        name: "paymasterInput",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "reservedDynamic",
                        type: "bytes"
                    }
                ],
                indexed: false,
                internalType: "struct IMailbox.L2CanonicalTransaction",
                name: "transaction",
                type: "tuple"
            },
            {
                indexed: false,
                internalType: "bytes[]",
                name: "factoryDeps",
                type: "bytes[]"
            }
        ],
        name: "NewPriorityRequest",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "oldPriorityTxMaxGasLimit",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "newPriorityTxMaxGasLimit",
                type: "uint256"
            }
        ],
        name: "NewPriorityTxMaxGasLimit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "oldVerifier",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "newVerifier",
                type: "address"
            }
        ],
        name: "NewVerifier",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32"
                    }
                ],
                indexed: false,
                internalType: "struct VerifierParams",
                name: "oldVerifierParams",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32"
                    }
                ],
                indexed: false,
                internalType: "struct VerifierParams",
                name: "newVerifierParams",
                type: "tuple"
            }
        ],
        name: "NewVerifierParams",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32"
            }
        ],
        name: "ProposeShadowUpgrade",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address"
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8"
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool"
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]"
                            }
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]"
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes"
                    }
                ],
                indexed: false,
                internalType: "struct Diamond.DiamondCutData",
                name: "diamondCut",
                type: "tuple"
            },
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
            },
            {
                indexed: false,
                internalType: "bytes32",
                name: "proposalSalt",
                type: "bytes32"
            }
        ],
        name: "ProposeTransparentUpgrade",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "uint256",
                name: "proposalId",
                type: "uint256"
            },
            {
                indexed: true,
                internalType: "bytes32",
                name: "proposalHash",
                type: "bytes32"
            }
        ],
        name: "SecurityCouncilUpgradeApprove",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [],
        name: "Unfreeze",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "validatorAddress",
                type: "address"
            },
            {
                indexed: false,
                internalType: "bool",
                name: "isActive",
                type: "bool"
            }
        ],
        name: "ValidatorStatusUpdate",
        type: "event"
    },
    {
        inputs: [],
        name: "acceptGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_proposedUpgradeHash",
                type: "bytes32"
            }
        ],
        name: "cancelUpgradeProposal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64"
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64"
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32"
                    }
                ],
                internalType: "struct IExecutor.StoredBlockInfo",
                name: "_lastCommittedBlockData",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64"
                    },
                    {
                        internalType: "uint64",
                        name: "timestamp",
                        type: "uint64"
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64"
                    },
                    {
                        internalType: "bytes32",
                        name: "newStateRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes",
                        name: "initialStorageChanges",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "repeatedStorageChanges",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes",
                        name: "l2Logs",
                        type: "bytes"
                    },
                    {
                        internalType: "bytes[]",
                        name: "l2ArbitraryLengthMessages",
                        type: "bytes[]"
                    },
                    {
                        internalType: "bytes[]",
                        name: "factoryDeps",
                        type: "bytes[]"
                    }
                ],
                internalType: "struct IExecutor.CommitBlockInfo[]",
                name: "_newBlocksData",
                type: "tuple[]"
            }
        ],
        name: "commitBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64"
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64"
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32"
                    }
                ],
                internalType: "struct IExecutor.StoredBlockInfo[]",
                name: "_blocksData",
                type: "tuple[]"
            }
        ],
        name: "executeBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address"
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8"
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool"
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]"
                            }
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]"
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes"
                    }
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple"
            },
            {
                internalType: "bytes32",
                name: "_proposalSalt",
                type: "bytes32"
            }
        ],
        name: "executeUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "_selector",
                type: "bytes4"
            }
        ],
        name: "facetAddress",
        outputs: [
            {
                internalType: "address",
                name: "facet",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "facetAddresses",
        outputs: [
            {
                internalType: "address[]",
                name: "facets",
                type: "address[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_facet",
                type: "address"
            }
        ],
        name: "facetFunctionSelectors",
        outputs: [
            {
                internalType: "bytes4[]",
                name: "",
                type: "bytes4[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "facets",
        outputs: [
            {
                components: [
                    {
                        internalType: "address",
                        name: "addr",
                        type: "address"
                    },
                    {
                        internalType: "bytes4[]",
                        name: "selectors",
                        type: "bytes4[]"
                    }
                ],
                internalType: "struct IGetters.Facet[]",
                name: "",
                type: "tuple[]"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16"
            },
            {
                internalType: "bytes",
                name: "_message",
                type: "bytes"
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]"
            }
        ],
        name: "finalizeEthWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "freezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "getCurrentProposalId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getFirstUnprocessedPriorityTx",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getGovernor",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getL2BootloaderBytecodeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getL2DefaultAccountBytecodeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getPendingGovernor",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getPriorityQueueSize",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getProposedUpgradeHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getProposedUpgradeTimestamp",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getSecurityCouncil",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getTotalBlocksCommitted",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getTotalBlocksExecuted",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getTotalBlocksVerified",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getTotalPriorityTxs",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getUpgradeProposalState",
        outputs: [
            {
                internalType: "enum UpgradeState",
                name: "",
                type: "uint8"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getVerifier",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getVerifierParams",
        outputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32"
                    }
                ],
                internalType: "struct VerifierParams",
                name: "",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "getpriorityTxMaxGasLimit",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "isApprovedBySecurityCouncil",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "isDiamondStorageFrozen",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            }
        ],
        name: "isEthWithdrawalFinalized",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_facet",
                type: "address"
            }
        ],
        name: "isFacetFreezable",
        outputs: [
            {
                internalType: "bool",
                name: "isFreezable",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes4",
                name: "_selector",
                type: "bytes4"
            }
        ],
        name: "isFunctionFreezable",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_address",
                type: "address"
            }
        ],
        name: "isValidator",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256"
            }
        ],
        name: "l2LogsRootHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "hash",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_gasPrice",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2GasLimit",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2GasPerPubdataByteLimit",
                type: "uint256"
            }
        ],
        name: "l2TransactionBaseCost",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "priorityQueueFrontOperation",
        outputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "canonicalTxHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint64",
                        name: "expirationTimestamp",
                        type: "uint64"
                    },
                    {
                        internalType: "uint192",
                        name: "layer2Tip",
                        type: "uint192"
                    }
                ],
                internalType: "struct PriorityOperation",
                name: "",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_proposalHash",
                type: "bytes32"
            },
            {
                internalType: "uint40",
                name: "_proposalId",
                type: "uint40"
            }
        ],
        name: "proposeShadowUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address"
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8"
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool"
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]"
                            }
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]"
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes"
                    }
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple"
            },
            {
                internalType: "uint40",
                name: "_proposalId",
                type: "uint40"
            }
        ],
        name: "proposeTransparentUpgrade",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64"
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64"
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32"
                    }
                ],
                internalType: "struct IExecutor.StoredBlockInfo",
                name: "_prevBlock",
                type: "tuple"
            },
            {
                components: [
                    {
                        internalType: "uint64",
                        name: "blockNumber",
                        type: "uint64"
                    },
                    {
                        internalType: "bytes32",
                        name: "blockHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint64",
                        name: "indexRepeatedStorageChanges",
                        type: "uint64"
                    },
                    {
                        internalType: "uint256",
                        name: "numberOfLayer1Txs",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "priorityOperationsHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "l2LogsTreeRoot",
                        type: "bytes32"
                    },
                    {
                        internalType: "uint256",
                        name: "timestamp",
                        type: "uint256"
                    },
                    {
                        internalType: "bytes32",
                        name: "commitment",
                        type: "bytes32"
                    }
                ],
                internalType: "struct IExecutor.StoredBlockInfo[]",
                name: "_committedBlocks",
                type: "tuple[]"
            },
            {
                components: [
                    {
                        internalType: "uint256[]",
                        name: "recursiveAggregationInput",
                        type: "uint256[]"
                    },
                    {
                        internalType: "uint256[]",
                        name: "serializedProof",
                        type: "uint256[]"
                    }
                ],
                internalType: "struct IExecutor.ProofInput",
                name: "_proof",
                type: "tuple"
            }
        ],
        name: "proveBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2TxHash",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16"
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]"
            },
            {
                internalType: "enum TxStatus",
                name: "_status",
                type: "uint8"
            }
        ],
        name: "proveL1ToL2TransactionStatus",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "uint8",
                        name: "l2ShardId",
                        type: "uint8"
                    },
                    {
                        internalType: "bool",
                        name: "isService",
                        type: "bool"
                    },
                    {
                        internalType: "uint16",
                        name: "txNumberInBlock",
                        type: "uint16"
                    },
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "bytes32",
                        name: "key",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "value",
                        type: "bytes32"
                    }
                ],
                internalType: "struct L2Log",
                name: "_log",
                type: "tuple"
            },
            {
                internalType: "bytes32[]",
                name: "_proof",
                type: "bytes32[]"
            }
        ],
        name: "proveL2LogInclusion",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_index",
                type: "uint256"
            },
            {
                components: [
                    {
                        internalType: "uint16",
                        name: "txNumberInBlock",
                        type: "uint16"
                    },
                    {
                        internalType: "address",
                        name: "sender",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "data",
                        type: "bytes"
                    }
                ],
                internalType: "struct L2Message",
                name: "_message",
                type: "tuple"
            },
            {
                internalType: "bytes32[]",
                name: "_proof",
                type: "bytes32[]"
            }
        ],
        name: "proveL2MessageInclusion",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_contractL2",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_l2Value",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "_calldata",
                type: "bytes"
            },
            {
                internalType: "uint256",
                name: "_l2GasLimit",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2GasPerPubdataByteLimit",
                type: "uint256"
            },
            {
                internalType: "bytes[]",
                name: "_factoryDeps",
                type: "bytes[]"
            },
            {
                internalType: "address",
                name: "_refundRecipient",
                type: "address"
            }
        ],
        name: "requestL2Transaction",
        outputs: [
            {
                internalType: "bytes32",
                name: "canonicalTxHash",
                type: "bytes32"
            }
        ],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_newLastBlock",
                type: "uint256"
            }
        ],
        name: "revertBlocks",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_upgradeProposalHash",
                type: "bytes32"
            }
        ],
        name: "securityCouncilUpgradeApprove",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2BootloaderBytecodeHash",
                type: "bytes32"
            }
        ],
        name: "setL2BootloaderBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bytes32",
                name: "_l2DefaultAccountBytecodeHash",
                type: "bytes32"
            }
        ],
        name: "setL2DefaultAccountBytecodeHash",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_newPendingGovernor",
                type: "address"
            }
        ],
        name: "setPendingGovernor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "bool",
                name: "_zkPorterIsAvailable",
                type: "bool"
            }
        ],
        name: "setPorterAvailability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_newPriorityTxMaxGasLimit",
                type: "uint256"
            }
        ],
        name: "setPriorityTxMaxGasLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_validator",
                type: "address"
            },
            {
                internalType: "bool",
                name: "_active",
                type: "bool"
            }
        ],
        name: "setValidator",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "contract Verifier",
                name: "_newVerifier",
                type: "address"
            }
        ],
        name: "setVerifier",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        internalType: "bytes32",
                        name: "recursionNodeLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionLeafLevelVkHash",
                        type: "bytes32"
                    },
                    {
                        internalType: "bytes32",
                        name: "recursionCircuitsSetVksHash",
                        type: "bytes32"
                    }
                ],
                internalType: "struct VerifierParams",
                name: "_newVerifierParams",
                type: "tuple"
            }
        ],
        name: "setVerifierParams",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_blockNumber",
                type: "uint256"
            }
        ],
        name: "storedBlockHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "unfreezeDiamond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                components: [
                    {
                        components: [
                            {
                                internalType: "address",
                                name: "facet",
                                type: "address"
                            },
                            {
                                internalType: "enum Diamond.Action",
                                name: "action",
                                type: "uint8"
                            },
                            {
                                internalType: "bool",
                                name: "isFreezable",
                                type: "bool"
                            },
                            {
                                internalType: "bytes4[]",
                                name: "selectors",
                                type: "bytes4[]"
                            }
                        ],
                        internalType: "struct Diamond.FacetCut[]",
                        name: "facetCuts",
                        type: "tuple[]"
                    },
                    {
                        internalType: "address",
                        name: "initAddress",
                        type: "address"
                    },
                    {
                        internalType: "bytes",
                        name: "initCalldata",
                        type: "bytes"
                    }
                ],
                internalType: "struct Diamond.DiamondCutData",
                name: "_diamondCut",
                type: "tuple"
            },
            {
                internalType: "uint256",
                name: "_proposalId",
                type: "uint256"
            },
            {
                internalType: "bytes32",
                name: "_salt",
                type: "bytes32"
            }
        ],
        name: "upgradeProposalHash",
        outputs: [
            {
                internalType: "bytes32",
                name: "",
                type: "bytes32"
            }
        ],
        stateMutability: "pure",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IERC20MetadataFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IERC20MetadataFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IERC20MetadataFactory = IERC20MetadataFactory;
const _abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "spender",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            }
        ],
        name: "Approval",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "owner",
                type: "address"
            },
            {
                internalType: "address",
                name: "spender",
                type: "address"
            }
        ],
        name: "allowance",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "spender",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "approve",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "account",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "decimals",
        outputs: [
            {
                internalType: "uint8",
                name: "",
                type: "uint8"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "name",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "symbol",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transfer",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "transferFrom",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "nonpayable",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IL1BridgeFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IL1BridgeFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IL1BridgeFactory = IL1BridgeFactory;
const _abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "ClaimedFailedDeposit",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "DepositInitiated",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "l1Token",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "WithdrawalFinalized",
        type: "event"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_depositSender",
                type: "address"
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_l2TxHash",
                type: "bytes32"
            },
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16"
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]"
            }
        ],
        name: "claimFailedDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l2Receiver",
                type: "address"
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2TxGasLimit",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2TxGasPerPubdataByte",
                type: "uint256"
            }
        ],
        name: "deposit",
        outputs: [
            {
                internalType: "bytes32",
                name: "txHash",
                type: "bytes32"
            }
        ],
        stateMutability: "payable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            },
            {
                internalType: "uint16",
                name: "_l2TxNumberInBlock",
                type: "uint16"
            },
            {
                internalType: "bytes",
                name: "_message",
                type: "bytes"
            },
            {
                internalType: "bytes32[]",
                name: "_merkleProof",
                type: "bytes32[]"
            }
        ],
        name: "finalizeWithdrawal",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "uint256",
                name: "_l2BlockNumber",
                type: "uint256"
            },
            {
                internalType: "uint256",
                name: "_l2MessageIndex",
                type: "uint256"
            }
        ],
        name: "isWithdrawalFinalized",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            }
        ],
        name: "l2TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IL2BridgeFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IL2BridgeFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IL2BridgeFactory = IL2BridgeFactory;
const _abi = [
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Sender",
                type: "address"
            },
            {
                internalType: "address",
                name: "_l2Receiver",
                type: "address"
            },
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            },
            {
                internalType: "bytes",
                name: "_data",
                type: "bytes"
            }
        ],
        name: "finalizeDeposit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Bridge",
                type: "address"
            },
            {
                internalType: "bytes32",
                name: "_l2TokenProxyBytecodeHash",
                type: "bytes32"
            },
            {
                internalType: "address",
                name: "_governor",
                type: "address"
            }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "l1Bridge",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l2Token",
                type: "address"
            }
        ],
        name: "l1TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            }
        ],
        name: "l2TokenAddress",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Receiver",
                type: "address"
            },
            {
                internalType: "address",
                name: "_l2Token",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/IAllowListFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IAllowListFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IAllowListFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IAllowListFactory = IAllowListFactory;
const _abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "target",
                type: "address"
            },
            {
                indexed: false,
                internalType: "enum IAllowList.AccessMode",
                name: "previousMode",
                type: "uint8"
            },
            {
                indexed: false,
                internalType: "enum IAllowList.AccessMode",
                name: "newMode",
                type: "uint8"
            }
        ],
        name: "UpdateAccessMode",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "caller",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "target",
                type: "address"
            },
            {
                indexed: true,
                internalType: "bytes4",
                name: "functionSig",
                type: "bytes4"
            },
            {
                indexed: false,
                internalType: "bool",
                name: "status",
                type: "bool"
            }
        ],
        name: "UpdateCallPermission",
        type: "event"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address"
            },
            {
                internalType: "address",
                name: "_target",
                type: "address"
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4"
            }
        ],
        name: "canCall",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_target",
                type: "address"
            }
        ],
        name: "getAccessMode",
        outputs: [
            {
                internalType: "enum IAllowList.AccessMode",
                name: "",
                type: "uint8"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            }
        ],
        name: "getTokenDepositLimitData",
        outputs: [
            {
                components: [
                    {
                        internalType: "bool",
                        name: "depositLimitation",
                        type: "bool"
                    },
                    {
                        internalType: "uint256",
                        name: "depositCap",
                        type: "uint256"
                    }
                ],
                internalType: "struct IAllowList.Deposit",
                name: "",
                type: "tuple"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address"
            },
            {
                internalType: "address",
                name: "_target",
                type: "address"
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4"
            }
        ],
        name: "hasSpecialAccessToCall",
        outputs: [
            {
                internalType: "bool",
                name: "",
                type: "bool"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_target",
                type: "address"
            },
            {
                internalType: "enum IAllowList.AccessMode",
                name: "_accessMode",
                type: "uint8"
            }
        ],
        name: "setAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_targets",
                type: "address[]"
            },
            {
                internalType: "enum IAllowList.AccessMode[]",
                name: "_accessMode",
                type: "uint8[]"
            }
        ],
        name: "setBatchAccessMode",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_callers",
                type: "address[]"
            },
            {
                internalType: "address[]",
                name: "_targets",
                type: "address[]"
            },
            {
                internalType: "bytes4[]",
                name: "_functionSigs",
                type: "bytes4[]"
            },
            {
                internalType: "bool[]",
                name: "_enables",
                type: "bool[]"
            }
        ],
        name: "setBatchPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Token",
                type: "address"
            },
            {
                internalType: "bool",
                name: "_depositLimitation",
                type: "bool"
            },
            {
                internalType: "uint256",
                name: "_depositCap",
                type: "uint256"
            }
        ],
        name: "setDepositLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_caller",
                type: "address"
            },
            {
                internalType: "address",
                name: "_target",
                type: "address"
            },
            {
                internalType: "bytes4",
                name: "_functionSig",
                type: "bytes4"
            },
            {
                internalType: "bool",
                name: "_enable",
                type: "bool"
            }
        ],
        name: "setPermissionToCall",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/IEthTokenFactory.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* Autogenerated file. Do not edit manually. */ /* tslint:disable */ /* eslint-disable */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IEthTokenFactory = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
class IEthTokenFactory {
    static connect(address, signerOrProvider) {
        return new ethers_1.Contract(address, _abi, signerOrProvider);
    }
}
exports.IEthTokenFactory = IEthTokenFactory;
const _abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "account",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256"
            }
        ],
        name: "Mint",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "from",
                type: "address"
            },
            {
                indexed: true,
                internalType: "address",
                name: "to",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "value",
                type: "uint256"
            }
        ],
        name: "Transfer",
        type: "event"
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "_l1Receiver",
                type: "address"
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            }
        ],
        name: "Withdrawal",
        type: "event"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "",
                type: "address"
            }
        ],
        name: "balanceOf",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [],
        name: "decimals",
        outputs: [
            {
                internalType: "uint8",
                name: "",
                type: "uint8"
            }
        ],
        stateMutability: "pure",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_account",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [],
        name: "name",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "pure",
        type: "function"
    },
    {
        inputs: [],
        name: "symbol",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string"
            }
        ],
        stateMutability: "pure",
        type: "function"
    },
    {
        inputs: [],
        name: "totalSupply",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256"
            }
        ],
        stateMutability: "view",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_from",
                type: "address"
            },
            {
                internalType: "address",
                name: "_to",
                type: "address"
            },
            {
                internalType: "uint256",
                name: "_amount",
                type: "uint256"
            }
        ],
        name: "transferFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
    },
    {
        inputs: [
            {
                internalType: "address",
                name: "_l1Receiver",
                type: "address"
            }
        ],
        name: "withdraw",
        outputs: [],
        stateMutability: "payable",
        type: "function"
    }
];
}}),
"[project]/node_modules/zksync-web3/build/typechain/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IEthTokenFactory = exports.IAllowListFactory = exports.IL2BridgeFactory = exports.IL1BridgeFactory = exports.IERC20MetadataFactory = exports.IZkSyncFactory = void 0;
var IZkSyncFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IZkSyncFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IZkSyncFactory", {
    enumerable: true,
    get: function() {
        return IZkSyncFactory_1.IZkSyncFactory;
    }
});
var IERC20MetadataFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IERC20MetadataFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IERC20MetadataFactory", {
    enumerable: true,
    get: function() {
        return IERC20MetadataFactory_1.IERC20MetadataFactory;
    }
});
var IL1BridgeFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IL1BridgeFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IL1BridgeFactory", {
    enumerable: true,
    get: function() {
        return IL1BridgeFactory_1.IL1BridgeFactory;
    }
});
var IL2BridgeFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IL2BridgeFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IL2BridgeFactory", {
    enumerable: true,
    get: function() {
        return IL2BridgeFactory_1.IL2BridgeFactory;
    }
});
var IAllowListFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IAllowListFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IAllowListFactory", {
    enumerable: true,
    get: function() {
        return IAllowListFactory_1.IAllowListFactory;
    }
});
var IEthTokenFactory_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/IEthTokenFactory.js [app-client] (ecmascript)");
Object.defineProperty(exports, "IEthTokenFactory", {
    enumerable: true,
    get: function() {
        return IEthTokenFactory_1.IEthTokenFactory;
    }
});
}}),
"[project]/node_modules/zksync-web3/build/src/adapters.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AdapterL2 = exports.AdapterL1 = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const typechain_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)");
function AdapterL1(Base) {
    return class Adapter extends Base {
        _providerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        _providerL1() {
            throw new Error('Must be implemented by the derived class!');
        }
        _signerL1() {
            throw new Error('Must be implemented by the derived class!');
        }
        async getMainContract() {
            const address = await this._providerL2().getMainContractAddress();
            return typechain_1.IZkSyncFactory.connect(address, this._signerL1());
        }
        async getL1BridgeContracts() {
            const addresses = await this._providerL2().getDefaultBridgeAddresses();
            return {
                erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())
            };
        }
        async getBalanceL1(token, blockTag) {
            token !== null && token !== void 0 ? token : token = utils_1.ETH_ADDRESS;
            if ((0, utils_1.isETH)(token)) {
                return await this._providerL1().getBalance(await this.getAddress(), blockTag);
            } else {
                const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());
                return await erc20contract.balanceOf(await this.getAddress());
            }
        }
        async l2TokenAddress(token) {
            if (token == utils_1.ETH_ADDRESS) {
                return utils_1.ETH_ADDRESS;
            } else {
                const erc20Bridge = (await this.getL1BridgeContracts()).erc20;
                return await erc20Bridge.l2TokenAddress(token);
            }
        }
        async approveERC20(token, amount, overrides) {
            if ((0, utils_1.isETH)(token)) {
                throw new Error("ETH token can't be approved. The address of the token does not exist on L1.");
            }
            let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;
            const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());
            if (bridgeAddress == null) {
                bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;
            } else {
                delete overrides.bridgeAddress;
            }
            return await erc20contract.approve(bridgeAddress, amount, overrides);
        }
        async getBaseCost(params) {
            var _a, _b;
            const zksyncContract = await this.getMainContract();
            const parameters = {
                ...(0, utils_1.layer1TxDefaults)(),
                ...params
            };
            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : parameters.gasPrice = await this._providerL1().getGasPrice();
            (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
            return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));
        }
        async deposit(transaction) {
            var _a;
            const depositTx = await this.getDepositTx(transaction);
            if (transaction.token == utils_1.ETH_ADDRESS) {
                return this.requestExecute(depositTx);
            } else {
                const bridgeContracts = await this.getL1BridgeContracts();
                if (transaction.approveERC20) {
                    const approveTx = await this.approveERC20(transaction.token, transaction.amount, {
                        bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,
                        ...transaction.approveOverrides
                    });
                    await approveTx.wait();
                }
                return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));
            }
        }
        async estimateGasDeposit(transaction) {
            const depositTx = await this.getDepositTx(transaction);
            if (transaction.token == utils_1.ETH_ADDRESS) {
                return await this.estimateGasRequestExecute(depositTx);
            } else {
                return await this._providerL1().estimateGas(depositTx);
            }
        }
        async getDepositTx(transaction) {
            var _a, _b, _c, _d, _e, _f, _g;
            const bridgeContracts = await this.getL1BridgeContracts();
            if (transaction.bridgeAddress) {
                bridgeContracts.erc20.attach(transaction.bridgeAddress);
            }
            const { ...tx } = transaction;
            (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = await this.getAddress();
            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
            (_c = tx.overrides) !== null && _c !== void 0 ? _c : tx.overrides = {};
            (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
            (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte);
            const { to, token, amount, operatorTip, overrides } = tx;
            await insertGasPrice(this._providerL1(), overrides);
            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
            const zksyncContract = await this.getMainContract();
            const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);
            if (token == utils_1.ETH_ADDRESS) {
                (_f = overrides.value) !== null && _f !== void 0 ? _f : overrides.value = baseCost.add(operatorTip).add(amount);
                return {
                    contractAddress: to,
                    calldata: '0x',
                    l2Value: amount,
                    // For some reason typescript can not deduce that we've already set the
                    // tx.l2GasLimit
                    l2GasLimit: tx.l2GasLimit,
                    ...tx
                };
            } else {
                const args = [
                    to,
                    token,
                    amount,
                    tx.l2GasLimit,
                    tx.gasPerPubdataByte
                ];
                (_g = overrides.value) !== null && _g !== void 0 ? _g : overrides.value = baseCost.add(operatorTip);
                await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
                // TODO: compatibility layer: using the old API which uses msg.sender as the
                // refund recipient, to make the SDK compatible with the old contracts.
                // const contract = bridgeContracts.erc20 as ethers.Contract;
                return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);
            }
        }
        async _getWithdrawalLog(withdrawalHash, index = 0) {
            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
            const receipt = await this._providerL2().getTransactionReceipt(hash);
            const log = receipt.logs.filter((log)=>log.address == utils_1.L1_MESSENGER_ADDRESS && log.topics[0] == ethers_1.ethers.utils.id('L1MessageSent(address,bytes32,bytes)'))[index];
            return {
                log,
                l1BatchTxId: receipt.l1BatchTxIndex
            };
        }
        async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {
            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);
            const receipt = await this._providerL2().getTransactionReceipt(hash);
            const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([_, log])=>log.sender == utils_1.L1_MESSENGER_ADDRESS);
            const [l2ToL1LogIndex, l2ToL1Log] = messages[index];
            return {
                l2ToL1LogIndex,
                l2ToL1Log
            };
        }
        async finalizeWithdrawalParams(withdrawalHash, index = 0) {
            const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);
            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
            const message = ethers_1.ethers.utils.defaultAbiCoder.decode([
                'bytes'
            ], log.data)[0];
            return {
                l1BatchNumber: log.l1BatchNumber,
                l2MessageIndex: proof.id,
                l2TxNumberInBlock: l1BatchTxId,
                message,
                sender,
                proof: proof.proof
            };
        }
        async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {
            const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, sender, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);
            if ((0, utils_1.isETH)(sender)) {
                const contractAddress = await this._providerL2().getMainContractAddress();
                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
                return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
            }
            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());
            return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async isWithdrawalFinalized(withdrawalHash, index = 0) {
            const { log } = await this._getWithdrawalLog(withdrawalHash, index);
            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);
            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);
            // `getLogProof` is called not to get proof but
            // to get the index of the corresponding L2->L1 log,
            // which is returned as `proof.id`.
            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);
            if ((0, utils_1.isETH)(sender)) {
                const contractAddress = await this._providerL2().getMainContractAddress();
                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());
                return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);
            }
            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());
            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());
            return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);
        }
        async claimFailedDeposit(depositHash, overrides) {
            const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));
            const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((l2ToL1log)=>l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);
            const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];
            if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {
                throw new Error('Cannot claim successful deposit');
            }
            const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));
            // Undo the aliasing, since the Mailbox contract set it as for contract address.
            const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);
            const l2BridgeAddress = receipt.to;
            const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());
            const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());
            const calldata = l2Bridge.interface.decodeFunctionData('finalizeDeposit', tx.data);
            const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);
            return await l1Bridge.claimFailedDeposit(calldata['_l1Sender'], calldata['_l1Token'], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});
        }
        async requestExecute(transaction) {
            const requestExecuteTx = await this.getRequestExecuteTx(transaction);
            return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));
        }
        async estimateGasRequestExecute(transaction) {
            const requestExecuteTx = await this.getRequestExecuteTx(transaction);
            return this._providerL1().estimateGas(requestExecuteTx);
        }
        async getRequestExecuteTx(transaction) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const zksyncContract = await this.getMainContract();
            const { ...tx } = transaction;
            (_a = tx.l2Value) !== null && _a !== void 0 ? _a : tx.l2Value = ethers_1.BigNumber.from(0);
            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);
            (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : tx.factoryDeps = [];
            (_d = tx.overrides) !== null && _d !== void 0 ? _d : tx.overrides = {};
            (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
            (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : tx.refundRecipient = await this.getAddress();
            (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction);
            const { contractAddress, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient } = tx;
            await insertGasPrice(this._providerL1(), overrides);
            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;
            const baseCost = await this.getBaseCost({
                gasPrice: await gasPriceForEstimation,
                gasPerPubdataByte,
                gasLimit: l2GasLimit
            });
            (_h = overrides.value) !== null && _h !== void 0 ? _h : overrides.value = baseCost.add(operatorTip).add(l2Value);
            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);
            return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);
        }
    };
}
exports.AdapterL1 = AdapterL1;
function AdapterL2(Base) {
    return class Adapter extends Base {
        _providerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        _signerL2() {
            throw new Error('Must be implemented by the derived class!');
        }
        async getBalance(token, blockTag = 'committed') {
            return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);
        }
        async getAllBalances() {
            return await this._providerL2().getAllAccountBalances(await this.getAddress());
        }
        async getL2BridgeContracts() {
            const addresses = await this._providerL2().getDefaultBridgeAddresses();
            return {
                erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())
            };
        }
        _fillCustomData(data) {
            var _a, _b;
            const customData = {
                ...data
            };
            (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
            (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : customData.factoryDeps = [];
            return customData;
        }
        async withdraw(transaction) {
            const withdrawTx = await this._providerL2().getWithdrawTx({
                from: await this.getAddress(),
                ...transaction
            });
            const txResponse = await this.sendTransaction(withdrawTx);
            return this._providerL2()._wrapTransaction(txResponse);
        }
        async transfer(transaction) {
            const transferTx = await this._providerL2().getTransferTx({
                from: await this.getAddress(),
                ...transaction
            });
            const txResponse = await this.sendTransaction(transferTx);
            return this._providerL2()._wrapTransaction(txResponse);
        }
    };
}
exports.AdapterL2 = AdapterL2;
/// @dev This method checks if the overrides contain a gasPrice (or maxFeePerGas), if not it will insert
/// the maxFeePerGas
async function insertGasPrice(l1Provider, overrides) {
    if (!overrides.gasPrice && !overrides.maxFeePerGas) {
        const l1FeeData = await l1Provider.getFeeData();
        // Sometimes baseFeePerGas is not available, so we use gasPrice instead.
        const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;
        // ethers.js by default uses multiplcation by 2, but since the price for the L2 part
        // will depend on the L1 part, doubling base fee is typically too much.
        const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);
        overrides.maxFeePerGas = maxFeePerGas;
        overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;
    }
}
}}),
"[project]/node_modules/zksync-web3/build/src/signer.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.eip712Types = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)");
const hash_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/hash/lib.esm/index.js [app-client] (ecmascript)");
const adapters_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/adapters.js [app-client] (ecmascript)");
exports.eip712Types = {
    Transaction: [
        {
            name: 'txType',
            type: 'uint256'
        },
        {
            name: 'from',
            type: 'uint256'
        },
        {
            name: 'to',
            type: 'uint256'
        },
        {
            name: 'gasLimit',
            type: 'uint256'
        },
        {
            name: 'gasPerPubdataByteLimit',
            type: 'uint256'
        },
        {
            name: 'maxFeePerGas',
            type: 'uint256'
        },
        {
            name: 'maxPriorityFeePerGas',
            type: 'uint256'
        },
        {
            name: 'paymaster',
            type: 'uint256'
        },
        {
            name: 'nonce',
            type: 'uint256'
        },
        {
            name: 'value',
            type: 'uint256'
        },
        {
            name: 'data',
            type: 'bytes'
        },
        {
            name: 'factoryDeps',
            type: 'bytes32[]'
        },
        {
            name: 'paymasterInput',
            type: 'bytes'
        }
    ]
};
class EIP712Signer {
    constructor(ethSigner, chainId){
        this.ethSigner = ethSigner;
        this.eip712Domain = Promise.resolve(chainId).then((chainId)=>({
                name: 'zkSync',
                version: '2',
                chainId
            }));
    }
    static getSignInput(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
        const gasPerPubdataByteLimit = ((_a = transaction.customData) === null || _a === void 0 ? void 0 : _a.gasPerPubdata) || utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        const signInput = {
            txType: transaction.type,
            from: transaction.from,
            to: transaction.to,
            gasLimit: transaction.gasLimit,
            gasPerPubdataByteLimit: gasPerPubdataByteLimit,
            maxFeePerGas,
            maxPriorityFeePerGas,
            paymaster: ((_c = (_b = transaction.customData) === null || _b === void 0 ? void 0 : _b.paymasterParams) === null || _c === void 0 ? void 0 : _c.paymaster) || ethers_1.ethers.constants.AddressZero,
            nonce: transaction.nonce,
            value: transaction.value,
            data: transaction.data,
            factoryDeps: ((_e = (_d = transaction.customData) === null || _d === void 0 ? void 0 : _d.factoryDeps) === null || _e === void 0 ? void 0 : _e.map((dep)=>(0, utils_1.hashBytecode)(dep))) || [],
            paymasterInput: ((_g = (_f = transaction.customData) === null || _f === void 0 ? void 0 : _f.paymasterParams) === null || _g === void 0 ? void 0 : _g.paymasterInput) || '0x'
        };
        return signInput;
    }
    async sign(transaction) {
        return await this.ethSigner._signTypedData(await this.eip712Domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
    }
    static getSignedDigest(transaction) {
        if (!transaction.chainId) {
            throw Error("Transaction chainId isn't set");
        }
        const domain = {
            name: 'zkSync',
            version: '2',
            chainId: transaction.chainId
        };
        return hash_1._TypedDataEncoder.hash(domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
    }
}
exports.EIP712Signer = EIP712Signer;
// This class is to be used on the frontend, with metamask injection.
// It only contains L2 operations. For L1 operations, see L1Signer.
// Sample usage:
// const provider = new zkweb3.Web3Provider(window.ethereum);
// const signer = provider.getSigner();
// const tx = await signer.sendTransaction({ ... });
class Signer extends (0, adapters_1.AdapterL2)(ethers_1.ethers.providers.JsonRpcSigner) {
    _signerL2() {
        return this;
    }
    _providerL2() {
        return this.provider;
    }
    static from(signer) {
        const newSigner = Object.setPrototypeOf(signer, Signer.prototype);
        // @ts-ignore
        newSigner.eip712 = new EIP712Signer(newSigner, newSigner.getChainId());
        return newSigner;
    }
    // an alias with a better name
    async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
    }
    async sendTransaction(transaction) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (transaction.customData == null && transaction.type == null) {
            // use legacy txs by default
            transaction.type = 0;
        }
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
            return await super.sendTransaction(transaction);
        } else {
            const address = await this.getAddress();
            (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = address;
            if (transaction.from.toLowerCase() != address.toLowerCase()) {
                throw new Error('Transaction `from` address mismatch');
            }
            transaction.type = utils_1.EIP712_TX_TYPE;
            (_b = transaction.value) !== null && _b !== void 0 ? _b : transaction.value = 0;
            (_c = transaction.data) !== null && _c !== void 0 ? _c : transaction.data = '0x';
            (_d = transaction.nonce) !== null && _d !== void 0 ? _d : transaction.nonce = await this.getNonce();
            transaction.customData = this._fillCustomData(transaction.customData);
            (_e = transaction.gasPrice) !== null && _e !== void 0 ? _e : transaction.gasPrice = await this.provider.getGasPrice();
            (_f = transaction.gasLimit) !== null && _f !== void 0 ? _f : transaction.gasLimit = await this.provider.estimateGas(transaction);
            (_g = transaction.chainId) !== null && _g !== void 0 ? _g : transaction.chainId = (await this.provider.getNetwork()).chainId;
            transaction.customData.customSignature = await this.eip712.sign(transaction);
            const txBytes = (0, utils_1.serialize)(transaction);
            return await this.provider.sendTransaction(txBytes);
        }
    }
}
exports.Signer = Signer;
// This class is to be used on the frontend with metamask injection.
// It only contains L1 operations. For L2 operations, see Signer.
// Sample usage:
// const provider = new ethers.Web3Provider(window.ethereum);
// const zksyncProvider = new zkweb3.Provider('<rpc_url>');
// const signer = zkweb3.L1Signer.from(provider.getSigner(), zksyncProvider);
// const tx = await signer.deposit({ ... });
class L1Signer extends (0, adapters_1.AdapterL1)(ethers_1.ethers.providers.JsonRpcSigner) {
    _providerL2() {
        return this.providerL2;
    }
    _providerL1() {
        return this.provider;
    }
    _signerL1() {
        return this;
    }
    static from(signer, zksyncProvider) {
        const newSigner = Object.setPrototypeOf(signer, L1Signer.prototype);
        newSigner.providerL2 = zksyncProvider;
        return newSigner;
    }
    connectToL2(provider) {
        this.providerL2 = provider;
        return this;
    }
}
exports.L1Signer = L1Signer;
}}),
"[project]/node_modules/zksync-web3/abi/IPaymasterFlow.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minAllowance\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_innerInput\",\"type\":\"bytes\"}],\"name\":\"approvalBased\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"name\":\"general\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/build/src/paymaster-utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getPaymasterParams = exports.getGeneralPaymasterInput = exports.getApprovalBasedPaymasterInput = exports.IPaymasterFlow = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
exports.IPaymasterFlow = new ethers_1.ethers.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IPaymasterFlow.json (json)").abi);
function getApprovalBasedPaymasterInput(paymasterInput) {
    return exports.IPaymasterFlow.encodeFunctionData('approvalBased', [
        paymasterInput.token,
        paymasterInput.minimalAllowance,
        paymasterInput.innerInput
    ]);
}
exports.getApprovalBasedPaymasterInput = getApprovalBasedPaymasterInput;
function getGeneralPaymasterInput(paymasterInput) {
    return exports.IPaymasterFlow.encodeFunctionData('general', [
        paymasterInput.innerInput
    ]);
}
exports.getGeneralPaymasterInput = getGeneralPaymasterInput;
function getPaymasterParams(paymasterAddress, paymasterInput) {
    if (paymasterInput.type == 'General') {
        return {
            paymaster: paymasterAddress,
            paymasterInput: getGeneralPaymasterInput(paymasterInput)
        };
    } else {
        return {
            paymaster: paymasterAddress,
            paymasterInput: getApprovalBasedPaymasterInput(paymasterInput)
        };
    }
}
exports.getPaymasterParams = getPaymasterParams;
}}),
"[project]/node_modules/zksync-web3/abi/IZkSync.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksVerified\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksExecuted\",\"type\":\"uint256\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousLastVerifiedBlock\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentLastVerifiedBlock\",\"type\":\"uint256\"}],\"name\":\"BlocksVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"CancelUpgradeProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthWithdrawalFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalSalt\",\"type\":\"bytes32\"}],\"name\":\"ExecuteUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Freeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPorterAvailable\",\"type\":\"bool\"}],\"name\":\"IsPorterAvailableStatusUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"NewGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousBytecodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newBytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"NewL2BootloaderBytecodeHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousBytecodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newBytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"NewL2DefaultAccountBytecodeHash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldPendingGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingGovernor\",\"type\":\"address\"}],\"name\":\"NewPendingGovernor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"txType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasPerPubdataByteLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriorityFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymaster\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256[4]\",\"name\":\"reserved\",\"type\":\"uint256[4]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"factoryDeps\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"paymasterInput\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"reservedDynamic\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct IMailbox.L2CanonicalTransaction\",\"name\":\"transaction\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"factoryDeps\",\"type\":\"bytes[]\"}],\"name\":\"NewPriorityRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPriorityTxMaxGasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriorityTxMaxGasLimit\",\"type\":\"uint256\"}],\"name\":\"NewPriorityTxMaxGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVerifier\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVerifier\",\"type\":\"address\"}],\"name\":\"NewVerifier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recursionNodeLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionLeafLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionCircuitsSetVksHash\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct VerifierParams\",\"name\":\"oldVerifierParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recursionNodeLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionLeafLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionCircuitsSetVksHash\",\"type\":\"bytes32\"}],\"indexed\":false,\"internalType\":\"struct VerifierParams\",\"name\":\"newVerifierParams\",\"type\":\"tuple\"}],\"name\":\"NewVerifierParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"ProposeShadowUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"enum Diamond.Action\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFreezable\",\"type\":\"bool\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Diamond.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"initAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCalldata\",\"type\":\"bytes\"}],\"indexed\":false,\"internalType\":\"struct Diamond.DiamondCutData\",\"name\":\"diamondCut\",\"type\":\"tuple\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"proposalSalt\",\"type\":\"bytes32\"}],\"name\":\"ProposeTransparentUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"proposalHash\",\"type\":\"bytes32\"}],\"name\":\"SecurityCouncilUpgradeApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unfreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"name\":\"ValidatorStatusUpdate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposedUpgradeHash\",\"type\":\"bytes32\"}],\"name\":\"cancelUpgradeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"_lastCommittedBlockData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initialStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"repeatedStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"l2Logs\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"l2ArbitraryLengthMessages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"factoryDeps\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IExecutor.CommitBlockInfo[]\",\"name\":\"_newBlocksData\",\"type\":\"tuple[]\"}],\"name\":\"commitBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"_blocksData\",\"type\":\"tuple[]\"}],\"name\":\"executeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"enum Diamond.Action\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFreezable\",\"type\":\"bool\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Diamond.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"initAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct Diamond.DiamondCutData\",\"name\":\"_diamondCut\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_proposalSalt\",\"type\":\"bytes32\"}],\"name\":\"executeUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IGetters.Facet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_l2TxNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"finalizeEthWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeDiamond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentProposalId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFirstUnprocessedPriorityTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getL2BootloaderBytecodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getL2DefaultAccountBytecodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriorityQueueSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedUpgradeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProposedUpgradeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecurityCouncil\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBlocksCommitted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBlocksExecuted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBlocksVerified\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPriorityTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUpgradeProposalState\",\"outputs\":[{\"internalType\":\"enum UpgradeState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifier\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifierParams\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recursionNodeLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionLeafLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionCircuitsSetVksHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct VerifierParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getpriorityTxMaxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isApprovedBySecurityCouncil\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondStorageFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"}],\"name\":\"isEthWithdrawalFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"isFacetFreezable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isFreezable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_selector\",\"type\":\"bytes4\"}],\"name\":\"isFunctionFreezable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"l2LogsRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasPerPubdataByteLimit\",\"type\":\"uint256\"}],\"name\":\"l2TransactionBaseCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priorityQueueFrontOperation\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"canonicalTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"layer2Tip\",\"type\":\"uint192\"}],\"internalType\":\"struct PriorityOperation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposalHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"_proposalId\",\"type\":\"uint40\"}],\"name\":\"proposeShadowUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"enum Diamond.Action\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFreezable\",\"type\":\"bool\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Diamond.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"initAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct Diamond.DiamondCutData\",\"name\":\"_diamondCut\",\"type\":\"tuple\"},{\"internalType\":\"uint40\",\"name\":\"_proposalId\",\"type\":\"uint40\"}],\"name\":\"proposeTransparentUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"_prevBlock\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"_committedBlocks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"recursiveAggregationInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serializedProof\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IExecutor.ProofInput\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"proveBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_l2TxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_l2TxNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"enum TxStatus\",\"name\":\"_status\",\"type\":\"uint8\"}],\"name\":\"proveL1ToL2TransactionStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"l2ShardId\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isService\",\"type\":\"bool\"},{\"internalType\":\"uint16\",\"name\":\"txNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"value\",\"type\":\"bytes32\"}],\"internalType\":\"struct L2Log\",\"name\":\"_log\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"proveL2LogInclusion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"txNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct L2Message\",\"name\":\"_message\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"proveL2MessageInclusion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractL2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_l2Value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasPerPubdataByteLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"_factoryDeps\",\"type\":\"bytes[]\"},{\"internalType\":\"address\",\"name\":\"_refundRecipient\",\"type\":\"address\"}],\"name\":\"requestL2Transaction\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"canonicalTxHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLastBlock\",\"type\":\"uint256\"}],\"name\":\"revertBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_upgradeProposalHash\",\"type\":\"bytes32\"}],\"name\":\"securityCouncilUpgradeApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_l2BootloaderBytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"setL2BootloaderBytecodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_l2DefaultAccountBytecodeHash\",\"type\":\"bytes32\"}],\"name\":\"setL2DefaultAccountBytecodeHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPendingGovernor\",\"type\":\"address\"}],\"name\":\"setPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_zkPorterIsAvailable\",\"type\":\"bool\"}],\"name\":\"setPorterAvailability\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPriorityTxMaxGasLimit\",\"type\":\"uint256\"}],\"name\":\"setPriorityTxMaxGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Verifier\",\"name\":\"_newVerifier\",\"type\":\"address\"}],\"name\":\"setVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"recursionNodeLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionLeafLevelVkHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"recursionCircuitsSetVksHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct VerifierParams\",\"name\":\"_newVerifierParams\",\"type\":\"tuple\"}],\"name\":\"setVerifierParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"storedBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreezeDiamond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"},{\"internalType\":\"enum Diamond.Action\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isFreezable\",\"type\":\"bool\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct Diamond.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"initAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct Diamond.DiamondCutData\",\"name\":\"_diamondCut\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"upgradeProposalHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/ContractDeployer.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IContractDeployer.AccountNonceOrdering\",\"name\":\"nonceOrdering\",\"type\":\"uint8\"}],\"name\":\"AccountNonceOrderingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"accountAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"aaVersion\",\"type\":\"uint8\"}],\"name\":\"AccountVersionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractDeployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_input\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_input\",\"type\":\"bytes\"}],\"name\":\"create2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_input\",\"type\":\"bytes\"},{\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"_aaVersion\",\"type\":\"uint8\"}],\"name\":\"create2Account\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_input\",\"type\":\"bytes\"},{\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"_aaVersion\",\"type\":\"uint8\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"extendedAccountVersion\",\"outputs\":[{\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"callConstructor\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"internalType\":\"struct ContractDeployer.ForceDeployment\",\"name\":\"_deployment\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"forceDeployOnAddress\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"callConstructor\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"input\",\"type\":\"bytes\"}],\"internalType\":\"struct ContractDeployer.ForceDeployment[]\",\"name\":\"_deployments\",\"type\":\"tuple[]\"}],\"name\":\"forceDeployOnAddresses\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAccountInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"supportedAAVersion\",\"type\":\"uint8\"},{\"internalType\":\"enum IContractDeployer.AccountNonceOrdering\",\"name\":\"nonceOrdering\",\"type\":\"uint8\"}],\"internalType\":\"struct IContractDeployer.AccountInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_senderNonce\",\"type\":\"uint256\"}],\"name\":\"getNewAddressCreate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_bytecodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_input\",\"type\":\"bytes\"}],\"name\":\"getNewAddressCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IContractDeployer.AccountAbstractionVersion\",\"name\":\"_version\",\"type\":\"uint8\"}],\"name\":\"updateAccountVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IContractDeployer.AccountNonceOrdering\",\"name\":\"_nonceOrdering\",\"type\":\"uint8\"}],\"name\":\"updateNonceOrdering\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/IL1Messenger.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"L1MessageSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendToL1\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/IERC20.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/IERC1271.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/IL1Bridge.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedFailedDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFinalized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_l2TxHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_l2TxNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimFailedDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2Receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2TxGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2TxGasPerPubdataByte\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_l2TxNumberInBlock\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"finalizeWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2BlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2MessageIndex\",\"type\":\"uint256\"}],\"name\":\"isWithdrawalFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"}],\"name\":\"l2TokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/abi/IL2Bridge.json (json)": ((__turbopack_context__) => {

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.v(JSON.parse("{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FinalizeDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l1Receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalInitiated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2Receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"finalizeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1Bridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l2Token\",\"type\":\"address\"}],\"name\":\"l1TokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"}],\"name\":\"l2TokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l2Token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]}"));}}),
"[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.estimateDefaultBridgeDepositL2Gas = exports.isTypedDataSignatureCorrect = exports.isMessageSignatureCorrect = exports.getERC20BridgeCalldata = exports.undoL1ToL2Alias = exports.applyL1ToL2Alias = exports.getL2HashFromPriorityOp = exports.parseTransaction = exports.hashBytecode = exports.serialize = exports.checkBaseCost = exports.createAddress = exports.create2Address = exports.getDeployedContracts = exports.getHashedL2ToL1Msg = exports.layer1TxDefaults = exports.sleep = exports.isETH = exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = exports.MAX_BYTECODE_LEN_BYTES = exports.PRIORITY_OPERATION_L2_TX_TYPE = exports.EIP712_TX_TYPE = exports.EIP1271_MAGIC_VALUE = exports.L1_TO_L2_ALIAS_OFFSET = exports.L2_ETH_TOKEN_ADDRESS = exports.L1_MESSENGER_ADDRESS = exports.CONTRACT_DEPLOYER_ADDRESS = exports.BOOTLOADER_FORMAL_ADDRESS = exports.L2_BRIDGE_ABI = exports.L1_BRIDGE_ABI = exports.IERC1271 = exports.IERC20 = exports.L1_MESSENGER = exports.CONTRACT_DEPLOYER = exports.ZKSYNC_MAIN_ABI = exports.ETH_ADDRESS = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/types.js [app-client] (ecmascript)");
const signer_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/signer.js [app-client] (ecmascript)");
const typechain_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
__exportStar(__turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/paymaster-utils.js [app-client] (ecmascript)"), exports);
exports.ETH_ADDRESS = '0x0000000000000000000000000000000000000000';
exports.ZKSYNC_MAIN_ABI = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IZkSync.json (json)").abi);
exports.CONTRACT_DEPLOYER = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/ContractDeployer.json (json)").abi);
exports.L1_MESSENGER = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IL1Messenger.json (json)").abi);
exports.IERC20 = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IERC20.json (json)").abi);
exports.IERC1271 = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IERC1271.json (json)").abi);
exports.L1_BRIDGE_ABI = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IL1Bridge.json (json)").abi);
exports.L2_BRIDGE_ABI = new ethers_1.utils.Interface(__turbopack_context__.r("[project]/node_modules/zksync-web3/abi/IL2Bridge.json (json)").abi);
exports.BOOTLOADER_FORMAL_ADDRESS = '0x0000000000000000000000000000000000008001';
exports.CONTRACT_DEPLOYER_ADDRESS = '0x0000000000000000000000000000000000008006';
exports.L1_MESSENGER_ADDRESS = '0x0000000000000000000000000000000000008008';
exports.L2_ETH_TOKEN_ADDRESS = '0x000000000000000000000000000000000000800a';
exports.L1_TO_L2_ALIAS_OFFSET = '0x1111000000000000000000000000000000001111';
exports.EIP1271_MAGIC_VALUE = '0x1626ba7e';
exports.EIP712_TX_TYPE = 0x71;
exports.PRIORITY_OPERATION_L2_TX_TYPE = 0xff;
exports.MAX_BYTECODE_LEN_BYTES = ((1 << 16) - 1) * 32;
// The large L2 gas per pubdata to sign. This gas is enough to ensure that
// any reasonable limit will be accepted. Note, that the operator is NOT required to
// use the honest value of gas per pubdata and it can use any value up to the one signed by the user.
// In the future releases, we will provide a way to estimate the current gasPerPubdata.
exports.DEFAULT_GAS_PER_PUBDATA_LIMIT = 50000;
// It is possible to provide practically any gasPerPubdataByte for L1->L2 transactions, since
// the cost per gas will be adjusted respectively. We will use 800 as an relatively optimal value for now.
exports.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT = 800;
function isETH(token) {
    return token.toLowerCase() == exports.ETH_ADDRESS || token.toLowerCase() == exports.L2_ETH_TOKEN_ADDRESS;
}
exports.isETH = isETH;
function sleep(millis) {
    return new Promise((resolve)=>setTimeout(resolve, millis));
}
exports.sleep = sleep;
function layer1TxDefaults() {
    return {
        queueType: types_1.PriorityQueueType.Deque,
        opTree: types_1.PriorityOpTree.Full
    };
}
exports.layer1TxDefaults = layer1TxDefaults;
function getHashedL2ToL1Msg(sender, msg, txNumberInBlock) {
    const encodedMsg = new Uint8Array([
        0,
        1,
        ...ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(txNumberInBlock), 2),
        ...ethers_1.ethers.utils.arrayify(exports.L1_MESSENGER_ADDRESS),
        ...ethers_1.ethers.utils.zeroPad(sender, 32),
        ...ethers_1.ethers.utils.arrayify(ethers_1.ethers.utils.keccak256(msg))
    ]);
    return ethers_1.ethers.utils.keccak256(encodedMsg);
}
exports.getHashedL2ToL1Msg = getHashedL2ToL1Msg;
function getDeployedContracts(receipt) {
    const addressBytesLen = 40;
    const deployedContracts = receipt.logs.filter((log)=>log.topics[0] == ethers_1.utils.id('ContractDeployed(address,bytes32,address)') && log.address == exports.CONTRACT_DEPLOYER_ADDRESS)// Take the last topic (deployed contract address as U256) and extract address from it (U160).
    .map((log)=>{
        const sender = `0x${log.topics[1].slice(log.topics[1].length - addressBytesLen)}`;
        const bytesCodehash = log.topics[2];
        const address = `0x${log.topics[3].slice(log.topics[3].length - addressBytesLen)}`;
        return {
            sender: ethers_1.utils.getAddress(sender),
            bytecodeHash: bytesCodehash,
            deployedAddress: ethers_1.utils.getAddress(address)
        };
    });
    return deployedContracts;
}
exports.getDeployedContracts = getDeployedContracts;
function create2Address(sender, bytecodeHash, salt, input) {
    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate2'));
    const inputHash = ethers_1.ethers.utils.keccak256(input);
    const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([
        prefix,
        ethers_1.ethers.utils.zeroPad(sender, 32),
        salt,
        bytecodeHash,
        inputHash
    ])).slice(26);
    return ethers_1.ethers.utils.getAddress(addressBytes);
}
exports.create2Address = create2Address;
function createAddress(sender, senderNonce) {
    const prefix = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes('zksyncCreate'));
    const addressBytes = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.concat([
        prefix,
        ethers_1.ethers.utils.zeroPad(sender, 32),
        ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.hexlify(senderNonce), 32)
    ])).slice(26);
    return ethers_1.ethers.utils.getAddress(addressBytes);
}
exports.createAddress = createAddress;
async function checkBaseCost(baseCost, value) {
    if (baseCost.gt(await value)) {
        throw new Error(`The base cost of performing the priority operation is higher than the provided value parameter ` + `for the transaction: baseCost: ${baseCost}, provided value: ${value}`);
    }
}
exports.checkBaseCost = checkBaseCost;
function serialize(transaction, signature) {
    var _a;
    if (transaction.customData == null && transaction.type != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.serializeTransaction(transaction, signature);
    }
    if (!transaction.chainId) {
        throw Error("Transaction chainId isn't set");
    }
    function formatNumber(value, name) {
        const result = ethers_1.utils.stripZeros(ethers_1.BigNumber.from(value).toHexString());
        if (result.length > 32) {
            throw new Error('invalid length for ' + name);
        }
        return result;
    }
    if (!transaction.from) {
        throw new Error('Explicitly providing `from` field is reqiured for EIP712 transactions');
    }
    const from = transaction.from;
    const meta = transaction.customData;
    let maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice || 0;
    let maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
    const fields = [
        formatNumber(transaction.nonce || 0, 'nonce'),
        formatNumber(maxPriorityFeePerGas, 'maxPriorityFeePerGas'),
        formatNumber(maxFeePerGas, 'maxFeePerGas'),
        formatNumber(transaction.gasLimit || 0, 'gasLimit'),
        transaction.to != null ? ethers_1.utils.getAddress(transaction.to) : '0x',
        formatNumber(transaction.value || 0, 'value'),
        transaction.data || '0x'
    ];
    if (signature) {
        const sig = ethers_1.utils.splitSignature(signature);
        fields.push(formatNumber(sig.recoveryParam, 'recoveryParam'));
        fields.push(ethers_1.utils.stripZeros(sig.r));
        fields.push(ethers_1.utils.stripZeros(sig.s));
    } else {
        fields.push(formatNumber(transaction.chainId, 'chainId'));
        fields.push('0x');
        fields.push('0x');
    }
    fields.push(formatNumber(transaction.chainId, 'chainId'));
    fields.push(ethers_1.utils.getAddress(from));
    // Add meta
    fields.push(formatNumber(meta.gasPerPubdata || exports.DEFAULT_GAS_PER_PUBDATA_LIMIT, 'gasPerPubdata'));
    fields.push(((_a = meta.factoryDeps) !== null && _a !== void 0 ? _a : []).map((dep)=>ethers_1.utils.hexlify(dep)));
    if (meta.customSignature && ethers_1.ethers.utils.arrayify(meta.customSignature).length == 0) {
        throw new Error('Empty signatures are not supported');
    }
    fields.push(meta.customSignature || '0x');
    if (meta.paymasterParams) {
        fields.push([
            meta.paymasterParams.paymaster,
            ethers_1.ethers.utils.hexlify(meta.paymasterParams.paymasterInput)
        ]);
    } else {
        fields.push([]);
    }
    return ethers_1.utils.hexConcat([
        [
            exports.EIP712_TX_TYPE
        ],
        ethers_1.utils.RLP.encode(fields)
    ]);
}
exports.serialize = serialize;
function hashBytecode(bytecode) {
    // For getting the consistent length we first convert the bytecode to UInt8Array
    const bytecodeAsArray = ethers_1.ethers.utils.arrayify(bytecode);
    if (bytecodeAsArray.length % 32 != 0) {
        throw new Error('The bytecode length in bytes must be divisible by 32');
    }
    if (bytecodeAsArray.length > exports.MAX_BYTECODE_LEN_BYTES) {
        throw new Error(`Bytecode can not be longer than ${exports.MAX_BYTECODE_LEN_BYTES} bytes`);
    }
    const hashStr = ethers_1.ethers.utils.sha256(bytecodeAsArray);
    const hash = ethers_1.ethers.utils.arrayify(hashStr);
    // Note that the length of the bytecode
    // should be provided in 32-byte words.
    const bytecodeLengthInWords = bytecodeAsArray.length / 32;
    if (bytecodeLengthInWords % 2 == 0) {
        throw new Error('Bytecode length in 32-byte words must be odd');
    }
    const bytecodeLength = ethers_1.ethers.utils.arrayify(bytecodeLengthInWords);
    // The bytecode should always take the first 2 bytes of the bytecode hash,
    // so we pad it from the left in case the length is smaller than 2 bytes.
    const bytecodeLengthPadded = ethers_1.ethers.utils.zeroPad(bytecodeLength, 2);
    const codeHashVersion = new Uint8Array([
        1,
        0
    ]);
    hash.set(codeHashVersion, 0);
    hash.set(bytecodeLengthPadded, 2);
    return hash;
}
exports.hashBytecode = hashBytecode;
function parseTransaction(payload) {
    function handleAddress(value) {
        if (value === '0x') {
            return null;
        }
        return ethers_1.utils.getAddress(value);
    }
    function handleNumber(value) {
        if (value === '0x') {
            return ethers_1.BigNumber.from(0);
        }
        return ethers_1.BigNumber.from(value);
    }
    function arrayToPaymasterParams(arr) {
        if (arr.length == 0) {
            return undefined;
        }
        if (arr.length != 2) {
            throw new Error(`Invalid paymaster parameters, expected to have length of 2, found ${arr.length}`);
        }
        return {
            paymaster: ethers_1.utils.getAddress(arr[0]),
            paymasterInput: ethers_1.utils.arrayify(arr[1])
        };
    }
    const bytes = ethers_1.utils.arrayify(payload);
    if (bytes[0] != exports.EIP712_TX_TYPE) {
        return ethers_1.utils.parseTransaction(bytes);
    }
    const raw = ethers_1.utils.RLP.decode(bytes.slice(1));
    const transaction = {
        type: exports.EIP712_TX_TYPE,
        nonce: handleNumber(raw[0]).toNumber(),
        maxPriorityFeePerGas: handleNumber(raw[1]),
        maxFeePerGas: handleNumber(raw[2]),
        gasLimit: handleNumber(raw[3]),
        to: handleAddress(raw[4]),
        value: handleNumber(raw[5]),
        data: raw[6],
        chainId: handleNumber(raw[10]),
        from: handleAddress(raw[11]),
        customData: {
            gasPerPubdata: handleNumber(raw[12]),
            factoryDeps: raw[13],
            customSignature: raw[14],
            paymasterParams: arrayToPaymasterParams(raw[15])
        }
    };
    const ethSignature = {
        v: handleNumber(raw[7]).toNumber(),
        r: raw[8],
        s: raw[9]
    };
    if ((ethers_1.utils.hexlify(ethSignature.r) == '0x' || ethers_1.utils.hexlify(ethSignature.s) == '0x') && !transaction.customData.customSignature) {
        return transaction;
    }
    if (ethSignature.v !== 0 && ethSignature.v !== 1 && !transaction.customData.customSignature) {
        throw new Error('Failed to parse signature');
    }
    if (!transaction.customData.customSignature) {
        transaction.v = ethSignature.v;
        transaction.s = ethSignature.s;
        transaction.r = ethSignature.r;
    }
    transaction.hash = eip712TxHash(transaction, ethSignature);
    return transaction;
}
exports.parseTransaction = parseTransaction;
function getSignature(transaction, ethSignature) {
    var _a;
    if (((_a = transaction === null || transaction === void 0 ? void 0 : transaction.customData) === null || _a === void 0 ? void 0 : _a.customSignature) && transaction.customData.customSignature.length) {
        return ethers_1.ethers.utils.arrayify(transaction.customData.customSignature);
    }
    if (!ethSignature) {
        throw new Error('No signature provided');
    }
    const r = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.r), 32);
    const s = ethers_1.ethers.utils.zeroPad(ethers_1.ethers.utils.arrayify(ethSignature.s), 32);
    const v = ethSignature.v;
    return new Uint8Array([
        ...r,
        ...s,
        v
    ]);
}
function eip712TxHash(transaction, ethSignature) {
    const signedDigest = signer_1.EIP712Signer.getSignedDigest(transaction);
    const hashedSignature = ethers_1.ethers.utils.keccak256(getSignature(transaction, ethSignature));
    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.hexConcat([
        signedDigest,
        hashedSignature
    ]));
}
function getL2HashFromPriorityOp(txReceipt, zkSyncAddress) {
    let txHash = null;
    for (const log of txReceipt.logs){
        if (log.address.toLowerCase() != zkSyncAddress.toLowerCase()) {
            continue;
        }
        try {
            const priorityQueueLog = exports.ZKSYNC_MAIN_ABI.parseLog(log);
            if (priorityQueueLog && priorityQueueLog.args.txHash != null) {
                txHash = priorityQueueLog.args.txHash;
            }
        } catch  {}
    }
    if (!txHash) {
        throw new Error('Failed to parse tx logs');
    }
    return txHash;
}
exports.getL2HashFromPriorityOp = getL2HashFromPriorityOp;
const ADDRESS_MODULO = ethers_1.BigNumber.from(2).pow(160);
function applyL1ToL2Alias(address) {
    return ethers_1.ethers.utils.hexlify(ethers_1.ethers.BigNumber.from(address).add(exports.L1_TO_L2_ALIAS_OFFSET).mod(ADDRESS_MODULO));
}
exports.applyL1ToL2Alias = applyL1ToL2Alias;
function undoL1ToL2Alias(address) {
    let result = ethers_1.ethers.BigNumber.from(address).sub(exports.L1_TO_L2_ALIAS_OFFSET);
    if (result.lt(ethers_1.BigNumber.from(0))) {
        result = result.add(ADDRESS_MODULO);
    }
    return ethers_1.ethers.utils.hexlify(result);
}
exports.undoL1ToL2Alias = undoL1ToL2Alias;
/// Getters data used to correctly initialize the L1 token counterpart on L2
async function getERC20GettersData(l1TokenAddress, provider) {
    const token = typechain_1.IERC20MetadataFactory.connect(l1TokenAddress, provider);
    const name = await token.name();
    const symbol = await token.symbol();
    const decimals = await token.decimals();
    const coder = new utils_1.AbiCoder();
    const nameBytes = coder.encode([
        'string'
    ], [
        name
    ]);
    const symbolBytes = coder.encode([
        'string'
    ], [
        symbol
    ]);
    const decimalsBytes = coder.encode([
        'uint256'
    ], [
        decimals
    ]);
    return coder.encode([
        'bytes',
        'bytes',
        'bytes'
    ], [
        nameBytes,
        symbolBytes,
        decimalsBytes
    ]);
}
/// The method that returns the calldata that will be sent by an L1 ERC20 bridge to its L2 counterpart
/// during bridging of a token.
async function getERC20BridgeCalldata(l1TokenAddress, l1Sender, l2Receiver, amount, provider) {
    const gettersData = await getERC20GettersData(l1TokenAddress, provider);
    return exports.L2_BRIDGE_ABI.encodeFunctionData('finalizeDeposit', [
        l1Sender,
        l2Receiver,
        l1TokenAddress,
        amount,
        gettersData
    ]);
}
exports.getERC20BridgeCalldata = getERC20BridgeCalldata;
// The method with similar functionality is already available in ethers.js,
// the only difference is that we provide additional `try { } catch { }`
// for error-resilience.
//
// It will also pave the road for allowing future EIP-1271 signature verification, by
// letting our SDK have functionality to verify signatures.
function isECDSASignatureCorrect(address, msgHash, signature) {
    try {
        return address == ethers_1.ethers.utils.recoverAddress(msgHash, signature);
    } catch  {
        // In case ECDSA signature verification has thrown an error,
        // we simply consider the signature as incorrect.
        return false;
    }
}
async function isEIP1271SignatureCorrect(provider, address, msgHash, signature) {
    const accountContract = new ethers_1.ethers.Contract(address, exports.IERC1271, provider);
    // This line may throw an exception if the contract does not implement the EIP1271 correctly.
    // But it may also throw an exception in case the internet connection is lost.
    // It is the caller's responsibility to handle the exception.
    const result = await accountContract.isValidSignature(msgHash, signature);
    return result == exports.EIP1271_MAGIC_VALUE;
}
async function isSignatureCorrect(provider, address, msgHash, signature) {
    let isContractAccount = false;
    const code = await provider.getCode(address);
    isContractAccount = ethers_1.ethers.utils.arrayify(code).length != 0;
    if (!isContractAccount) {
        return isECDSASignatureCorrect(address, msgHash, signature);
    } else {
        return await isEIP1271SignatureCorrect(provider, address, msgHash, signature);
    }
}
// Returns `true` or `false` depending on whether or not the account abstraction's
// signature is correct. Note, that while currently it does not do any `async` actions.
// in the future it will. That's why the `Promise<boolean>` is returned.
async function isMessageSignatureCorrect(provider, address, message, signature) {
    const msgHash = ethers_1.ethers.utils.hashMessage(message);
    return await isSignatureCorrect(provider, address, msgHash, signature);
}
exports.isMessageSignatureCorrect = isMessageSignatureCorrect;
// Returns `true` or `false` depending on whether or not the account abstraction's
// EIP712 signature is correct. Note, that while currently it does not do any `async` actions.
// in the future it will. That's why the `Promise<boolean>` is returned.
async function isTypedDataSignatureCorrect(provider, address, domain, types, value, signature) {
    const msgHash = ethers_1.ethers.utils._TypedDataEncoder.hash(domain, types, value);
    return await isSignatureCorrect(provider, address, msgHash, signature);
}
exports.isTypedDataSignatureCorrect = isTypedDataSignatureCorrect;
async function estimateDefaultBridgeDepositL2Gas(providerL1, providerL2, token, amount, to, from, gasPerPubdataByte) {
    // If the `from` address is not provided, we use a random address, because
    // due to storage slot aggregation, the gas estimation will depend on the address
    // and so estimation for the zero address may be smaller than for the sender.
    from !== null && from !== void 0 ? from : from = ethers_1.ethers.Wallet.createRandom().address;
    if (token == exports.ETH_ADDRESS) {
        return await providerL2.estimateL1ToL2Execute({
            contractAddress: to,
            gasPerPubdataByte: gasPerPubdataByte,
            caller: from,
            calldata: '0x',
            l2Value: amount
        });
    } else {
        const l1ERC20BridgeAddresses = (await providerL2.getDefaultBridgeAddresses()).erc20L1;
        const erc20BridgeAddress = (await providerL2.getDefaultBridgeAddresses()).erc20L2;
        const calldata = await getERC20BridgeCalldata(token, from, to, amount, providerL1);
        return await providerL2.estimateL1ToL2Execute({
            caller: applyL1ToL2Alias(l1ERC20BridgeAddresses),
            contractAddress: erc20BridgeAddress,
            gasPerPubdataByte: gasPerPubdataByte,
            calldata: calldata
        });
    }
}
exports.estimateDefaultBridgeDepositL2Gas = estimateDefaultBridgeDepositL2Gas;
}}),
"[project]/node_modules/zksync-web3/build/src/wallet.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Wallet = void 0;
const signer_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/signer.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const adapters_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/adapters.js [app-client] (ecmascript)");
class Wallet extends (0, adapters_1.AdapterL2)((0, adapters_1.AdapterL1)(ethers_1.ethers.Wallet)) {
    _providerL1() {
        if (this.providerL1 == null) {
            throw new Error('L1 provider missing: use `connectToL1` to specify');
        }
        return this.providerL1;
    }
    _providerL2() {
        return this.provider;
    }
    _signerL1() {
        return this.ethWallet();
    }
    _signerL2() {
        return this;
    }
    ethWallet() {
        return new ethers_1.ethers.Wallet(this._signingKey(), this._providerL1());
    }
    // an alias with a better name
    async getNonce(blockTag) {
        return await this.getTransactionCount(blockTag);
    }
    connect(provider) {
        return new Wallet(this._signingKey(), provider, this.providerL1);
    }
    connectToL1(provider) {
        return new Wallet(this._signingKey(), this.provider, provider);
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        const wallet = super.fromMnemonic(mnemonic, path, wordlist);
        return new Wallet(wallet._signingKey());
    }
    static async fromEncryptedJson(json, password, callback) {
        const wallet = await super.fromEncryptedJson(json, password, callback);
        return new Wallet(wallet._signingKey());
    }
    static fromEncryptedJsonSync(json, password) {
        const wallet = super.fromEncryptedJsonSync(json, password);
        return new Wallet(wallet._signingKey());
    }
    static createRandom(options) {
        const wallet = super.createRandom(options);
        return new Wallet(wallet._signingKey());
    }
    constructor(privateKey, providerL2, providerL1){
        super(privateKey, providerL2);
        if (this.provider != null) {
            const chainId = this.getChainId();
            // @ts-ignore
            this.eip712 = new signer_1.EIP712Signer(this, chainId);
        }
        this.providerL1 = providerL1;
    }
    async populateTransaction(transaction) {
        var _a, _b;
        if (transaction.type == null && transaction.customData == null) {
            // use legacy txs by default
            transaction.type = 0;
        }
        transaction = await super.populateTransaction(transaction);
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
            return transaction;
        }
        transaction.type = utils_1.EIP712_TX_TYPE;
        (_a = transaction.value) !== null && _a !== void 0 ? _a : transaction.value = 0;
        (_b = transaction.data) !== null && _b !== void 0 ? _b : transaction.data = '0x';
        transaction.customData = this._fillCustomData(transaction.customData);
        transaction.gasPrice = await this.provider.getGasPrice();
        return transaction;
    }
    async signTransaction(transaction) {
        var _a;
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
            if (transaction.type == 2 && transaction.maxFeePerGas == null) {
                transaction.maxFeePerGas = await this.provider.getGasPrice();
            }
            return await super.signTransaction(transaction);
        } else {
            (_a = transaction.from) !== null && _a !== void 0 ? _a : transaction.from = this.address;
            if (transaction.from.toLowerCase() != this.address.toLowerCase()) {
                throw new Error('Transaction `from` address mismatch');
            }
            transaction.customData.customSignature = await this.eip712.sign(transaction);
            return (0, utils_1.serialize)(transaction);
        }
    }
    async sendTransaction(transaction) {
        // Typescript isn't smart enough to recognise that wallet.sendTransaction
        // calls provider.sendTransaction which returns our extended type and not ethers' one.
        return await super.sendTransaction(transaction);
    }
}
exports.Wallet = Wallet;
}}),
"[project]/node_modules/zksync-web3/build/src/provider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Web3Provider = exports.Provider = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
var Formatter = ethers_1.providers.Formatter;
const web_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/web/lib.esm/index.js [app-client] (ecmascript)");
const typechain_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/typechain/index.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/types.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)");
const signer_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/signer.js [app-client] (ecmascript)");
let defaultFormatter = null;
class Provider extends ethers_1.ethers.providers.JsonRpcProvider {
    async getTransactionReceipt(transactionHash) {
        await this.getNetwork();
        transactionHash = await transactionHash;
        const params = {
            transactionHash: this.formatter.hash(transactionHash, true)
        };
        return (0, web_1.poll)(async ()=>{
            const result = await this.perform('getTransactionReceipt', params);
            if (result == null) {
                if (this._emitted['t:' + transactionHash] == null) {
                    return null;
                }
                return undefined;
            }
            if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {
                // transaction is rejected in the state-keeper
                return {
                    ...this.formatter.receipt({
                        ...result,
                        confirmations: 1,
                        blockNumber: 0,
                        blockHash: ethers_1.ethers.constants.HashZero
                    }),
                    blockNumber: null,
                    blockHash: null,
                    l1BatchNumber: null,
                    l1BatchTxIndex: null
                };
            }
            if (result.blockHash == null) {
                // receipt is not ready
                return undefined;
            } else {
                const receipt = this.formatter.receipt(result);
                if (receipt.blockNumber == null) {
                    receipt.confirmations = 0;
                } else if (receipt.confirmations == null) {
                    const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = blockNumber - receipt.blockNumber + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    receipt.confirmations = confirmations;
                }
                return receipt;
            }
        }, {
            oncePoll: this
        });
    }
    async getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
    }
    async getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
    }
    static getFormatter() {
        if (defaultFormatter == null) {
            defaultFormatter = new Formatter();
            const number = defaultFormatter.number.bind(defaultFormatter);
            const boolean = defaultFormatter.boolean.bind(defaultFormatter);
            const hash = defaultFormatter.hash.bind(defaultFormatter);
            const address = defaultFormatter.address.bind(defaultFormatter);
            defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.l2Tol1Log = {
                blockNumber: number,
                blockHash: hash,
                l1BatchNumber: Formatter.allowNull(number),
                transactionIndex: number,
                shardId: number,
                isService: boolean,
                sender: address,
                key: hash,
                value: hash,
                transactionHash: hash,
                logIndex: number
            };
            defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);
            defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value)=>Formatter.check(defaultFormatter.formats.l2Tol1Log, value));
            defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);
            defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);
            defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);
            defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);
            defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);
        }
        return defaultFormatter;
    }
    async getBalance(address, blockTag, tokenAddress) {
        const tag = this.formatter.blockTag(blockTag);
        if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {
            // requesting ETH balance
            return await super.getBalance(address, tag);
        } else {
            try {
                let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);
                return await token.balanceOf(address, {
                    blockTag: tag
                });
            } catch  {
                return ethers_1.BigNumber.from(0);
            }
        }
    }
    async l2TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
            return utils_1.ETH_ADDRESS;
        } else {
            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
            return await erc20Bridge.l2TokenAddress(token);
        }
    }
    async l1TokenAddress(token) {
        if (token == utils_1.ETH_ADDRESS) {
            return utils_1.ETH_ADDRESS;
        } else {
            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;
            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);
            return await erc20Bridge.l1TokenAddress(token);
        }
    }
    // This function is used when formatting requests for
    // eth_call and eth_estimateGas. We override it here
    // because we have extra stuff to serialize (customData).
    // This function is for internal use only.
    static hexlifyTransaction(transaction, allowExtra) {
        var _a;
        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {
            ...allowExtra,
            customData: true,
            from: true
        });
        if (transaction.customData == null) {
            return result;
        }
        result.eip712Meta = {
            gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)
        };
        transaction.type = utils_1.EIP712_TX_TYPE;
        if (transaction.customData.factoryDeps) {
            // @ts-ignore
            result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep)=>// TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.
                //  We should change deserialization there.
                Array.from(ethers_1.utils.arrayify(dep)));
        }
        if (transaction.customData.paymasterParams) {
            // @ts-ignore
            result.eip712Meta.paymasterParams = {
                paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),
                paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))
            };
        }
        return result;
    }
    async estimateGas(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
            transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
            // @ts-ignore
            params.transaction.customData = transaction.customData;
        }
        const result = await this.perform('estimateGas', params);
        try {
            return ethers_1.BigNumber.from(result);
        } catch (error) {
            throw new Error(`bad result from backend (estimateGas): ${result}`);
        }
    }
    async estimateGasL1(transaction) {
        await this.getNetwork();
        const params = await ethers_1.utils.resolveProperties({
            transaction: this._getTransactionRequest(transaction)
        });
        if (transaction.customData != null) {
            // @ts-ignore
            params.transaction.customData = transaction.customData;
        }
        const result = await this.send('zks_estimateGasL1ToL2', [
            Provider.hexlifyTransaction(params.transaction, {
                from: true
            })
        ]);
        try {
            return ethers_1.BigNumber.from(result);
        } catch (error) {
            throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);
        }
    }
    async getGasPrice(token) {
        const params = token ? [
            token
        ] : [];
        const price = await this.send('eth_gasPrice', params);
        return ethers_1.BigNumber.from(price);
    }
    constructor(url, network){
        super(url, network);
        this.pollingInterval = 500;
        const blockTag = this.formatter.blockTag.bind(this.formatter);
        this.formatter.blockTag = (tag)=>{
            if (tag == 'committed' || tag == 'finalized') {
                return tag;
            }
            return blockTag(tag);
        };
        this.contractAddresses = {};
        this.formatter.transaction = utils_1.parseTransaction;
    }
    async getMessageProof(blockNumber, sender, messageHash, logIndex) {
        return await this.send('zks_getL2ToL1MsgProof', [
            ethers_1.BigNumber.from(blockNumber).toNumber(),
            sender,
            ethers_1.ethers.utils.hexlify(messageHash),
            logIndex
        ]);
    }
    async getLogProof(txHash, index) {
        return await this.send('zks_getL2ToL1LogProof', [
            ethers_1.ethers.utils.hexlify(txHash),
            index
        ]);
    }
    async getL1BatchBlockRange(l1BatchNumber) {
        const range = await this.send('zks_getL1BatchBlockRange', [
            l1BatchNumber
        ]);
        if (range == null) {
            return null;
        }
        return [
            parseInt(range[0], 16),
            parseInt(range[1], 16)
        ];
    }
    async getMainContractAddress() {
        if (!this.contractAddresses.mainContract) {
            this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);
        }
        return this.contractAddresses.mainContract;
    }
    async getTestnetPaymasterAddress() {
        // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed
        // on the fly by the server and should not be relied to be constant
        return await this.send('zks_getTestnetPaymaster', []);
    }
    async getDefaultBridgeAddresses() {
        if (!this.contractAddresses.erc20BridgeL1) {
            let addresses = await this.send('zks_getBridgeContracts', []);
            this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
            this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
        }
        return {
            erc20L1: this.contractAddresses.erc20BridgeL1,
            erc20L2: this.contractAddresses.erc20BridgeL2
        };
    }
    async getConfirmedTokens(start = 0, limit = 255) {
        const tokens = await this.send('zks_getConfirmedTokens', [
            start,
            limit
        ]);
        return tokens.map((token)=>({
                address: token.l2Address,
                ...token
            }));
    }
    async getTokenPrice(token) {
        return await this.send('zks_getTokenPrice', [
            token
        ]);
    }
    async getAllAccountBalances(address) {
        let balances = await this.send('zks_getAllAccountBalances', [
            address
        ]);
        for(let token in balances){
            balances[token] = ethers_1.BigNumber.from(balances[token]);
        }
        return balances;
    }
    async l1ChainId() {
        const res = await this.send('zks_L1ChainId', []);
        return ethers_1.BigNumber.from(res).toNumber();
    }
    async getL1BatchNumber() {
        const number = await this.send('zks_L1BatchNumber', []);
        return ethers_1.BigNumber.from(number).toNumber();
    }
    async getL1BatchDetails(number) {
        return await this.send('zks_getL1BatchDetails', [
            number
        ]);
    }
    async getBlockDetails(number) {
        return await this.send('zks_getBlockDetails', [
            number
        ]);
    }
    async getTransactionDetails(txHash) {
        return await this.send('zks_getTransactionDetails', [
            txHash
        ]);
    }
    async getWithdrawTx(transaction) {
        var _a, _b, _c;
        var _d;
        const { ...tx } = transaction;
        if (tx.to == null && tx.from == null) {
            throw new Error('withdrawal target address is undefined');
        }
        (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = tx.from;
        (_b = tx.overrides) !== null && _b !== void 0 ? _b : tx.overrides = {};
        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : _d.from = tx.from;
        if ((0, utils_1.isETH)(tx.token)) {
            if (!tx.overrides.value) {
                tx.overrides.value = tx.amount;
            }
            const passedValue = ethers_1.BigNumber.from(tx.overrides.value);
            if (!passedValue.eq(tx.amount)) {
                // To avoid users shooting themselves into the foot, we will always use the amount to withdraw
                // as the value
                throw new Error('The tx.value is not equal to the value withdrawn');
            }
            const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);
            return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);
        }
        if (tx.bridgeAddress == null) {
            const bridges = await this.getDefaultBridgeAddresses();
            tx.bridgeAddress = bridges.erc20L2;
        }
        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);
        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);
    }
    async estimateGasWithdraw(transaction) {
        const withdrawTx = await this.getWithdrawTx(transaction);
        return await this.estimateGas(withdrawTx);
    }
    async getTransferTx(transaction) {
        var _a, _b;
        var _c;
        const { ...tx } = transaction;
        (_a = tx.overrides) !== null && _a !== void 0 ? _a : tx.overrides = {};
        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : _c.from = tx.from;
        if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {
            return {
                ...await ethers_1.ethers.utils.resolveProperties(tx.overrides),
                to: tx.to,
                value: tx.amount
            };
        } else {
            const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);
            return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);
        }
    }
    async estimateGasTransfer(transaction) {
        const transferTx = await this.getTransferTx(transaction);
        return await this.estimateGas(transferTx);
    }
    static getDefaultProvider() {
        // TODO (SMA-1606): Add different urls for different networks.
        return new Provider(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');
    }
    async newFilter(filter) {
        filter = await filter;
        const id = await this.send('eth_newFilter', [
            this._prepareFilter(filter)
        ]);
        return ethers_1.BigNumber.from(id);
    }
    async newBlockFilter() {
        const id = await this.send('eth_newBlockFilter', []);
        return ethers_1.BigNumber.from(id);
    }
    async newPendingTransactionsFilter() {
        const id = await this.send('eth_newPendingTransactionFilter', []);
        return ethers_1.BigNumber.from(id);
    }
    async getFilterChanges(idx) {
        const logs = await this.send('eth_getFilterChanges', [
            idx.toHexString()
        ]);
        return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);
    }
    async getLogs(filter = {}) {
        filter = await filter;
        const logs = await this.send('eth_getLogs', [
            this._prepareFilter(filter)
        ]);
        return this._parseLogs(logs);
    }
    _parseLogs(logs) {
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    }
    _prepareFilter(filter) {
        return {
            ...filter,
            fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),
            toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)
        };
    }
    _wrapTransaction(tx, hash) {
        const response = super._wrapTransaction(tx, hash);
        response.waitFinalize = async ()=>{
            const receipt = await response.wait();
            while(true){
                const block = await this.getBlock('finalized');
                if (receipt.blockNumber <= block.number) {
                    return await this.getTransactionReceipt(receipt.transactionHash);
                } else {
                    await (0, utils_1.sleep)(this.pollingInterval);
                }
            }
        };
        return response;
    }
    // This is inefficient. Status should probably be indicated in the transaction receipt.
    async getTransactionStatus(txHash) {
        const tx = await this.getTransaction(txHash);
        if (tx == null) {
            return types_1.TransactionStatus.NotFound;
        }
        if (tx.blockNumber == null) {
            return types_1.TransactionStatus.Processing;
        }
        const verifiedBlock = await this.getBlock('finalized');
        if (tx.blockNumber <= verifiedBlock.number) {
            return types_1.TransactionStatus.Finalized;
        }
        return types_1.TransactionStatus.Committed;
    }
    async getTransaction(hash) {
        hash = await hash;
        const tx = await super.getTransaction(hash);
        return tx ? this._wrapTransaction(tx, hash) : null;
    }
    async sendTransaction(transaction) {
        return await super.sendTransaction(transaction);
    }
    async getL2TransactionFromPriorityOp(l1TxResponse) {
        const receipt = await l1TxResponse.wait();
        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
        let status = null;
        do {
            status = await this.getTransactionStatus(l2Hash);
            await (0, utils_1.sleep)(this.pollingInterval);
        }while (status == types_1.TransactionStatus.NotFound)
        return await this.getTransaction(l2Hash);
    }
    async getPriorityOpResponse(l1TxResponse) {
        const l2Response = {
            ...l1TxResponse
        };
        l2Response.waitL1Commit = l2Response.wait;
        l2Response.wait = async ()=>{
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.wait();
        };
        l2Response.waitFinalize = async ()=>{
            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
            return await l2Tx.waitFinalize();
        };
        return l2Response;
    }
    async getContractAccountInfo(address) {
        const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);
        const data = await deployerContract.getAccountInfo(address);
        return {
            supportedAAVersion: data.supportedAAVersion,
            nonceOrdering: data.nonceOrdering
        };
    }
    // TODO (EVM-3): support refundRecipient for fee estimation
    async estimateL1ToL2Execute(transaction) {
        var _a, _b;
        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;
        // If the `from` address is not provided, we use a random address, because
        // due to storage slot aggregation, the gas estimation will depend on the address
        // and so estimation for the zero address may be smaller than for the sender.
        (_b = transaction.caller) !== null && _b !== void 0 ? _b : transaction.caller = ethers_1.ethers.Wallet.createRandom().address;
        const customData = {
            gasPerPubdataByte: transaction.gasPerPubdataByte
        };
        if (transaction.factoryDeps) {
            Object.assign(customData, {
                factoryDeps: transaction.factoryDeps
            });
        }
        const fee = await this.estimateGasL1({
            from: transaction.caller,
            data: transaction.calldata,
            to: transaction.contractAddress,
            value: transaction.l2Value,
            customData
        });
        return fee;
    }
}
exports.Provider = Provider;
class Web3Provider extends Provider {
    constructor(provider, network){
        if (provider == null) {
            throw new Error('missing provider');
        }
        if (!provider.request) {
            throw new Error('provider must implement eip-1193');
        }
        let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');
        super(path, network);
        this.provider = provider;
    }
    async send(method, params) {
        params !== null && params !== void 0 ? params : params = [];
        // Metamask complains about eth_sign (and on some versions hangs)
        if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {
            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign
            method = 'personal_sign';
            params = [
                params[1],
                params[0]
            ];
        }
        return await this.provider.request({
            method,
            params
        });
    }
    getSigner(addressOrIndex) {
        return signer_1.Signer.from(super.getSigner(addressOrIndex));
    }
    async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = ethers_1.BigNumber.from(21000);
        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;
        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;
    }
}
exports.Web3Provider = Web3Provider;
}}),
"[project]/node_modules/zksync-web3/build/src/contract.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContractFactory = exports.Contract = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/types.js [app-client] (ecmascript)");
var ethers_2 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Contract", {
    enumerable: true,
    get: function() {
        return ethers_2.Contract;
    }
});
class ContractFactory extends ethers_1.ethers.ContractFactory {
    constructor(abi, bytecode, signer, deploymentType){
        super(abi, bytecode, signer);
        this.deploymentType = deploymentType || 'create';
    }
    encodeCalldata(salt, bytecodeHash, constructorCalldata) {
        if (this.deploymentType == 'create') {
            return utils_1.CONTRACT_DEPLOYER.encodeFunctionData('create', [
                salt,
                bytecodeHash,
                constructorCalldata
            ]);
        } else if (this.deploymentType == 'createAccount') {
            return utils_1.CONTRACT_DEPLOYER.encodeFunctionData('createAccount', [
                salt,
                bytecodeHash,
                constructorCalldata,
                types_1.AccountAbstractionVersion.Version1
            ]);
        } else {
            throw new Error(`Unsupported deployment type ${this.deploymentType}`);
        }
    }
    getDeployTransaction(...args) {
        var _a, _b, _c;
        var _d, _e;
        // TODO (SMA-1585): Users should be able to provide the salt.
        let salt = '0x0000000000000000000000000000000000000000000000000000000000000000';
        // The overrides will be popped out in this call:
        const txRequest = super.getDeployTransaction(...args);
        // Removing overrides
        if (this.interface.deploy.inputs.length + 1 == args.length) {
            args.pop();
        }
        // Salt argument is not used, so we provide a placeholder value.
        const bytecodeHash = (0, utils_1.hashBytecode)(this.bytecode);
        const constructorCalldata = ethers_1.utils.arrayify(this.interface.encodeDeploy(args));
        const deployCalldata = this.encodeCalldata(salt, bytecodeHash, constructorCalldata);
        txRequest.type = utils_1.EIP712_TX_TYPE;
        txRequest.to = utils_1.CONTRACT_DEPLOYER_ADDRESS;
        txRequest.data = deployCalldata;
        (_a = txRequest.customData) !== null && _a !== void 0 ? _a : txRequest.customData = {};
        (_b = (_d = txRequest.customData).factoryDeps) !== null && _b !== void 0 ? _b : _d.factoryDeps = [];
        (_c = (_e = txRequest.customData).gasPerPubdata) !== null && _c !== void 0 ? _c : _e.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        // The number of factory deps is relatively low, so it is efficient enough.
        if (!txRequest.customData.factoryDeps.includes(this.bytecode)) {
            txRequest.customData.factoryDeps.push(this.bytecode);
        }
        return txRequest;
    }
    async deploy(...args) {
        const contract = await super.deploy(...args);
        const deployTxReceipt = await contract.deployTransaction.wait();
        const deployedAddresses = (0, utils_1.getDeployedContracts)(deployTxReceipt).map((info)=>info.deployedAddress);
        const contractWithCorrectAddress = new ethers_1.ethers.Contract(deployedAddresses[deployedAddresses.length - 1], contract.interface, contract.signer);
        ethers_1.utils.defineReadOnly(contractWithCorrectAddress, 'deployTransaction', contract.deployTransaction);
        return contractWithCorrectAddress;
    }
}
exports.ContractFactory = ContractFactory;
}}),
"[project]/node_modules/zksync-web3/build/src/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Contract = exports.ContractFactory = exports.Provider = exports.Web3Provider = exports.Wallet = exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.types = exports.utils = void 0;
exports.utils = __importStar(__turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/utils.js [app-client] (ecmascript)"));
exports.types = __importStar(__turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/types.js [app-client] (ecmascript)"));
var signer_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/signer.js [app-client] (ecmascript)");
Object.defineProperty(exports, "EIP712Signer", {
    enumerable: true,
    get: function() {
        return signer_1.EIP712Signer;
    }
});
Object.defineProperty(exports, "Signer", {
    enumerable: true,
    get: function() {
        return signer_1.Signer;
    }
});
Object.defineProperty(exports, "L1Signer", {
    enumerable: true,
    get: function() {
        return signer_1.L1Signer;
    }
});
var wallet_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/wallet.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Wallet", {
    enumerable: true,
    get: function() {
        return wallet_1.Wallet;
    }
});
var provider_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/provider.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Web3Provider", {
    enumerable: true,
    get: function() {
        return provider_1.Web3Provider;
    }
});
Object.defineProperty(exports, "Provider", {
    enumerable: true,
    get: function() {
        return provider_1.Provider;
    }
});
var contract_1 = __turbopack_context__.r("[project]/node_modules/zksync-web3/build/src/contract.js [app-client] (ecmascript)");
Object.defineProperty(exports, "ContractFactory", {
    enumerable: true,
    get: function() {
        return contract_1.ContractFactory;
    }
});
Object.defineProperty(exports, "Contract", {
    enumerable: true,
    get: function() {
        return contract_1.Contract;
    }
});
}}),
}]);

//# sourceMappingURL=node_modules_zksync-web3_0eb50ab2._.js.map