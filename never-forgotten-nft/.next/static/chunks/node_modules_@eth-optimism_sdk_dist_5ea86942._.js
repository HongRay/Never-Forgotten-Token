(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/@eth-optimism/sdk/dist/utils/assert.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assert = void 0;
const assert = (condition, message)=>{
    if (!condition) {
        throw new Error(message);
    }
};
exports.assert = assert; //# sourceMappingURL=assert.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toAddress = exports.toNumber = exports.toBigNumber = exports.toTransactionHash = exports.toJsonRpcProvider = exports.toProvider = exports.toSignerOrProvider = void 0;
const abstract_provider_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/abstract-provider/lib.esm/index.js [app-client] (ecmascript)");
const abstract_signer_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/abstract-signer/lib.esm/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const assert_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/assert.js [app-client] (ecmascript)");
const toSignerOrProvider = (signerOrProvider)=>{
    if (typeof signerOrProvider === 'string') {
        return new ethers_1.ethers.providers.JsonRpcProvider(signerOrProvider);
    } else if (abstract_provider_1.Provider.isProvider(signerOrProvider)) {
        return signerOrProvider;
    } else if (abstract_signer_1.Signer.isSigner(signerOrProvider)) {
        return signerOrProvider;
    } else {
        throw new Error('Invalid provider');
    }
};
exports.toSignerOrProvider = toSignerOrProvider;
const toProvider = (provider)=>{
    if (typeof provider === 'string') {
        return new ethers_1.ethers.providers.JsonRpcProvider(provider);
    } else if (abstract_provider_1.Provider.isProvider(provider)) {
        return provider;
    } else {
        throw new Error('Invalid provider');
    }
};
exports.toProvider = toProvider;
const toJsonRpcProvider = (provider)=>{
    const coerced = (0, exports.toProvider)(provider);
    if ('send' in coerced) {
        return coerced;
    } else {
        throw new Error('Invalid JsonRpcProvider, does not have "send" function');
    }
};
exports.toJsonRpcProvider = toJsonRpcProvider;
const toTransactionHash = (transaction)=>{
    if (typeof transaction === 'string') {
        (0, assert_1.assert)(ethers_1.ethers.utils.isHexString(transaction, 32), 'Invalid transaction hash');
        return transaction;
    } else if (transaction.transactionHash) {
        return transaction.transactionHash;
    } else if (transaction.hash) {
        return transaction.hash;
    } else {
        throw new Error('Invalid transaction');
    }
};
exports.toTransactionHash = toTransactionHash;
const toBigNumber = (num)=>{
    return ethers_1.ethers.BigNumber.from(num);
};
exports.toBigNumber = toBigNumber;
const toNumber = (num)=>{
    return (0, exports.toBigNumber)(num).toNumber();
};
exports.toNumber = toNumber;
const toAddress = (addr)=>{
    if (typeof addr === 'string') {
        (0, assert_1.assert)(ethers_1.ethers.utils.isAddress(addr), 'Invalid address');
        return ethers_1.ethers.utils.getAddress(addr);
    } else {
        (0, assert_1.assert)(ethers_1.ethers.utils.isAddress(addr.address), 'Invalid address');
        return ethers_1.ethers.utils.getAddress(addr.address);
    }
};
exports.toAddress = toAddress; //# sourceMappingURL=coercion.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/misc-utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.omit = void 0;
const omit = (obj, ...keys)=>{
    const copy = Object.assign({}, obj);
    for (const key of keys){
        delete copy[key];
    }
    return copy;
};
exports.omit = omit; //# sourceMappingURL=misc-utils.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/chain-constants.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BRIDGE_ADAPTER_DATA = exports.CONTRACT_ADDRESSES = exports.IGNORABLE_CONTRACTS = exports.DEFAULT_L2_CONTRACT_ADDRESSES = exports.CHAIN_BLOCK_TIMES = exports.DEPOSIT_CONFIRMATION_BLOCKS = void 0;
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const adapters_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/index.js [app-client] (ecmascript)");
const interfaces_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)");
const portalAddresses = {
    mainnet: '0xbEb5Fc579115071764c7423A4f12eDde41f106Ed',
    goerli: '0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383',
    sepolia: '0x16Fc5058F25648194471939df75CF27A2fdC48BC'
};
const l2OutputOracleAddresses = {
    mainnet: '0xdfe97868233d1aa22e815a266982f2cf17685a27',
    goerli: '0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0',
    sepolia: '0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F'
};
const addressManagerAddresses = {
    mainnet: '0xdE1FCfB0851916CA5101820A69b13a4E276bd81F',
    goerli: '0xa6f73589243a6A7a9023b1Fa0651b1d89c177111',
    sepolia: '0x9bFE9c5609311DF1c011c47642253B78a4f33F4B'
};
const l1StandardBridgeAddresses = {
    mainnet: '0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1',
    goerli: '0x636Af16bf2f682dD3109e60102b8E1A089FedAa8',
    sepolia: '0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1'
};
const l1CrossDomainMessengerAddresses = {
    mainnet: '0x25ace71c97B33Cc4729CF772ae268934F7ab5fA1',
    goerli: '0x5086d1eEF304eb5284A0f6720f79403b4e9bE294',
    sepolia: '0x58Cc85b8D04EA49cC6DBd3CbFFd00B4B8D6cb3ef'
};
const disputeGameFactoryAddresses = {
    mainnet: '0xe5965Ab5962eDc7477C8520243A95517CD252fA9',
    goerli: ethers_1.ethers.constants.AddressZero,
    sepolia: '0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1'
};
const stateCommitmentChainAddresses = {
    mainnet: '0xBe5dAb4A2e9cd0F27300dB4aB94BeE3A233AEB19',
    goerli: '0x9c945aC97Baf48cB784AbBB61399beB71aF7A378',
    sepolia: ethers_1.ethers.constants.AddressZero
};
const canonicalTransactionChainAddresses = {
    mainnet: '0x5E4e65926BA27467555EB562121fac00D24E9dD2',
    goerli: '0x607F755149cFEB3a14E1Dc3A4E2450Cde7dfb04D',
    sepolia: ethers_1.ethers.constants.AddressZero
};
exports.DEPOSIT_CONFIRMATION_BLOCKS = {
    [interfaces_1.L2ChainID.OPTIMISM]: 50,
    [interfaces_1.L2ChainID.OPTIMISM_GOERLI]: 12,
    [interfaces_1.L2ChainID.OPTIMISM_SEPOLIA]: 12,
    [interfaces_1.L2ChainID.OPTIMISM_HARDHAT_LOCAL]: 2,
    [interfaces_1.L2ChainID.OPTIMISM_HARDHAT_DEVNET]: 2,
    [interfaces_1.L2ChainID.OPTIMISM_BEDROCK_ALPHA_TESTNET]: 12,
    [interfaces_1.L2ChainID.BASE_GOERLI]: 25,
    [interfaces_1.L2ChainID.BASE_SEPOLIA]: 25,
    [interfaces_1.L2ChainID.BASE_MAINNET]: 10,
    [interfaces_1.L2ChainID.ZORA_GOERLI]: 12,
    [interfaces_1.L2ChainID.ZORA_MAINNET]: 50,
    [interfaces_1.L2ChainID.MODE_SEPOLIA]: 25,
    [interfaces_1.L2ChainID.MODE_MAINNET]: 50
};
exports.CHAIN_BLOCK_TIMES = {
    [interfaces_1.L1ChainID.MAINNET]: 13,
    [interfaces_1.L1ChainID.GOERLI]: 15,
    [interfaces_1.L1ChainID.SEPOLIA]: 15,
    [interfaces_1.L1ChainID.HARDHAT_LOCAL]: 1,
    [interfaces_1.L1ChainID.BEDROCK_LOCAL_DEVNET]: 15
};
exports.DEFAULT_L2_CONTRACT_ADDRESSES = {
    L2CrossDomainMessenger: core_utils_1.predeploys.L2CrossDomainMessenger,
    L2ToL1MessagePasser: core_utils_1.predeploys.L2ToL1MessagePasser,
    L2StandardBridge: core_utils_1.predeploys.L2StandardBridge,
    OVM_L1BlockNumber: core_utils_1.predeploys.L1BlockNumber,
    OVM_L2ToL1MessagePasser: core_utils_1.predeploys.L2ToL1MessagePasser,
    OVM_DeployerWhitelist: core_utils_1.predeploys.DeployerWhitelist,
    OVM_ETH: core_utils_1.predeploys.LegacyERC20ETH,
    OVM_GasPriceOracle: core_utils_1.predeploys.GasPriceOracle,
    OVM_SequencerFeeVault: core_utils_1.predeploys.SequencerFeeVault,
    WETH: core_utils_1.predeploys.WETH9,
    BedrockMessagePasser: core_utils_1.predeploys.L2ToL1MessagePasser
};
const getL1ContractsByNetworkName = (network)=>{
    return {
        AddressManager: addressManagerAddresses[network],
        L1CrossDomainMessenger: l1CrossDomainMessengerAddresses[network],
        L1StandardBridge: l1StandardBridgeAddresses[network],
        StateCommitmentChain: stateCommitmentChainAddresses[network],
        CanonicalTransactionChain: canonicalTransactionChainAddresses[network],
        BondManager: ethers_1.ethers.constants.AddressZero,
        OptimismPortal: portalAddresses[network],
        L2OutputOracle: l2OutputOracleAddresses[network],
        OptimismPortal2: portalAddresses[network],
        DisputeGameFactory: disputeGameFactoryAddresses[network]
    };
};
exports.IGNORABLE_CONTRACTS = [
    'OptimismPortal2',
    'DisputeGameFactory'
];
exports.CONTRACT_ADDRESSES = {
    [interfaces_1.L2ChainID.OPTIMISM]: {
        l1: getL1ContractsByNetworkName('mainnet'),
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.OPTIMISM_GOERLI]: {
        l1: getL1ContractsByNetworkName('goerli'),
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.OPTIMISM_SEPOLIA]: {
        l1: getL1ContractsByNetworkName('sepolia'),
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.OPTIMISM_HARDHAT_LOCAL]: {
        l1: {
            AddressManager: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
            L1CrossDomainMessenger: '0x8A791620dd6260079BF849Dc5567aDC3F2FdC318',
            L1StandardBridge: '0x610178dA211FEF7D417bC0e6FeD39F05609AD788',
            StateCommitmentChain: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9',
            CanonicalTransactionChain: '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9',
            BondManager: '0x5FC8d32690cc91D4c39d9d3abcBD16989F875707',
            OptimismPortal: '0x0000000000000000000000000000000000000000',
            L2OutputOracle: '0x0000000000000000000000000000000000000000',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.OPTIMISM_HARDHAT_DEVNET]: {
        l1: {
            AddressManager: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
            L1CrossDomainMessenger: '0x8A791620dd6260079BF849Dc5567aDC3F2FdC318',
            L1StandardBridge: '0x610178dA211FEF7D417bC0e6FeD39F05609AD788',
            StateCommitmentChain: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9',
            CanonicalTransactionChain: '0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9',
            BondManager: '0x5FC8d32690cc91D4c39d9d3abcBD16989F875707',
            OptimismPortal: '0x0000000000000000000000000000000000000000',
            L2OutputOracle: '0x0000000000000000000000000000000000000000',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.OPTIMISM_BEDROCK_ALPHA_TESTNET]: {
        l1: {
            AddressManager: '0xb4e08DcE1F323608229265c9d4125E22a4B9dbAF',
            L1CrossDomainMessenger: '0x838a6DC4E37CA45D4Ef05bb776bf05eEf50798De',
            L1StandardBridge: '0xFf94B6C486350aD92561Ba09bad3a59df764Da92',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0xA581Ca3353DB73115C4625FFC7aDF5dB379434A8',
            L2OutputOracle: '0x3A234299a14De50027eA65dCdf1c0DaC729e04A6',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.BASE_GOERLI]: {
        l1: {
            AddressManager: '0x4Cf6b56b14c6CFcB72A75611080514F94624c54e',
            L1CrossDomainMessenger: '0x8e5693140eA606bcEB98761d9beB1BC87383706D',
            L1StandardBridge: '0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA',
            L2OutputOracle: '0x2A35891ff30313CcFa6CE88dcf3858bb075A2298',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.BASE_SEPOLIA]: {
        l1: {
            AddressManager: '0x709c2B8ef4A9feFc629A8a2C1AF424Dc5BD6ad1B',
            L1CrossDomainMessenger: '0xC34855F4De64F1840e5686e64278da901e261f20',
            L1StandardBridge: '0xfd0Bf71F60660E2f608ed56e1659C450eB113120',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0x49f53e41452C74589E85cA1677426Ba426459e85',
            L2OutputOracle: '0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.BASE_MAINNET]: {
        l1: {
            AddressManager: '0x8EfB6B5c4767B09Dc9AA6Af4eAA89F749522BaE2',
            L1CrossDomainMessenger: '0x866E82a600A1414e583f7F13623F1aC5d58b0Afa',
            L1StandardBridge: '0x3154Cf16ccdb4C6d922629664174b904d80F2C35',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0x49048044D57e1C92A77f79988d21Fa8fAF74E97e',
            L2OutputOracle: '0x56315b90c40730925ec5485cf004d835058518A0',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.ZORA_GOERLI]: {
        l1: {
            AddressManager: '0x54f4676203dEDA6C08E0D40557A119c602bFA246',
            L1CrossDomainMessenger: '0xD87342e16352D33170557A7dA1e5fB966a60FafC',
            L1StandardBridge: '0x7CC09AC2452D6555d5e0C213Ab9E2d44eFbFc956',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0xDb9F51790365e7dc196e7D072728df39Be958ACe',
            L2OutputOracle: '0xdD292C9eEd00f6A32Ff5245d0BCd7f2a15f24e00',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.ZORA_MAINNET]: {
        l1: {
            AddressManager: '0xEF8115F2733fb2033a7c756402Fc1deaa56550Ef',
            L1CrossDomainMessenger: '0xdC40a14d9abd6F410226f1E6de71aE03441ca506',
            L1StandardBridge: '0x3e2Ea9B92B7E48A52296fD261dc26fd995284631',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0x1a0ad011913A150f69f6A19DF447A0CfD9551054',
            L2OutputOracle: '0x9E6204F750cD866b299594e2aC9eA824E2e5f95c',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.MODE_SEPOLIA]: {
        l1: {
            AddressManager: '0x83D45725d6562d8CD717673D6bb4c67C07dC1905',
            L1CrossDomainMessenger: '0xc19a60d9E8C27B9A43527c3283B4dd8eDC8bE15C',
            L1StandardBridge: '0xbC5C679879B2965296756CD959C3C739769995E2',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0x320e1580effF37E008F1C92700d1eBa47c1B23fD',
            L2OutputOracle: '0x2634BD65ba27AB63811c74A63118ACb312701Bfa',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    },
    [interfaces_1.L2ChainID.MODE_MAINNET]: {
        l1: {
            AddressManager: '0x50eF494573f28Cad6B64C31b7a00Cdaa48306e15',
            L1CrossDomainMessenger: '0x95bDCA6c8EdEB69C98Bd5bd17660BaCef1298A6f',
            L1StandardBridge: '0x735aDBbE72226BD52e818E7181953f42E3b0FF21',
            StateCommitmentChain: '0x0000000000000000000000000000000000000000',
            CanonicalTransactionChain: '0x0000000000000000000000000000000000000000',
            BondManager: '0x0000000000000000000000000000000000000000',
            OptimismPortal: '0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07',
            L2OutputOracle: '0x4317ba146D4933D889518a3e5E11Fe7a53199b04',
            OptimismPortal2: '0x0000000000000000000000000000000000000000',
            DisputeGameFactory: '0x0000000000000000000000000000000000000000'
        },
        l2: exports.DEFAULT_L2_CONTRACT_ADDRESSES
    }
};
exports.BRIDGE_ADAPTER_DATA = {
    [interfaces_1.L2ChainID.OPTIMISM]: {
        wstETH: {
            Adapter: adapters_1.DAIBridgeAdapter,
            l1Bridge: '0x76943C0D61395d8F2edF9060e1533529cAe05dE6',
            l2Bridge: '0x8E01013243a96601a86eb3153F0d9Fa4fbFb6957'
        },
        BitBTC: {
            Adapter: adapters_1.StandardBridgeAdapter,
            l1Bridge: '0xaBA2c5F108F7E820C049D5Af70B16ac266c8f128',
            l2Bridge: '0x158F513096923fF2d3aab2BcF4478536de6725e2'
        },
        DAI: {
            Adapter: adapters_1.DAIBridgeAdapter,
            l1Bridge: '0x10E6593CDda8c58a1d0f14C5164B376352a55f2F',
            l2Bridge: '0x467194771dAe2967Aef3ECbEDD3Bf9a310C76C65'
        },
        ECO: {
            Adapter: adapters_1.ECOBridgeAdapter,
            l1Bridge: '0xAa029BbdC947F5205fBa0F3C11b592420B58f824',
            l2Bridge: '0xAa029BbdC947F5205fBa0F3C11b592420B58f824'
        }
    },
    [interfaces_1.L2ChainID.OPTIMISM_GOERLI]: {
        DAI: {
            Adapter: adapters_1.DAIBridgeAdapter,
            l1Bridge: '0x05a388Db09C2D44ec0b00Ee188cD42365c42Df23',
            l2Bridge: '0x467194771dAe2967Aef3ECbEDD3Bf9a310C76C65'
        },
        ECO: {
            Adapter: adapters_1.ECOBridgeAdapter,
            l1Bridge: '0x9A4464D6bFE006715382D39D183AAf66c952a3e0',
            l2Bridge: '0x6aA809bAeA2e4C057b3994127cB165119c6fc3B2'
        }
    }
}; //# sourceMappingURL=chain-constants.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/contracts.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBridgeAdapters = exports.getAllOEContracts = exports.getOEContract = exports.getContractInterfaceBedrock = void 0;
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/contracts/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const adapters_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/index.js [app-client] (ecmascript)");
const DisputeGameFactory_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/DisputeGameFactory.json (json)"));
const FaultDisputeGame_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/FaultDisputeGame.json (json)"));
const GasPriceOracle_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/GasPriceOracle.json (json)"));
const L1Block_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L1Block.json (json)"));
const L1CrossDomainMessenger_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L1CrossDomainMessenger.json (json)"));
const L1ERC721Bridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L1ERC721Bridge.json (json)"));
const L1StandardBridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L1StandardBridge.json (json)"));
const L2CrossDomainMessenger_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2CrossDomainMessenger.json (json)"));
const L2ERC721Bridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2ERC721Bridge.json (json)"));
const L2OutputOracle_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2OutputOracle.json (json)"));
const L2StandardBridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2StandardBridge.json (json)"));
const L2ToL1MessagePasser_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2ToL1MessagePasser.json (json)"));
const OptimismMintableERC20_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/OptimismMintableERC20.json (json)"));
const OptimismMintableERC20Factory_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/OptimismMintableERC20Factory.json (json)"));
const OptimismPortal_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/OptimismPortal.json (json)"));
const OptimismPortal2_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/OptimismPortal2.json (json)"));
const ProxyAdmin_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/ProxyAdmin.json (json)"));
const chain_constants_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/chain-constants.js [app-client] (ecmascript)");
const coercion_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)");
const NAME_REMAPPING = {
    AddressManager: 'Lib_AddressManager',
    OVM_L1BlockNumber: 'iOVM_L1BlockNumber',
    WETH: 'WETH9',
    BedrockMessagePasser: 'L2ToL1MessagePasser'
};
const getContractInterfaceBedrock = (name)=>{
    let artifact = '';
    switch(name){
        case 'Lib_AddressManager':
        case 'AddressManager':
            artifact = '';
            break;
        case 'L1CrossDomainMessenger':
            artifact = L1CrossDomainMessenger_json_1.default;
            break;
        case 'L1ERC721Bridge':
            artifact = L1ERC721Bridge_json_1.default;
            break;
        case 'L2OutputOracle':
            artifact = L2OutputOracle_json_1.default;
            break;
        case 'OptimismMintableERC20Factory':
            artifact = OptimismMintableERC20Factory_json_1.default;
            break;
        case 'ProxyAdmin':
            artifact = ProxyAdmin_json_1.default;
            break;
        case 'L1StandardBridge':
            artifact = L1StandardBridge_json_1.default;
            break;
        case 'L2StandardBridge':
            artifact = L2StandardBridge_json_1.default;
            break;
        case 'OptimismPortal':
            artifact = OptimismPortal_json_1.default;
            break;
        case 'L2CrossDomainMessenger':
            artifact = L2CrossDomainMessenger_json_1.default;
            break;
        case 'OptimismMintableERC20':
            artifact = OptimismMintableERC20_json_1.default;
            break;
        case 'L2ERC721Bridge':
            artifact = L2ERC721Bridge_json_1.default;
            break;
        case 'L1Block':
            artifact = L1Block_json_1.default;
            break;
        case 'L2ToL1MessagePasser':
            artifact = L2ToL1MessagePasser_json_1.default;
            break;
        case 'GasPriceOracle':
            artifact = GasPriceOracle_json_1.default;
            break;
        case 'DisputeGameFactory':
            artifact = DisputeGameFactory_json_1.default;
            break;
        case 'OptimismPortal2':
            artifact = OptimismPortal2_json_1.default;
            break;
        case 'FaultDisputeGame':
            artifact = FaultDisputeGame_json_1.default;
            break;
    }
    return new ethers_1.ethers.utils.Interface(artifact.abi);
};
exports.getContractInterfaceBedrock = getContractInterfaceBedrock;
const getOEContract = (contractName, l2ChainId, opts = {})=>{
    const addresses = chain_constants_1.CONTRACT_ADDRESSES[l2ChainId];
    if (addresses === undefined && opts.address === undefined) {
        if (chain_constants_1.IGNORABLE_CONTRACTS.includes(contractName)) {
            return undefined;
        } else {
            throw new Error(`cannot get contract ${contractName} for unknown L2 chain ID ${l2ChainId}, you must provide an address`);
        }
    }
    const name = NAME_REMAPPING[contractName] || contractName;
    let iface;
    try {
        iface = (0, exports.getContractInterfaceBedrock)(name);
    } catch (err) {
        iface = (0, contracts_1.getContractInterface)(name);
    }
    return new ethers_1.Contract((0, coercion_1.toAddress)(opts.address || addresses.l1[contractName] || addresses.l2[contractName]), iface, opts.signerOrProvider);
};
exports.getOEContract = getOEContract;
const getAllOEContracts = (l2ChainId, opts = {})=>{
    var _a, _b, _c, _d;
    const addresses = chain_constants_1.CONTRACT_ADDRESSES[l2ChainId] || {
        l1: {
            AddressManager: undefined,
            L1CrossDomainMessenger: undefined,
            L1StandardBridge: undefined,
            StateCommitmentChain: undefined,
            CanonicalTransactionChain: undefined,
            BondManager: undefined,
            OptimismPortal: undefined,
            L2OutputOracle: undefined,
            DisputeGameFactory: undefined,
            OptimismPortal2: undefined
        },
        l2: chain_constants_1.DEFAULT_L2_CONTRACT_ADDRESSES
    };
    const l1Contracts = {};
    for (const [contractName, contractAddress] of Object.entries(addresses.l1)){
        l1Contracts[contractName] = (0, exports.getOEContract)(contractName, l2ChainId, {
            address: ((_b = (_a = opts.overrides) === null || _a === void 0 ? void 0 : _a.l1) === null || _b === void 0 ? void 0 : _b[contractName]) || contractAddress,
            signerOrProvider: opts.l1SignerOrProvider
        });
    }
    const l2Contracts = {};
    for (const [contractName, contractAddress] of Object.entries(addresses.l2)){
        l2Contracts[contractName] = (0, exports.getOEContract)(contractName, l2ChainId, {
            address: ((_d = (_c = opts.overrides) === null || _c === void 0 ? void 0 : _c.l2) === null || _d === void 0 ? void 0 : _d[contractName]) || contractAddress,
            signerOrProvider: opts.l2SignerOrProvider
        });
    }
    return {
        l1: l1Contracts,
        l2: l2Contracts
    };
};
exports.getAllOEContracts = getAllOEContracts;
const getBridgeAdapters = (l2ChainId, messenger, opts)=>{
    var _a, _b, _c, _d, _e, _f;
    const adapterData = Object.assign(Object.assign(Object.assign({}, chain_constants_1.CONTRACT_ADDRESSES[l2ChainId] || ((_b = (_a = opts === null || opts === void 0 ? void 0 : opts.contracts) === null || _a === void 0 ? void 0 : _a.l1) === null || _b === void 0 ? void 0 : _b.L1StandardBridge) ? {
        Standard: {
            Adapter: adapters_1.StandardBridgeAdapter,
            l1Bridge: ((_d = (_c = opts === null || opts === void 0 ? void 0 : opts.contracts) === null || _c === void 0 ? void 0 : _c.l1) === null || _d === void 0 ? void 0 : _d.L1StandardBridge) || chain_constants_1.CONTRACT_ADDRESSES[l2ChainId].l1.L1StandardBridge,
            l2Bridge: contracts_1.predeploys.L2StandardBridge
        },
        ETH: {
            Adapter: adapters_1.ETHBridgeAdapter,
            l1Bridge: ((_f = (_e = opts === null || opts === void 0 ? void 0 : opts.contracts) === null || _e === void 0 ? void 0 : _e.l1) === null || _f === void 0 ? void 0 : _f.L1StandardBridge) || chain_constants_1.CONTRACT_ADDRESSES[l2ChainId].l1.L1StandardBridge,
            l2Bridge: contracts_1.predeploys.L2StandardBridge
        }
    } : {}), chain_constants_1.BRIDGE_ADAPTER_DATA[l2ChainId] || {}), (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
    const adapters = {};
    for (const [bridgeName, bridgeData] of Object.entries(adapterData)){
        adapters[bridgeName] = new bridgeData.Adapter({
            messenger,
            l1Bridge: bridgeData.l1Bridge,
            l2Bridge: bridgeData.l2Bridge
        });
    }
    return adapters;
};
exports.getBridgeAdapters = getBridgeAdapters; //# sourceMappingURL=contracts.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/merkle-utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.makeStateTrieProof = exports.maybeAddProofNode = exports.makeMerkleTreeProof = void 0;
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const merkletreejs_1 = __turbopack_context__.r("[project]/node_modules/merkletreejs/dist/index.js [app-client] (ecmascript)");
const rlp = __importStar(__turbopack_context__.r("[project]/node_modules/rlp/dist.browser/index.js [app-client] (ecmascript)"));
const makeMerkleTreeProof = (leaves, index)=>{
    const correctedTreeSize = Math.pow(2, Math.ceil(Math.log2(leaves.length)));
    const parsedLeaves = [];
    for(let i = 0; i < correctedTreeSize; i++){
        if (i < leaves.length) {
            parsedLeaves.push(leaves[i]);
        } else {
            parsedLeaves.push(ethers_1.ethers.utils.keccak256('0x' + '00'.repeat(32)));
        }
    }
    const bufLeaves = parsedLeaves.map(core_utils_1.fromHexString);
    const tree = new merkletreejs_1.MerkleTree(bufLeaves, (el)=>{
        return (0, core_utils_1.fromHexString)(ethers_1.ethers.utils.keccak256(el));
    });
    const proof = tree.getProof(bufLeaves[index], index).map((element)=>{
        return (0, core_utils_1.toHexString)(element.data);
    });
    return proof;
};
exports.makeMerkleTreeProof = makeMerkleTreeProof;
const maybeAddProofNode = (key, proof)=>{
    const modifiedProof = [
        ...proof
    ];
    const finalProofEl = modifiedProof[modifiedProof.length - 1];
    const finalProofElDecoded = rlp.decode(finalProofEl);
    if (finalProofElDecoded.length === 17) {
        for (const item of finalProofElDecoded){
            if (Array.isArray(item)) {
                const suffix = (0, core_utils_1.toHexString)(item[0]).slice(3);
                if (key.endsWith(suffix)) {
                    modifiedProof.push((0, core_utils_1.toHexString)(rlp.encode(item)));
                }
            }
        }
    }
    return modifiedProof;
};
exports.maybeAddProofNode = maybeAddProofNode;
const makeStateTrieProof = async (provider, blockNumber, address, slot)=>{
    const proof = await provider.send('eth_getProof', [
        address,
        [
            slot
        ],
        (0, core_utils_1.toRpcHexString)(blockNumber)
    ]);
    proof.storageProof[0].proof = (0, exports.maybeAddProofNode)(ethers_1.ethers.utils.keccak256(slot), proof.storageProof[0].proof);
    return {
        accountProof: proof.accountProof,
        storageProof: proof.storageProof[0].proof,
        storageValue: ethers_1.BigNumber.from(proof.storageProof[0].value),
        storageRoot: proof.storageHash
    };
};
exports.makeStateTrieProof = makeStateTrieProof; //# sourceMappingURL=merkle-utils.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/message-utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.migratedWithdrawalGasLimit = exports.hashMessageHash = exports.hashLowLevelMessage = void 0;
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const { hexDataLength } = ethers_1.utils;
const RELAY_CONSTANT_OVERHEAD = ethers_1.BigNumber.from(200000);
const RELAY_PER_BYTE_DATA_COST = ethers_1.BigNumber.from(16);
const MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = ethers_1.BigNumber.from(64);
const MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = ethers_1.BigNumber.from(63);
const RELAY_CALL_OVERHEAD = ethers_1.BigNumber.from(40000);
const RELAY_RESERVED_GAS = ethers_1.BigNumber.from(40000);
const RELAY_GAS_CHECK_BUFFER = ethers_1.BigNumber.from(5000);
const hashLowLevelMessage = (message)=>{
    return (0, core_utils_1.hashWithdrawal)(message.messageNonce, message.sender, message.target, message.value, message.minGasLimit, message.message);
};
exports.hashLowLevelMessage = hashLowLevelMessage;
const hashMessageHash = (messageHash)=>{
    const data = ethers_1.ethers.utils.defaultAbiCoder.encode([
        'bytes32',
        'uint256'
    ], [
        messageHash,
        ethers_1.ethers.constants.HashZero
    ]);
    return ethers_1.ethers.utils.keccak256(data);
};
exports.hashMessageHash = hashMessageHash;
const migratedWithdrawalGasLimit = (data, chainID)=>{
    const dataCost = ethers_1.BigNumber.from(hexDataLength(data)).mul(RELAY_PER_BYTE_DATA_COST);
    let overhead;
    if (chainID === 420) {
        overhead = ethers_1.BigNumber.from(200000);
    } else {
        const dynamicOverhead = MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR.mul(1000000).div(MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR);
        overhead = RELAY_CONSTANT_OVERHEAD.add(dynamicOverhead).add(RELAY_CALL_OVERHEAD).add(RELAY_RESERVED_GAS).add(RELAY_GAS_CHECK_BUFFER);
    }
    let minGasLimit = dataCost.add(overhead);
    if (minGasLimit.gt(25000000)) {
        minGasLimit = ethers_1.BigNumber.from(25000000);
    }
    return minGasLimit;
};
exports.migratedWithdrawalGasLimit = migratedWithdrawalGasLimit; //# sourceMappingURL=message-utils.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/type-utils.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=type-utils.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/utils/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/chain-constants.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/contracts.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/merkle-utils.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/message-utils.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/misc-utils.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/type-utils.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/interfaces/bridge-adapter.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=bridge-adapter.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/interfaces/l2-provider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=l2-provider.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/interfaces/types.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageReceiptStatus = exports.MessageDirection = exports.MessageStatus = exports.L2ChainID = exports.L1ChainID = void 0;
var L1ChainID;
(function(L1ChainID) {
    L1ChainID[L1ChainID["MAINNET"] = 1] = "MAINNET";
    L1ChainID[L1ChainID["GOERLI"] = 5] = "GOERLI";
    L1ChainID[L1ChainID["SEPOLIA"] = 11155111] = "SEPOLIA";
    L1ChainID[L1ChainID["HARDHAT_LOCAL"] = 31337] = "HARDHAT_LOCAL";
    L1ChainID[L1ChainID["BEDROCK_LOCAL_DEVNET"] = 900] = "BEDROCK_LOCAL_DEVNET";
})(L1ChainID || (exports.L1ChainID = L1ChainID = {}));
var L2ChainID;
(function(L2ChainID) {
    L2ChainID[L2ChainID["OPTIMISM"] = 10] = "OPTIMISM";
    L2ChainID[L2ChainID["OPTIMISM_GOERLI"] = 420] = "OPTIMISM_GOERLI";
    L2ChainID[L2ChainID["OPTIMISM_SEPOLIA"] = 11155420] = "OPTIMISM_SEPOLIA";
    L2ChainID[L2ChainID["OPTIMISM_HARDHAT_LOCAL"] = 31337] = "OPTIMISM_HARDHAT_LOCAL";
    L2ChainID[L2ChainID["OPTIMISM_HARDHAT_DEVNET"] = 17] = "OPTIMISM_HARDHAT_DEVNET";
    L2ChainID[L2ChainID["OPTIMISM_BEDROCK_ALPHA_TESTNET"] = 28528] = "OPTIMISM_BEDROCK_ALPHA_TESTNET";
    L2ChainID[L2ChainID["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
    L2ChainID[L2ChainID["BASE_SEPOLIA"] = 84532] = "BASE_SEPOLIA";
    L2ChainID[L2ChainID["BASE_MAINNET"] = 8453] = "BASE_MAINNET";
    L2ChainID[L2ChainID["ZORA_GOERLI"] = 999] = "ZORA_GOERLI";
    L2ChainID[L2ChainID["ZORA_MAINNET"] = 7777777] = "ZORA_MAINNET";
    L2ChainID[L2ChainID["MODE_SEPOLIA"] = 919] = "MODE_SEPOLIA";
    L2ChainID[L2ChainID["MODE_MAINNET"] = 34443] = "MODE_MAINNET";
})(L2ChainID || (exports.L2ChainID = L2ChainID = {}));
var MessageStatus;
(function(MessageStatus) {
    MessageStatus[MessageStatus["UNCONFIRMED_L1_TO_L2_MESSAGE"] = 0] = "UNCONFIRMED_L1_TO_L2_MESSAGE";
    MessageStatus[MessageStatus["FAILED_L1_TO_L2_MESSAGE"] = 1] = "FAILED_L1_TO_L2_MESSAGE";
    MessageStatus[MessageStatus["STATE_ROOT_NOT_PUBLISHED"] = 2] = "STATE_ROOT_NOT_PUBLISHED";
    MessageStatus[MessageStatus["READY_TO_PROVE"] = 3] = "READY_TO_PROVE";
    MessageStatus[MessageStatus["IN_CHALLENGE_PERIOD"] = 4] = "IN_CHALLENGE_PERIOD";
    MessageStatus[MessageStatus["READY_FOR_RELAY"] = 5] = "READY_FOR_RELAY";
    MessageStatus[MessageStatus["RELAYED"] = 6] = "RELAYED";
})(MessageStatus || (exports.MessageStatus = MessageStatus = {}));
var MessageDirection;
(function(MessageDirection) {
    MessageDirection[MessageDirection["L1_TO_L2"] = 0] = "L1_TO_L2";
    MessageDirection[MessageDirection["L2_TO_L1"] = 1] = "L2_TO_L1";
})(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
var MessageReceiptStatus;
(function(MessageReceiptStatus) {
    MessageReceiptStatus[MessageReceiptStatus["RELAYED_FAILED"] = 0] = "RELAYED_FAILED";
    MessageReceiptStatus[MessageReceiptStatus["RELAYED_SUCCEEDED"] = 1] = "RELAYED_SUCCEEDED";
})(MessageReceiptStatus || (exports.MessageReceiptStatus = MessageReceiptStatus = {})); //# sourceMappingURL=types.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/bridge-adapter.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/l2-provider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/types.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/adapters/standard-bridge.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StandardBridgeAdapter = void 0;
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/contracts/dist/index.js [app-client] (ecmascript)");
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const L1StandardBridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L1StandardBridge.json (json)"));
const L2StandardBridge_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/L2StandardBridge.json (json)"));
const OptimismMintableERC20_json_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/forge-artifacts/OptimismMintableERC20.json (json)"));
const interfaces_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)");
const coercion_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)");
class StandardBridgeAdapter {
    constructor(opts){
        this.populateTransaction = {
            approve: async (l1Token, l2Token, amount, opts)=>{
                if (!await this.supportsTokenPair(l1Token, l2Token)) {
                    throw new Error(`token pair not supported by bridge`);
                }
                const token = new ethers_1.Contract((0, coercion_1.toAddress)(l1Token), OptimismMintableERC20_json_1.default.abi, this.messenger.l1Provider);
                return token.populateTransaction.approve(this.l1Bridge.address, amount, (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
            },
            deposit: async (l1Token, l2Token, amount, opts)=>{
                if (!await this.supportsTokenPair(l1Token, l2Token)) {
                    throw new Error(`token pair not supported by bridge`);
                }
                if ((opts === null || opts === void 0 ? void 0 : opts.recipient) === undefined) {
                    return this.l1Bridge.populateTransaction.depositERC20((0, coercion_1.toAddress)(l1Token), (0, coercion_1.toAddress)(l2Token), amount, (opts === null || opts === void 0 ? void 0 : opts.l2GasLimit) || 200000, '0x', (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                } else {
                    return this.l1Bridge.populateTransaction.depositERC20To((0, coercion_1.toAddress)(l1Token), (0, coercion_1.toAddress)(l2Token), (0, coercion_1.toAddress)(opts.recipient), amount, (opts === null || opts === void 0 ? void 0 : opts.l2GasLimit) || 200000, '0x', (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                }
            },
            withdraw: async (l1Token, l2Token, amount, opts)=>{
                if (!await this.supportsTokenPair(l1Token, l2Token)) {
                    throw new Error(`token pair not supported by bridge`);
                }
                if ((opts === null || opts === void 0 ? void 0 : opts.recipient) === undefined) {
                    return this.l2Bridge.populateTransaction.withdraw((0, coercion_1.toAddress)(l2Token), amount, 0, '0x', (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                } else {
                    return this.l2Bridge.populateTransaction.withdrawTo((0, coercion_1.toAddress)(l2Token), (0, coercion_1.toAddress)(opts.recipient), amount, 0, '0x', (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                }
            }
        };
        this.estimateGas = {
            approve: async (l1Token, l2Token, amount, opts)=>{
                return this.messenger.l1Provider.estimateGas(await this.populateTransaction.approve(l1Token, l2Token, amount, opts));
            },
            deposit: async (l1Token, l2Token, amount, opts)=>{
                return this.messenger.l1Provider.estimateGas(await this.populateTransaction.deposit(l1Token, l2Token, amount, opts));
            },
            withdraw: async (l1Token, l2Token, amount, opts)=>{
                return this.messenger.l2Provider.estimateGas(await this.populateTransaction.withdraw(l1Token, l2Token, amount, opts));
            }
        };
        this.messenger = opts.messenger;
        this.l1Bridge = new ethers_1.Contract((0, coercion_1.toAddress)(opts.l1Bridge), L1StandardBridge_json_1.default.abi, this.messenger.l1Provider);
        this.l2Bridge = new ethers_1.Contract((0, coercion_1.toAddress)(opts.l2Bridge), L2StandardBridge_json_1.default.abi, this.messenger.l2Provider);
    }
    async getDepositsByAddress(address, opts) {
        const events = await this.l1Bridge.queryFilter(this.l1Bridge.filters.ERC20DepositInitiated(undefined, undefined, address), opts === null || opts === void 0 ? void 0 : opts.fromBlock, opts === null || opts === void 0 ? void 0 : opts.toBlock);
        return events.filter((event)=>{
            return !(0, core_utils_1.hexStringEquals)(event.args.l1Token, ethers_1.ethers.constants.AddressZero) && !(0, core_utils_1.hexStringEquals)(event.args.l2Token, contracts_1.predeploys.OVM_ETH);
        }).map((event)=>{
            return {
                direction: interfaces_1.MessageDirection.L1_TO_L2,
                from: event.args.from,
                to: event.args.to,
                l1Token: event.args.l1Token,
                l2Token: event.args.l2Token,
                amount: event.args.amount,
                data: event.args.extraData,
                logIndex: event.logIndex,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash
            };
        }).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async getWithdrawalsByAddress(address, opts) {
        const events = await this.l2Bridge.queryFilter(this.l2Bridge.filters.WithdrawalInitiated(undefined, undefined, address), opts === null || opts === void 0 ? void 0 : opts.fromBlock, opts === null || opts === void 0 ? void 0 : opts.toBlock);
        return events.filter((event)=>{
            return !(0, core_utils_1.hexStringEquals)(event.args.l1Token, ethers_1.ethers.constants.AddressZero) && !(0, core_utils_1.hexStringEquals)(event.args.l2Token, contracts_1.predeploys.OVM_ETH);
        }).map((event)=>{
            return {
                direction: interfaces_1.MessageDirection.L2_TO_L1,
                from: event.args.from,
                to: event.args.to,
                l1Token: event.args.l1Token,
                l2Token: event.args.l2Token,
                amount: event.args.amount,
                data: event.args.extraData,
                logIndex: event.logIndex,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash
            };
        }).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async supportsTokenPair(l1Token, l2Token) {
        const contract = new ethers_1.Contract((0, coercion_1.toAddress)(l2Token), OptimismMintableERC20_json_1.default.abi, this.messenger.l2Provider);
        if ((0, core_utils_1.hexStringEquals)((0, coercion_1.toAddress)(l1Token), ethers_1.ethers.constants.AddressZero) || (0, core_utils_1.hexStringEquals)((0, coercion_1.toAddress)(l2Token), contracts_1.predeploys.OVM_ETH)) {
            return false;
        }
        const remoteL1Token = await contract.l1Token();
        if (!(0, core_utils_1.hexStringEquals)(remoteL1Token, (0, coercion_1.toAddress)(l1Token))) {
            return false;
        }
        const remoteL2Bridge = await contract.l2Bridge();
        if (!(0, core_utils_1.hexStringEquals)(remoteL2Bridge, this.l2Bridge.address)) {
            return false;
        }
        return true;
    }
    async approval(l1Token, l2Token, signer) {
        if (!await this.supportsTokenPair(l1Token, l2Token)) {
            throw new Error(`token pair not supported by bridge`);
        }
        const token = new ethers_1.Contract((0, coercion_1.toAddress)(l1Token), OptimismMintableERC20_json_1.default.abi, this.messenger.l1Provider);
        return token.allowance(await signer.getAddress(), this.l1Bridge.address);
    }
    async approve(l1Token, l2Token, amount, signer, opts) {
        return signer.sendTransaction(await this.populateTransaction.approve(l1Token, l2Token, amount, opts));
    }
    async deposit(l1Token, l2Token, amount, signer, opts) {
        return signer.sendTransaction(await this.populateTransaction.deposit(l1Token, l2Token, amount, opts));
    }
    async withdraw(l1Token, l2Token, amount, signer, opts) {
        return signer.sendTransaction(await this.populateTransaction.withdraw(l1Token, l2Token, amount, opts));
    }
}
exports.StandardBridgeAdapter = StandardBridgeAdapter; //# sourceMappingURL=standard-bridge.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/adapters/dai-bridge.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DAIBridgeAdapter = void 0;
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const coercion_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)");
const standard_bridge_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/standard-bridge.js [app-client] (ecmascript)");
class DAIBridgeAdapter extends standard_bridge_1.StandardBridgeAdapter {
    async supportsTokenPair(l1Token, l2Token) {
        const l1Bridge = new ethers_1.Contract(this.l1Bridge.address, [
            {
                inputs: [],
                name: 'l1Token',
                outputs: [
                    {
                        internalType: 'address',
                        name: '',
                        type: 'address'
                    }
                ],
                stateMutability: 'view',
                type: 'function'
            },
            {
                inputs: [],
                name: 'l2Token',
                outputs: [
                    {
                        internalType: 'address',
                        name: '',
                        type: 'address'
                    }
                ],
                stateMutability: 'view',
                type: 'function'
            }
        ], this.messenger.l1Provider);
        const allowedL1Token = await l1Bridge.l1Token();
        if (!(0, core_utils_1.hexStringEquals)(allowedL1Token, (0, coercion_1.toAddress)(l1Token))) {
            return false;
        }
        const allowedL2Token = await l1Bridge.l2Token();
        if (!(0, core_utils_1.hexStringEquals)(allowedL2Token, (0, coercion_1.toAddress)(l2Token))) {
            return false;
        }
        return true;
    }
}
exports.DAIBridgeAdapter = DAIBridgeAdapter; //# sourceMappingURL=dai-bridge.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/adapters/eco-bridge.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ECOBridgeAdapter = void 0;
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const coercion_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)");
const standard_bridge_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/standard-bridge.js [app-client] (ecmascript)");
class ECOBridgeAdapter extends standard_bridge_1.StandardBridgeAdapter {
    async supportsTokenPair(l1Token, l2Token) {
        const l1Bridge = new ethers_1.Contract(this.l1Bridge.address, [
            {
                inputs: [],
                name: 'l1Eco',
                outputs: [
                    {
                        internalType: 'address',
                        name: '',
                        type: 'address'
                    }
                ],
                stateMutability: 'view',
                type: 'function'
            }
        ], this.messenger.l1Provider);
        const l2Bridge = new ethers_1.Contract(this.l2Bridge.address, [
            {
                inputs: [],
                name: 'l2Eco',
                outputs: [
                    {
                        internalType: 'contract L2ECO',
                        name: '',
                        type: 'address'
                    }
                ],
                stateMutability: 'view',
                type: 'function'
            }
        ], this.messenger.l2Provider);
        const [remoteL1Token, remoteL2Token] = await Promise.all([
            l1Bridge.l1Eco(),
            l2Bridge.l2Eco()
        ]);
        if (!(0, core_utils_1.hexStringEquals)(remoteL1Token, (0, coercion_1.toAddress)(l1Token))) {
            return false;
        }
        if (!(0, core_utils_1.hexStringEquals)(remoteL2Token, (0, coercion_1.toAddress)(l2Token))) {
            return false;
        }
        return true;
    }
}
exports.ECOBridgeAdapter = ECOBridgeAdapter; //# sourceMappingURL=eco-bridge.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/adapters/eth-bridge.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ETHBridgeAdapter = void 0;
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/contracts/dist/index.js [app-client] (ecmascript)");
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const interfaces_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)");
const coercion_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/coercion.js [app-client] (ecmascript)");
const misc_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/misc-utils.js [app-client] (ecmascript)");
const standard_bridge_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/standard-bridge.js [app-client] (ecmascript)");
class ETHBridgeAdapter extends standard_bridge_1.StandardBridgeAdapter {
    constructor(){
        super(...arguments);
        this.populateTransaction = {
            approve: async (l1Token, l2Token, amount, opts)=>{
                throw new Error(`approvals not necessary for ETH bridge`);
            },
            deposit: async (l1Token, l2Token, amount, opts)=>{
                if (!await this.supportsTokenPair(l1Token, l2Token)) {
                    throw new Error(`token pair not supported by bridge`);
                }
                if ((opts === null || opts === void 0 ? void 0 : opts.recipient) === undefined) {
                    return this.l1Bridge.populateTransaction.depositETH((opts === null || opts === void 0 ? void 0 : opts.l2GasLimit) || 200000, '0x', Object.assign(Object.assign({}, (0, misc_utils_1.omit)((opts === null || opts === void 0 ? void 0 : opts.overrides) || {}, 'value')), {
                        value: amount
                    }));
                } else {
                    return this.l1Bridge.populateTransaction.depositETHTo((0, coercion_1.toAddress)(opts.recipient), (opts === null || opts === void 0 ? void 0 : opts.l2GasLimit) || 200000, '0x', Object.assign(Object.assign({}, (0, misc_utils_1.omit)((opts === null || opts === void 0 ? void 0 : opts.overrides) || {}, 'value')), {
                        value: amount
                    }));
                }
            },
            withdraw: async (l1Token, l2Token, amount, opts)=>{
                if (!await this.supportsTokenPair(l1Token, l2Token)) {
                    throw new Error(`token pair not supported by bridge`);
                }
                if ((opts === null || opts === void 0 ? void 0 : opts.recipient) === undefined) {
                    return this.l2Bridge.populateTransaction.withdraw((0, coercion_1.toAddress)(l2Token), amount, 0, '0x', Object.assign(Object.assign({}, (0, misc_utils_1.omit)((opts === null || opts === void 0 ? void 0 : opts.overrides) || {}, 'value')), {
                        value: this.messenger.bedrock ? amount : 0
                    }));
                } else {
                    return this.l2Bridge.populateTransaction.withdrawTo((0, coercion_1.toAddress)(l2Token), (0, coercion_1.toAddress)(opts.recipient), amount, 0, '0x', Object.assign(Object.assign({}, (0, misc_utils_1.omit)((opts === null || opts === void 0 ? void 0 : opts.overrides) || {}, 'value')), {
                        value: this.messenger.bedrock ? amount : 0
                    }));
                }
            }
        };
    }
    async approval(l1Token, l2Token, signer) {
        throw new Error(`approval not necessary for ETH bridge`);
    }
    async getDepositsByAddress(address, opts) {
        const events = await this.l1Bridge.queryFilter(this.l1Bridge.filters.ETHDepositInitiated(address), opts === null || opts === void 0 ? void 0 : opts.fromBlock, opts === null || opts === void 0 ? void 0 : opts.toBlock);
        return events.map((event)=>{
            return {
                direction: interfaces_1.MessageDirection.L1_TO_L2,
                from: event.args.from,
                to: event.args.to,
                l1Token: ethers_1.ethers.constants.AddressZero,
                l2Token: contracts_1.predeploys.OVM_ETH,
                amount: event.args.amount,
                data: event.args.extraData,
                logIndex: event.logIndex,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash
            };
        }).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async getWithdrawalsByAddress(address, opts) {
        const events = await this.l2Bridge.queryFilter(this.l2Bridge.filters.WithdrawalInitiated(undefined, undefined, address), opts === null || opts === void 0 ? void 0 : opts.fromBlock, opts === null || opts === void 0 ? void 0 : opts.toBlock);
        return events.filter((event)=>{
            return (0, core_utils_1.hexStringEquals)(event.args.l1Token, ethers_1.ethers.constants.AddressZero) && (0, core_utils_1.hexStringEquals)(event.args.l2Token, contracts_1.predeploys.OVM_ETH);
        }).map((event)=>{
            return {
                direction: interfaces_1.MessageDirection.L2_TO_L1,
                from: event.args.from,
                to: event.args.to,
                l1Token: event.args.l1Token,
                l2Token: event.args.l2Token,
                amount: event.args.amount,
                data: event.args.extraData,
                logIndex: event.logIndex,
                blockNumber: event.blockNumber,
                transactionHash: event.transactionHash
            };
        }).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async supportsTokenPair(l1Token, l2Token) {
        return (0, core_utils_1.hexStringEquals)((0, coercion_1.toAddress)(l1Token), ethers_1.ethers.constants.AddressZero) && (0, core_utils_1.hexStringEquals)((0, coercion_1.toAddress)(l2Token), contracts_1.predeploys.OVM_ETH);
    }
}
exports.ETHBridgeAdapter = ETHBridgeAdapter; //# sourceMappingURL=eth-bridge.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/adapters/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/dai-bridge.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/eco-bridge.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/eth-bridge.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/standard-bridge.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/cross-chain-messenger.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CrossChainMessenger = void 0;
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/contracts/dist/index.js [app-client] (ecmascript)");
const core_utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/core-utils/dist/index.js [app-client] (ecmascript)");
const abstract_provider_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/abstract-provider/lib.esm/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const rlp = __importStar(__turbopack_context__.r("[project]/node_modules/rlp/dist.browser/index.js [app-client] (ecmascript)"));
const semver_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/semver/index.js [app-client] (ecmascript)"));
const interfaces_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/index.js [app-client] (ecmascript)");
class CrossChainMessenger {
    constructor(opts){
        var _a;
        this._outputCache = [];
        this.populateTransaction = {
            sendMessage: async (message, opts)=>{
                if (message.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                    return this.contracts.l1.L1CrossDomainMessenger.populateTransaction.sendMessage(message.target, message.message, (opts === null || opts === void 0 ? void 0 : opts.l2GasLimit) || await this.estimateL2MessageGasLimit(message), (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                } else {
                    return this.contracts.l2.L2CrossDomainMessenger.populateTransaction.sendMessage(message.target, message.message, 0, (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                }
            },
            resendMessage: async (message, messageGasLimit, opts, messageIndex = 0)=>{
                const resolved = await this.toCrossChainMessage(message, messageIndex);
                if (resolved.direction === interfaces_1.MessageDirection.L2_TO_L1) {
                    throw new Error(`cannot resend L2 to L1 message`);
                }
                if (this.bedrock) {
                    return this.populateTransaction.finalizeMessage(resolved, Object.assign(Object.assign({}, opts || {}), {
                        overrides: Object.assign(Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.overrides), {
                            gasLimit: messageGasLimit
                        })
                    }), messageIndex);
                } else {
                    const legacyL1XDM = new ethers_1.ethers.Contract(this.contracts.l1.L1CrossDomainMessenger.address, (0, contracts_1.getContractInterface)('L1CrossDomainMessenger'), this.l1SignerOrProvider);
                    return legacyL1XDM.populateTransaction.replayMessage(resolved.target, resolved.sender, resolved.message, resolved.messageNonce, resolved.minGasLimit, messageGasLimit, (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                }
            },
            proveMessage: async (message, opts, messageIndex = 0)=>{
                const resolved = await this.toCrossChainMessage(message, messageIndex);
                if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                    throw new Error('cannot finalize L1 to L2 message');
                }
                if (!this.bedrock) {
                    throw new Error('message proving only applies after the bedrock upgrade');
                }
                const withdrawal = await this.toLowLevelMessage(resolved, messageIndex);
                const proof = await this.getBedrockMessageProof(resolved, messageIndex);
                const args = [
                    [
                        withdrawal.messageNonce,
                        withdrawal.sender,
                        withdrawal.target,
                        withdrawal.value,
                        withdrawal.minGasLimit,
                        withdrawal.message
                    ],
                    proof.l2OutputIndex,
                    [
                        proof.outputRootProof.version,
                        proof.outputRootProof.stateRoot,
                        proof.outputRootProof.messagePasserStorageRoot,
                        proof.outputRootProof.latestBlockhash
                    ],
                    proof.withdrawalProof,
                    (opts === null || opts === void 0 ? void 0 : opts.overrides) || {}
                ];
                return this.contracts.l1.OptimismPortal.populateTransaction.proveWithdrawalTransaction(...args);
            },
            finalizeMessage: async (message, opts, messageIndex = 0)=>{
                const resolved = await this.toCrossChainMessage(message, messageIndex);
                if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                    throw new Error(`cannot finalize L1 to L2 message`);
                }
                if (this.bedrock) {
                    const messageHashV1 = (0, core_utils_1.hashCrossDomainMessagev1)(resolved.messageNonce, resolved.sender, resolved.target, resolved.value, resolved.minGasLimit, resolved.message);
                    const [isFailed, withdrawal] = await Promise.allSettled([
                        this.contracts.l1.L1CrossDomainMessenger.failedMessages(messageHashV1),
                        this.toLowLevelMessage(resolved, messageIndex)
                    ]);
                    if (isFailed.status === 'rejected' || withdrawal.status === 'rejected') {
                        const rejections = [
                            isFailed,
                            withdrawal
                        ].filter((p)=>p.status === 'rejected').map((p)=>p.reason);
                        throw rejections.length > 1 ? new AggregateError(rejections) : rejections[0];
                    }
                    if (isFailed.value === true) {
                        const xdmWithdrawal = this.contracts.l1.L1CrossDomainMessenger.interface.decodeFunctionData('relayMessage', withdrawal.value.message);
                        return this.contracts.l1.L1CrossDomainMessenger.populateTransaction.relayMessage(xdmWithdrawal._nonce, xdmWithdrawal._sender, xdmWithdrawal._target, xdmWithdrawal._value, xdmWithdrawal._minGasLimit, xdmWithdrawal._message, (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                    }
                    return this.contracts.l1.OptimismPortal.populateTransaction.finalizeWithdrawalTransaction([
                        withdrawal.value.messageNonce,
                        withdrawal.value.sender,
                        withdrawal.value.target,
                        withdrawal.value.value,
                        withdrawal.value.minGasLimit,
                        withdrawal.value.message
                    ], (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                } else {
                    const proof = await this.getMessageProof(resolved, messageIndex);
                    const legacyL1XDM = new ethers_1.ethers.Contract(this.contracts.l1.L1CrossDomainMessenger.address, (0, contracts_1.getContractInterface)('L1CrossDomainMessenger'), this.l1SignerOrProvider);
                    return legacyL1XDM.populateTransaction.relayMessage(resolved.target, resolved.sender, resolved.message, resolved.messageNonce, proof, (opts === null || opts === void 0 ? void 0 : opts.overrides) || {});
                }
            },
            depositETH: async (amount, opts, isEstimatingGas = false)=>{
                const getOpts = async ()=>{
                    if (isEstimatingGas) {
                        return opts;
                    }
                    const gasEstimation = await this.estimateGas.depositETH(amount, opts);
                    return Object.assign(Object.assign({}, opts), {
                        overrides: Object.assign(Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.overrides), {
                            gasLimit: gasEstimation.add(gasEstimation.div(2))
                        })
                    });
                };
                return this.bridges.ETH.populateTransaction.deposit(ethers_1.ethers.constants.AddressZero, contracts_1.predeploys.OVM_ETH, amount, await getOpts());
            },
            withdrawETH: async (amount, opts)=>{
                return this.bridges.ETH.populateTransaction.withdraw(ethers_1.ethers.constants.AddressZero, contracts_1.predeploys.OVM_ETH, amount, opts);
            },
            approveERC20: async (l1Token, l2Token, amount, opts)=>{
                const bridge = await this.getBridgeForTokenPair(l1Token, l2Token);
                return bridge.populateTransaction.approve(l1Token, l2Token, amount, opts);
            },
            depositERC20: async (l1Token, l2Token, amount, opts, isEstimatingGas = false)=>{
                const bridge = await this.getBridgeForTokenPair(l1Token, l2Token);
                const getOpts = async ()=>{
                    var _a, _b, _c, _d;
                    if (isEstimatingGas) {
                        return opts;
                    }
                    if (!ethers_1.ethers.Signer.isSigner(this.l1SignerOrProvider)) {
                        throw new Error('unable to deposit without an l1 signer');
                    }
                    const from = this.l1SignerOrProvider.getAddress();
                    const gasEstimation = await this.estimateGas.depositERC20(l1Token, l2Token, amount, Object.assign(Object.assign({}, opts), {
                        overrides: Object.assign(Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.overrides), {
                            from: (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.overrides) === null || _a === void 0 ? void 0 : _a.from) !== null && _b !== void 0 ? _b : from
                        })
                    }));
                    return Object.assign(Object.assign({}, opts), {
                        overrides: Object.assign(Object.assign({}, opts === null || opts === void 0 ? void 0 : opts.overrides), {
                            gasLimit: gasEstimation.add(gasEstimation.div(2)),
                            from: (_d = (_c = opts === null || opts === void 0 ? void 0 : opts.overrides) === null || _c === void 0 ? void 0 : _c.from) !== null && _d !== void 0 ? _d : from
                        })
                    });
                };
                return bridge.populateTransaction.deposit(l1Token, l2Token, amount, await getOpts());
            },
            withdrawERC20: async (l1Token, l2Token, amount, opts)=>{
                const bridge = await this.getBridgeForTokenPair(l1Token, l2Token);
                return bridge.populateTransaction.withdraw(l1Token, l2Token, amount, opts);
            }
        };
        this.estimateGas = {
            sendMessage: async (message, opts)=>{
                const tx = await this.populateTransaction.sendMessage(message, opts);
                if (message.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                    return this.l1Provider.estimateGas(tx);
                } else {
                    return this.l2Provider.estimateGas(tx);
                }
            },
            resendMessage: async (message, messageGasLimit, opts)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.resendMessage(message, messageGasLimit, opts));
            },
            proveMessage: async (message, opts, messageIndex = 0)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.proveMessage(message, opts, messageIndex));
            },
            finalizeMessage: async (message, opts, messageIndex = 0)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.finalizeMessage(message, opts, messageIndex));
            },
            depositETH: async (amount, opts)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.depositETH(amount, opts, true));
            },
            withdrawETH: async (amount, opts)=>{
                return this.l2Provider.estimateGas(await this.populateTransaction.withdrawETH(amount, opts));
            },
            approveERC20: async (l1Token, l2Token, amount, opts)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.approveERC20(l1Token, l2Token, amount, opts));
            },
            depositERC20: async (l1Token, l2Token, amount, opts)=>{
                return this.l1Provider.estimateGas(await this.populateTransaction.depositERC20(l1Token, l2Token, amount, opts, true));
            },
            withdrawERC20: async (l1Token, l2Token, amount, opts)=>{
                return this.l2Provider.estimateGas(await this.populateTransaction.withdrawERC20(l1Token, l2Token, amount, opts));
            }
        };
        this.bedrock = (_a = opts.bedrock) !== null && _a !== void 0 ? _a : true;
        this.l1SignerOrProvider = (0, utils_1.toSignerOrProvider)(opts.l1SignerOrProvider);
        this.l2SignerOrProvider = (0, utils_1.toSignerOrProvider)(opts.l2SignerOrProvider);
        try {
            this.l1ChainId = (0, utils_1.toNumber)(opts.l1ChainId);
        } catch (err) {
            throw new Error(`L1 chain ID is missing or invalid: ${opts.l1ChainId}`);
        }
        try {
            this.l2ChainId = (0, utils_1.toNumber)(opts.l2ChainId);
        } catch (err) {
            throw new Error(`L2 chain ID is missing or invalid: ${opts.l2ChainId}`);
        }
        this.depositConfirmationBlocks = (opts === null || opts === void 0 ? void 0 : opts.depositConfirmationBlocks) !== undefined ? (0, utils_1.toNumber)(opts.depositConfirmationBlocks) : utils_1.DEPOSIT_CONFIRMATION_BLOCKS[this.l2ChainId] || 0;
        this.l1BlockTimeSeconds = (opts === null || opts === void 0 ? void 0 : opts.l1BlockTimeSeconds) !== undefined ? (0, utils_1.toNumber)(opts.l1BlockTimeSeconds) : utils_1.CHAIN_BLOCK_TIMES[this.l1ChainId] || 1;
        this.contracts = (0, utils_1.getAllOEContracts)(this.l2ChainId, {
            l1SignerOrProvider: this.l1SignerOrProvider,
            l2SignerOrProvider: this.l2SignerOrProvider,
            overrides: opts.contracts
        });
        this.bridges = (0, utils_1.getBridgeAdapters)(this.l2ChainId, this, {
            overrides: opts.bridges,
            contracts: opts.contracts
        });
    }
    get l1Provider() {
        if (abstract_provider_1.Provider.isProvider(this.l1SignerOrProvider)) {
            return this.l1SignerOrProvider;
        } else {
            return this.l1SignerOrProvider.provider;
        }
    }
    get l2Provider() {
        if (abstract_provider_1.Provider.isProvider(this.l2SignerOrProvider)) {
            return this.l2SignerOrProvider;
        } else {
            return this.l2SignerOrProvider.provider;
        }
    }
    get l1Signer() {
        if (abstract_provider_1.Provider.isProvider(this.l1SignerOrProvider)) {
            throw new Error(`messenger has no L1 signer`);
        } else {
            return this.l1SignerOrProvider;
        }
    }
    get l2Signer() {
        if (abstract_provider_1.Provider.isProvider(this.l2SignerOrProvider)) {
            throw new Error(`messenger has no L2 signer`);
        } else {
            return this.l2SignerOrProvider;
        }
    }
    async fpac() {
        if (this.contracts.l1.OptimismPortal.address === ethers_1.ethers.constants.AddressZero) {
            return false;
        } else {
            return semver_1.default.gte(await this.contracts.l1.OptimismPortal.version(), '3.0.0');
        }
    }
    async getMessagesByTransaction(transaction, opts = {}) {
        var _a, _b;
        await ((_b = (_a = transaction).wait) === null || _b === void 0 ? void 0 : _b.call(_a));
        const txHash = (0, utils_1.toTransactionHash)(transaction);
        let receipt;
        if (opts.direction !== undefined) {
            if (opts.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                receipt = await this.l1Provider.getTransactionReceipt(txHash);
            } else {
                receipt = await this.l2Provider.getTransactionReceipt(txHash);
            }
        } else {
            receipt = await this.l1Provider.getTransactionReceipt(txHash);
            if (receipt) {
                opts.direction = interfaces_1.MessageDirection.L1_TO_L2;
            } else {
                receipt = await this.l2Provider.getTransactionReceipt(txHash);
                opts.direction = interfaces_1.MessageDirection.L2_TO_L1;
            }
        }
        if (!receipt) {
            throw new Error(`unable to find transaction receipt for ${txHash}`);
        }
        const messenger = opts.direction === interfaces_1.MessageDirection.L1_TO_L2 ? this.contracts.l1.L1CrossDomainMessenger : this.contracts.l2.L2CrossDomainMessenger;
        return receipt.logs.filter((log)=>{
            return log.address === messenger.address;
        }).filter((log)=>{
            const parsed = messenger.interface.parseLog(log);
            return parsed.name === 'SentMessage';
        }).map((log)=>{
            let value = ethers_1.ethers.BigNumber.from(0);
            const next = receipt.logs.find((l)=>{
                return l.logIndex === log.logIndex + 1 && l.address === messenger.address;
            });
            if (next) {
                const nextParsed = messenger.interface.parseLog(next);
                if (nextParsed.name === 'SentMessageExtension1') {
                    value = nextParsed.args.value;
                }
            }
            const parsed = messenger.interface.parseLog(log);
            return {
                direction: opts.direction,
                target: parsed.args.target,
                sender: parsed.args.sender,
                message: parsed.args.message,
                messageNonce: parsed.args.messageNonce,
                value,
                minGasLimit: parsed.args.gasLimit,
                logIndex: log.logIndex,
                blockNumber: log.blockNumber,
                transactionHash: log.transactionHash
            };
        });
    }
    async toBedrockCrossChainMessage(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        const { version } = (0, core_utils_1.decodeVersionedNonce)(resolved.messageNonce);
        if (version.eq(1)) {
            return resolved;
        }
        let value = ethers_1.BigNumber.from(0);
        if (resolved.direction === interfaces_1.MessageDirection.L2_TO_L1 && resolved.sender === this.contracts.l2.L2StandardBridge.address && resolved.target === this.contracts.l1.L1StandardBridge.address) {
            try {
                ;
                [, , value] = this.contracts.l1.L1StandardBridge.interface.decodeFunctionData('finalizeETHWithdrawal', resolved.message);
            } catch (err) {}
        }
        return Object.assign(Object.assign({}, resolved), {
            value,
            minGasLimit: ethers_1.BigNumber.from(0),
            messageNonce: (0, core_utils_1.encodeVersionedNonce)(ethers_1.BigNumber.from(0), resolved.messageNonce)
        });
    }
    async toLowLevelMessage(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            throw new Error(`can only convert L2 to L1 messages to low level`);
        }
        const { version } = (0, core_utils_1.decodeVersionedNonce)(resolved.messageNonce);
        let updated;
        if (version.eq(0)) {
            updated = await this.toBedrockCrossChainMessage(resolved, messageIndex);
        } else {
            updated = resolved;
        }
        const encoded = (0, core_utils_1.encodeCrossDomainMessageV1)(updated.messageNonce, updated.sender, updated.target, updated.value, updated.minGasLimit, updated.message);
        let gasLimit;
        let messageNonce;
        if (version.eq(0)) {
            const chainID = await (0, core_utils_1.getChainId)(this.l2Provider);
            gasLimit = (0, utils_1.migratedWithdrawalGasLimit)(encoded, chainID);
            messageNonce = resolved.messageNonce;
        } else {
            const receipt = await this.l2Provider.getTransactionReceipt((await this.toCrossChainMessage(message)).transactionHash);
            const withdrawals = [];
            for (const log of receipt.logs){
                if (log.address === this.contracts.l2.BedrockMessagePasser.address) {
                    const decoded = this.contracts.l2.L2ToL1MessagePasser.interface.parseLog(log);
                    if (decoded.name === 'MessagePassed') {
                        withdrawals.push(decoded.args);
                    }
                }
            }
            if (withdrawals.length === 0) {
                throw new Error(`no withdrawals found in receipt`);
            }
            const withdrawal = withdrawals[messageIndex];
            if (!withdrawal) {
                throw new Error(`withdrawal index ${messageIndex} out of bounds there are ${withdrawals.length} withdrawals`);
            }
            messageNonce = withdrawal.nonce;
            gasLimit = withdrawal.gasLimit;
        }
        return {
            messageNonce,
            sender: this.contracts.l2.L2CrossDomainMessenger.address,
            target: this.contracts.l1.L1CrossDomainMessenger.address,
            value: updated.value,
            minGasLimit: gasLimit,
            message: encoded
        };
    }
    async getBridgeForTokenPair(l1Token, l2Token) {
        var _a, _b;
        const bridges = [];
        for (const bridge of Object.values(this.bridges)){
            try {
                if (await bridge.supportsTokenPair(l1Token, l2Token)) {
                    bridges.push(bridge);
                }
            } catch (err) {
                if (!((_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toString().includes('CALL_EXCEPTION')) && !((_b = err === null || err === void 0 ? void 0 : err.stack) === null || _b === void 0 ? void 0 : _b.toString().includes('execution reverted'))) {
                    console.error('Unexpected error when checking bridge', err);
                }
            }
        }
        if (bridges.length === 0) {
            throw new Error(`no supported bridge for token pair`);
        }
        if (bridges.length > 1) {
            throw new Error(`found more than one bridge for token pair`);
        }
        return bridges[0];
    }
    async getDepositsByAddress(address, opts = {}) {
        return (await Promise.all(Object.values(this.bridges).map(async (bridge)=>{
            return bridge.getDepositsByAddress(address, opts);
        }))).reduce((acc, val)=>{
            return acc.concat(val);
        }, []).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async getWithdrawalsByAddress(address, opts = {}) {
        return (await Promise.all(Object.values(this.bridges).map(async (bridge)=>{
            return bridge.getWithdrawalsByAddress(address, opts);
        }))).reduce((acc, val)=>{
            return acc.concat(val);
        }, []).sort((a, b)=>{
            return b.blockNumber - a.blockNumber;
        });
    }
    async toCrossChainMessage(message, messageIndex = 0) {
        if (!message) {
            throw new Error('message is undefined');
        }
        if (message.message) {
            return message;
        } else if (message.l1Token && message.l2Token && message.transactionHash) {
            const messages = await this.getMessagesByTransaction(message.transactionHash);
            const found = messages.sort((a, b)=>{
                return a.logIndex - b.logIndex;
            }).find((m)=>{
                return m.logIndex > message.logIndex;
            });
            if (!found) {
                throw new Error(`could not find SentMessage event for message`);
            }
            return found;
        } else {
            const messages = await this.getMessagesByTransaction(message);
            const out = messages[messageIndex];
            if (!out) {
                throw new Error(`withdrawal index ${messageIndex} out of bounds. There are ${messages.length} withdrawals`);
            }
            return out;
        }
    }
    async getMessageStatus(message, messageIndex = 0, fromBlockOrBlockHash, toBlockOrBlockHash) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        const messageHashV0 = (0, core_utils_1.hashCrossDomainMessagev0)(resolved.target, resolved.sender, resolved.message, resolved.messageNonce);
        const messageHashV1 = (0, core_utils_1.hashCrossDomainMessagev1)(resolved.messageNonce, resolved.sender, resolved.target, resolved.value, resolved.minGasLimit, resolved.message);
        const messenger = resolved.direction === interfaces_1.MessageDirection.L1_TO_L2 ? this.contracts.l2.L2CrossDomainMessenger : this.contracts.l1.L1CrossDomainMessenger;
        const success = await messenger.successfulMessages(messageHashV0) || await messenger.successfulMessages(messageHashV1);
        if (success) {
            return interfaces_1.MessageStatus.RELAYED;
        }
        const failure = await messenger.failedMessages(messageHashV0) || await messenger.failedMessages(messageHashV1);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            if (failure) {
                return interfaces_1.MessageStatus.FAILED_L1_TO_L2_MESSAGE;
            } else {
                return interfaces_1.MessageStatus.UNCONFIRMED_L1_TO_L2_MESSAGE;
            }
        } else {
            if (failure) {
                return interfaces_1.MessageStatus.READY_FOR_RELAY;
            } else {
                let timestamp;
                if (this.bedrock) {
                    const output = await this.getMessageBedrockOutput(resolved, messageIndex);
                    if (output === null) {
                        return interfaces_1.MessageStatus.STATE_ROOT_NOT_PUBLISHED;
                    }
                    const withdrawal = await this.toLowLevelMessage(resolved, messageIndex);
                    const provenWithdrawal = await this.getProvenWithdrawal((0, utils_1.hashLowLevelMessage)(withdrawal));
                    if (provenWithdrawal === null) {
                        return interfaces_1.MessageStatus.READY_TO_PROVE;
                    }
                    timestamp = provenWithdrawal.timestamp.toNumber();
                } else {
                    const stateRoot = await this.getMessageStateRoot(resolved, messageIndex);
                    if (stateRoot === null) {
                        return interfaces_1.MessageStatus.STATE_ROOT_NOT_PUBLISHED;
                    }
                    const bn = stateRoot.batch.blockNumber;
                    const block = await this.l1Provider.getBlock(bn);
                    timestamp = block.timestamp;
                }
                if (await this.fpac()) {
                    const withdrawal = await this.toLowLevelMessage(resolved, messageIndex);
                    const withdrawalHash = (0, utils_1.hashLowLevelMessage)(withdrawal);
                    const provenWithdrawal = await this.getProvenWithdrawal(withdrawalHash);
                    if (provenWithdrawal === null) {
                        console.warn('Unexpected code path reached in getMessageStatus, returning READY_TO_PROVE');
                        return interfaces_1.MessageStatus.READY_TO_PROVE;
                    }
                    if (!('proofSubmitter' in provenWithdrawal)) {
                        throw new Error(`expected to get FPAC withdrawal but got legacy withdrawal`);
                    }
                    try {
                        await this.contracts.l1.OptimismPortal2.checkWithdrawal((0, utils_1.hashLowLevelMessage)(withdrawal), provenWithdrawal.proofSubmitter);
                        return interfaces_1.MessageStatus.READY_FOR_RELAY;
                    } catch (err) {
                        return interfaces_1.MessageStatus.IN_CHALLENGE_PERIOD;
                    }
                } else {
                    const challengePeriod = await this.getChallengePeriodSeconds();
                    const latestBlock = await this.l1Provider.getBlock('latest');
                    if (timestamp + challengePeriod > latestBlock.timestamp) {
                        return interfaces_1.MessageStatus.IN_CHALLENGE_PERIOD;
                    } else {
                        return interfaces_1.MessageStatus.READY_FOR_RELAY;
                    }
                }
            }
        }
    }
    async getMessageReceipt(message, messageIndex = 0, fromBlockOrBlockHash, toBlockOrHash) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        const messageHashV0 = (0, core_utils_1.hashCrossDomainMessagev0)(resolved.target, resolved.sender, resolved.message, resolved.messageNonce);
        const messageHashV1 = (0, core_utils_1.hashCrossDomainMessagev1)(resolved.messageNonce, resolved.sender, resolved.target, resolved.value, resolved.minGasLimit, resolved.message);
        const messenger = resolved.direction === interfaces_1.MessageDirection.L1_TO_L2 ? this.contracts.l2.L2CrossDomainMessenger : this.contracts.l1.L1CrossDomainMessenger;
        const relayedMessageEvents = [
            ...await messenger.queryFilter(messenger.filters.RelayedMessage(messageHashV0), fromBlockOrBlockHash, toBlockOrHash),
            ...await messenger.queryFilter(messenger.filters.RelayedMessage(messageHashV1), fromBlockOrBlockHash, toBlockOrHash)
        ];
        if (relayedMessageEvents.length === 1) {
            return {
                receiptStatus: interfaces_1.MessageReceiptStatus.RELAYED_SUCCEEDED,
                transactionReceipt: await relayedMessageEvents[0].getTransactionReceipt()
            };
        } else if (relayedMessageEvents.length > 1) {
            throw new Error(`multiple successful relays for message`);
        }
        const failedRelayedMessageEvents = [
            ...await messenger.queryFilter(messenger.filters.FailedRelayedMessage(messageHashV0), fromBlockOrBlockHash, toBlockOrHash),
            ...await messenger.queryFilter(messenger.filters.FailedRelayedMessage(messageHashV1), fromBlockOrBlockHash, toBlockOrHash)
        ];
        if (failedRelayedMessageEvents.length > 0) {
            return {
                receiptStatus: interfaces_1.MessageReceiptStatus.RELAYED_FAILED,
                transactionReceipt: await failedRelayedMessageEvents[failedRelayedMessageEvents.length - 1].getTransactionReceipt()
            };
        }
        return null;
    }
    async waitForMessageReceipt(message, opts = {}, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        let totalTimeMs = 0;
        while(totalTimeMs < (opts.timeoutMs || Infinity)){
            const tick = Date.now();
            const receipt = await this.getMessageReceipt(resolved, messageIndex, opts.fromBlockOrBlockHash, opts.toBlockOrHash);
            if (receipt !== null) {
                return receipt;
            } else {
                await (0, core_utils_1.sleep)(opts.pollIntervalMs || 4000);
                totalTimeMs += Date.now() - tick;
            }
        }
        throw new Error(`timed out waiting for message receipt`);
    }
    async waitForMessageStatus(message, status, opts = {}, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        let totalTimeMs = 0;
        while(totalTimeMs < (opts.timeoutMs || Infinity)){
            const tick = Date.now();
            const currentStatus = await this.getMessageStatus(resolved, messageIndex, opts.fromBlockOrBlockHash, opts.toBlockOrBlockHash);
            if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
                if (currentStatus === status) {
                    return;
                }
                if (status === interfaces_1.MessageStatus.UNCONFIRMED_L1_TO_L2_MESSAGE && currentStatus > status) {
                    return;
                }
                if (status === interfaces_1.MessageStatus.FAILED_L1_TO_L2_MESSAGE && currentStatus === interfaces_1.MessageStatus.RELAYED) {
                    throw new Error(`incompatible message status, expected FAILED_L1_TO_L2_MESSAGE got RELAYED`);
                }
                if (status === interfaces_1.MessageStatus.RELAYED && currentStatus === interfaces_1.MessageStatus.FAILED_L1_TO_L2_MESSAGE) {
                    throw new Error(`incompatible message status, expected RELAYED got FAILED_L1_TO_L2_MESSAGE`);
                }
            }
            if (resolved.direction === interfaces_1.MessageDirection.L2_TO_L1) {
                if (currentStatus >= status) {
                    return;
                }
            }
            await (0, core_utils_1.sleep)(opts.pollIntervalMs || 4000);
            totalTimeMs += Date.now() - tick;
        }
        throw new Error(`timed out waiting for message status change`);
    }
    async estimateL2MessageGasLimit(message, opts, messageIndex = 0) {
        let resolved;
        let from;
        if (message.messageNonce === undefined) {
            resolved = message;
            from = opts === null || opts === void 0 ? void 0 : opts.from;
        } else {
            resolved = await this.toCrossChainMessage(message, messageIndex);
            from = (opts === null || opts === void 0 ? void 0 : opts.from) || resolved.sender;
        }
        if (resolved.direction === interfaces_1.MessageDirection.L2_TO_L1) {
            throw new Error(`cannot estimate gas limit for L2 => L1 message`);
        }
        const estimate = await this.l2Provider.estimateGas({
            from,
            to: resolved.target,
            data: resolved.message
        });
        const bufferPercent = (opts === null || opts === void 0 ? void 0 : opts.bufferPercent) || 20;
        return estimate.mul(100 + bufferPercent).div(100);
    }
    async estimateMessageWaitTimeSeconds(message, messageIndex = 0, fromBlockOrBlockHash, toBlockOrBlockHash) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        const status = await this.getMessageStatus(resolved, messageIndex, fromBlockOrBlockHash, toBlockOrBlockHash);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            if (status === interfaces_1.MessageStatus.RELAYED || status === interfaces_1.MessageStatus.FAILED_L1_TO_L2_MESSAGE) {
                return 0;
            } else {
                const receipt = await this.l1Provider.getTransactionReceipt(resolved.transactionHash);
                const blocksLeft = Math.max(this.depositConfirmationBlocks - receipt.confirmations, 0);
                return blocksLeft * this.l1BlockTimeSeconds;
            }
        } else {
            if (status === interfaces_1.MessageStatus.RELAYED || status === interfaces_1.MessageStatus.READY_FOR_RELAY) {
                return 0;
            } else if (status === interfaces_1.MessageStatus.STATE_ROOT_NOT_PUBLISHED) {
                return this.getChallengePeriodSeconds();
            } else if (status === interfaces_1.MessageStatus.IN_CHALLENGE_PERIOD) {
                const stateRoot = await this.getMessageStateRoot(resolved, messageIndex);
                const challengePeriod = await this.getChallengePeriodSeconds();
                const targetBlock = await this.l1Provider.getBlock(stateRoot.batch.blockNumber);
                const latestBlock = await this.l1Provider.getBlock('latest');
                return Math.max(challengePeriod - (latestBlock.timestamp - targetBlock.timestamp), 0);
            } else {
                throw new Error(`unexpected message status`);
            }
        }
    }
    async getChallengePeriodSeconds() {
        if (!this.bedrock) {
            return (await this.contracts.l1.StateCommitmentChain.FRAUD_PROOF_WINDOW()).toNumber();
        }
        const oracleVersion = await this.contracts.l1.L2OutputOracle.version();
        const challengePeriod = oracleVersion === '1.0.0' ? ethers_1.BigNumber.from(await this.contracts.l1.OptimismPortal.provider.call({
            to: this.contracts.l1.OptimismPortal.address,
            data: '0xf4daa291'
        })) : await this.contracts.l1.L2OutputOracle.FINALIZATION_PERIOD_SECONDS();
        return challengePeriod.toNumber();
    }
    async getProvenWithdrawal(withdrawalHash) {
        if (!this.bedrock) {
            throw new Error('message proving only applies after the bedrock upgrade');
        }
        if (!await this.fpac()) {
            const provenWithdrawal = await this.contracts.l1.OptimismPortal.provenWithdrawals(withdrawalHash);
            if (provenWithdrawal.timestamp.eq(0)) {
                return null;
            } else {
                return provenWithdrawal;
            }
        }
        const numProofSubmitters = ethers_1.BigNumber.from(await this.contracts.l1.OptimismPortal2.numProofSubmitters(withdrawalHash)).toNumber();
        for(let i = 0; i < numProofSubmitters; i++){
            const proofSubmitter = await this.contracts.l1.OptimismPortal2.proofSubmitters(withdrawalHash, i);
            const provenWithdrawal = await this.contracts.l1.OptimismPortal2.provenWithdrawals(withdrawalHash, proofSubmitter);
            const game = new ethers_1.ethers.Contract(provenWithdrawal.disputeGameProxy, (0, utils_1.getContractInterfaceBedrock)('FaultDisputeGame'), this.l1SignerOrProvider);
            const status = await game.status();
            if (status === 1) {
                continue;
            } else if (status === 2) {
                return Object.assign(Object.assign({}, provenWithdrawal), {
                    proofSubmitter
                });
            } else if (status > 2) {
                throw new Error('got invalid game status');
            }
            const extraData = await game.extraData();
            let l2BlockNumber;
            try {
                ;
                [l2BlockNumber] = ethers_1.ethers.utils.defaultAbiCoder.decode([
                    'uint256'
                ], extraData);
            } catch (err) {
                continue;
            }
            if (await this.isValidOutputRoot(await game.rootClaim(), l2BlockNumber)) {
                return Object.assign(Object.assign({}, provenWithdrawal), {
                    proofSubmitter
                });
            }
        }
        return null;
    }
    async isValidOutputRoot(outputRoot, l2BlockNumber) {
        const cached = this._outputCache.find((other)=>{
            return other.root === outputRoot;
        });
        if (cached) {
            return cached.valid;
        }
        if (this._outputCache.length > 10000) {
            this._outputCache = this._outputCache.slice(5000);
        }
        try {
            const provider = (0, utils_1.toJsonRpcProvider)(this.l2Provider);
            const [block, proof] = await Promise.all([
                provider.send('eth_getBlockByNumber', [
                    (0, core_utils_1.toRpcHexString)(l2BlockNumber),
                    false
                ]),
                (0, utils_1.makeStateTrieProof)(provider, l2BlockNumber, this.contracts.l2.OVM_L2ToL1MessagePasser.address, ethers_1.ethers.constants.HashZero)
            ]);
            const output = ethers_1.ethers.utils.solidityKeccak256([
                'bytes32',
                'bytes32',
                'bytes32',
                'bytes32'
            ], [
                ethers_1.ethers.constants.HashZero,
                block.stateRoot,
                proof.storageRoot,
                block.hash
            ]);
            const valid = output === outputRoot;
            this._outputCache.push({
                root: outputRoot,
                valid
            });
            return valid;
        } catch (err) {
            return false;
        }
    }
    async getMessageBedrockOutput(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            throw new Error(`cannot get a state root for an L1 to L2 message`);
        }
        let proposal;
        let l2OutputIndex;
        if (await this.fpac()) {
            const gameType = await this.contracts.l1.OptimismPortal2.respectedGameType();
            const gameCount = await this.contracts.l1.DisputeGameFactory.gameCount();
            const latestGames = await this.contracts.l1.DisputeGameFactory.findLatestGames(gameType, Math.max(0, gameCount.sub(1).toNumber()), Math.min(100, gameCount.toNumber()));
            const matches = [];
            for (const game of latestGames){
                try {
                    const [blockNumber] = ethers_1.ethers.utils.defaultAbiCoder.decode([
                        'uint256'
                    ], game.extraData);
                    if (blockNumber.gte(resolved.blockNumber)) {
                        matches.push(Object.assign(Object.assign({}, game), {
                            l2BlockNumber: blockNumber
                        }));
                    }
                } catch (err) {
                    continue;
                }
            }
            for(let i = matches.length - 1; i > 0; i--){
                const j = Math.floor(Math.random() * (i + 1));
                [matches[i], matches[j]] = [
                    matches[j],
                    matches[i]
                ];
            }
            let match;
            for (const option of matches){
                if (await this.isValidOutputRoot(option.rootClaim, option.l2BlockNumber)) {
                    match = option;
                    break;
                }
            }
            if (!match) {
                return null;
            }
            l2OutputIndex = match.index;
            proposal = {
                outputRoot: match.rootClaim,
                timestamp: match.timestamp,
                l2BlockNumber: match.l2BlockNumber
            };
        } else {
            try {
                l2OutputIndex = await this.contracts.l1.L2OutputOracle.getL2OutputIndexAfter(resolved.blockNumber);
            } catch (err) {
                if (err.message.includes('L2OutputOracle: cannot get output')) {
                    return null;
                } else {
                    throw err;
                }
            }
            proposal = await this.contracts.l1.L2OutputOracle.getL2Output(l2OutputIndex);
        }
        return {
            outputRoot: proposal.outputRoot,
            l1Timestamp: proposal.timestamp.toNumber(),
            l2BlockNumber: proposal.l2BlockNumber.toNumber(),
            l2OutputIndex: l2OutputIndex.toNumber()
        };
    }
    async getMessageStateRoot(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            throw new Error(`cannot get a state root for an L1 to L2 message`);
        }
        const messageTxReceipt = await this.l2Provider.getTransactionReceipt(resolved.transactionHash);
        const messageTxIndex = messageTxReceipt.blockNumber - 1;
        const stateRootBatch = await this.getStateRootBatchByTransactionIndex(messageTxIndex);
        if (stateRootBatch === null) {
            return null;
        }
        const indexInBatch = messageTxIndex - stateRootBatch.header.prevTotalElements.toNumber();
        if (stateRootBatch.stateRoots.length <= indexInBatch) {
            throw new Error(`state root does not exist in batch`);
        }
        return {
            stateRoot: stateRootBatch.stateRoots[indexInBatch],
            stateRootIndexInBatch: indexInBatch,
            batch: stateRootBatch
        };
    }
    async getStateBatchAppendedEventByBatchIndex(batchIndex) {
        const events = await this.contracts.l1.StateCommitmentChain.queryFilter(this.contracts.l1.StateCommitmentChain.filters.StateBatchAppended(batchIndex));
        if (events.length === 0) {
            return null;
        } else if (events.length > 1) {
            throw new Error(`found more than one StateBatchAppended event`);
        } else {
            return events[0];
        }
    }
    async getStateBatchAppendedEventByTransactionIndex(transactionIndex) {
        const isEventHi = (event, index)=>{
            const prevTotalElements = event.args._prevTotalElements.toNumber();
            return index < prevTotalElements;
        };
        const isEventLo = (event, index)=>{
            const prevTotalElements = event.args._prevTotalElements.toNumber();
            const batchSize = event.args._batchSize.toNumber();
            return index >= prevTotalElements + batchSize;
        };
        const totalBatches = await this.contracts.l1.StateCommitmentChain.getTotalBatches();
        if (totalBatches.eq(0)) {
            return null;
        }
        let lowerBound = 0;
        let upperBound = totalBatches.toNumber() - 1;
        let batchEvent = await this.getStateBatchAppendedEventByBatchIndex(upperBound);
        if (batchEvent === null) {
            return null;
        }
        if (isEventLo(batchEvent, transactionIndex)) {
            return null;
        } else if (!isEventHi(batchEvent, transactionIndex)) {
            return batchEvent;
        }
        while(lowerBound < upperBound){
            const middleOfBounds = Math.floor((lowerBound + upperBound) / 2);
            batchEvent = await this.getStateBatchAppendedEventByBatchIndex(middleOfBounds);
            if (isEventHi(batchEvent, transactionIndex)) {
                upperBound = middleOfBounds;
            } else if (isEventLo(batchEvent, transactionIndex)) {
                lowerBound = middleOfBounds;
            } else {
                break;
            }
        }
        return batchEvent;
    }
    async getStateRootBatchByTransactionIndex(transactionIndex) {
        const stateBatchAppendedEvent = await this.getStateBatchAppendedEventByTransactionIndex(transactionIndex);
        if (stateBatchAppendedEvent === null) {
            return null;
        }
        const stateBatchTransaction = await stateBatchAppendedEvent.getTransaction();
        const [stateRoots] = this.contracts.l1.StateCommitmentChain.interface.decodeFunctionData('appendStateBatch', stateBatchTransaction.data);
        return {
            blockNumber: stateBatchAppendedEvent.blockNumber,
            stateRoots,
            header: {
                batchIndex: stateBatchAppendedEvent.args._batchIndex,
                batchRoot: stateBatchAppendedEvent.args._batchRoot,
                batchSize: stateBatchAppendedEvent.args._batchSize,
                prevTotalElements: stateBatchAppendedEvent.args._prevTotalElements,
                extraData: stateBatchAppendedEvent.args._extraData
            }
        };
    }
    async getMessageProof(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            throw new Error(`can only generate proofs for L2 to L1 messages`);
        }
        const stateRoot = await this.getMessageStateRoot(resolved, messageIndex);
        if (stateRoot === null) {
            throw new Error(`state root for message not yet published`);
        }
        const messageSlot = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.keccak256((0, core_utils_1.encodeCrossDomainMessageV0)(resolved.target, resolved.sender, resolved.message, resolved.messageNonce) + (0, core_utils_1.remove0x)(this.contracts.l2.L2CrossDomainMessenger.address)) + '00'.repeat(32));
        const stateTrieProof = await (0, utils_1.makeStateTrieProof)((0, utils_1.toJsonRpcProvider)(this.l2Provider), resolved.blockNumber, this.contracts.l2.OVM_L2ToL1MessagePasser.address, messageSlot);
        return {
            stateRoot: stateRoot.stateRoot,
            stateRootBatchHeader: stateRoot.batch.header,
            stateRootProof: {
                index: stateRoot.stateRootIndexInBatch,
                siblings: (0, utils_1.makeMerkleTreeProof)(stateRoot.batch.stateRoots, stateRoot.stateRootIndexInBatch)
            },
            stateTrieWitness: (0, core_utils_1.toHexString)(rlp.encode(stateTrieProof.accountProof)),
            storageTrieWitness: (0, core_utils_1.toHexString)(rlp.encode(stateTrieProof.storageProof))
        };
    }
    async getBedrockMessageProof(message, messageIndex = 0) {
        const resolved = await this.toCrossChainMessage(message, messageIndex);
        if (resolved.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            throw new Error(`can only generate proofs for L2 to L1 messages`);
        }
        const output = await this.getMessageBedrockOutput(resolved, messageIndex);
        if (output === null) {
            throw new Error(`state root for message not yet published`);
        }
        const withdrawal = await this.toLowLevelMessage(resolved, messageIndex);
        const hash = (0, utils_1.hashLowLevelMessage)(withdrawal);
        const messageSlot = (0, utils_1.hashMessageHash)(hash);
        const provider = (0, utils_1.toJsonRpcProvider)(this.l2Provider);
        const stateTrieProof = await (0, utils_1.makeStateTrieProof)(provider, output.l2BlockNumber, this.contracts.l2.BedrockMessagePasser.address, messageSlot);
        const block = await provider.send('eth_getBlockByNumber', [
            (0, core_utils_1.toRpcHexString)(output.l2BlockNumber),
            false
        ]);
        return {
            outputRootProof: {
                version: ethers_1.ethers.constants.HashZero,
                stateRoot: block.stateRoot,
                messagePasserStorageRoot: stateTrieProof.storageRoot,
                latestBlockhash: block.hash
            },
            withdrawalProof: stateTrieProof.storageProof,
            l2OutputIndex: output.l2OutputIndex
        };
    }
    async sendMessage(message, opts) {
        const tx = await this.populateTransaction.sendMessage(message, opts);
        if (message.direction === interfaces_1.MessageDirection.L1_TO_L2) {
            return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(tx);
        } else {
            return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l2Signer).sendTransaction(tx);
        }
    }
    async resendMessage(message, messageGasLimit, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(await this.populateTransaction.resendMessage(message, messageGasLimit, opts));
    }
    async proveMessage(message, opts, messageIndex = 0) {
        const tx = await this.populateTransaction.proveMessage(message, opts, messageIndex);
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(tx);
    }
    async finalizeMessage(message, opts, messageIndex = 0) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(await this.populateTransaction.finalizeMessage(message, opts, messageIndex));
    }
    async depositETH(amount, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(await this.populateTransaction.depositETH(amount, opts));
    }
    async withdrawETH(amount, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l2Signer).sendTransaction(await this.populateTransaction.withdrawETH(amount, opts));
    }
    async approval(l1Token, l2Token, opts) {
        const bridge = await this.getBridgeForTokenPair(l1Token, l2Token);
        return bridge.approval(l1Token, l2Token, (opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer);
    }
    async approveERC20(l1Token, l2Token, amount, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(await this.populateTransaction.approveERC20(l1Token, l2Token, amount, opts));
    }
    async depositERC20(l1Token, l2Token, amount, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l1Signer).sendTransaction(await this.populateTransaction.depositERC20(l1Token, l2Token, amount, opts));
    }
    async withdrawERC20(l1Token, l2Token, amount, opts) {
        return ((opts === null || opts === void 0 ? void 0 : opts.signer) || this.l2Signer).sendTransaction(await this.populateTransaction.withdrawERC20(l1Token, l2Token, amount, opts));
    }
}
exports.CrossChainMessenger = CrossChainMessenger; //# sourceMappingURL=cross-chain-messenger.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/l2-provider.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.asL2Provider = exports.isL2Provider = exports.estimateTotalGasCost = exports.estimateL2GasCost = exports.estimateL1GasCost = exports.estimateL1Gas = exports.getL1GasPrice = void 0;
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/contracts/dist/index.js [app-client] (ecmascript)");
const transactions_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/transactions/lib.esm/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const cloneDeep_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/lodash/cloneDeep.js [app-client] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/index.js [app-client] (ecmascript)");
const assert_1 = __turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/assert.js [app-client] (ecmascript)");
const getNonceForTx = async (provider, tx)=>{
    if (tx.nonce !== undefined) {
        return (0, utils_1.toNumber)(tx.nonce);
    } else if (tx.from !== undefined) {
        return (0, utils_1.toProvider)(provider).getTransactionCount(tx.from);
    } else {
        return 0xffffffff;
    }
};
const connectGasPriceOracle = (provider)=>{
    return new ethers_1.Contract(contracts_1.predeploys.OVM_GasPriceOracle, (0, contracts_1.getContractInterface)('OVM_GasPriceOracle'), (0, utils_1.toProvider)(provider));
};
const getL1GasPrice = async (l2Provider)=>{
    const gpo = connectGasPriceOracle(l2Provider);
    return gpo.l1BaseFee();
};
exports.getL1GasPrice = getL1GasPrice;
const estimateL1Gas = async (l2Provider, tx)=>{
    const gpo = connectGasPriceOracle(l2Provider);
    return gpo.getL1GasUsed((0, transactions_1.serialize)({
        to: tx.to,
        gasLimit: tx.gasLimit,
        gasPrice: tx.gasPrice,
        maxFeePerGas: tx.maxFeePerGas,
        maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
        data: tx.data,
        value: tx.value,
        chainId: tx.chainId,
        type: tx.type,
        accessList: tx.accessList,
        nonce: tx.nonce ? ethers_1.BigNumber.from(tx.nonce).toNumber() : await getNonceForTx(l2Provider, tx)
    }));
};
exports.estimateL1Gas = estimateL1Gas;
const estimateL1GasCost = async (l2Provider, tx)=>{
    const gpo = connectGasPriceOracle(l2Provider);
    return gpo.getL1Fee((0, transactions_1.serialize)({
        to: tx.to,
        gasLimit: tx.gasLimit,
        gasPrice: tx.gasPrice,
        maxFeePerGas: tx.maxFeePerGas,
        maxPriorityFeePerGas: tx.maxPriorityFeePerGas,
        data: tx.data,
        value: tx.value,
        chainId: tx.chainId,
        type: tx.type,
        accessList: tx.accessList,
        nonce: tx.nonce ? ethers_1.BigNumber.from(tx.nonce).toNumber() : await getNonceForTx(l2Provider, tx)
    }));
};
exports.estimateL1GasCost = estimateL1GasCost;
const estimateL2GasCost = async (l2Provider, tx)=>{
    const parsed = (0, utils_1.toProvider)(l2Provider);
    const l2GasPrice = await parsed.getGasPrice();
    const l2GasCost = await parsed.estimateGas(tx);
    return l2GasPrice.mul(l2GasCost);
};
exports.estimateL2GasCost = estimateL2GasCost;
const estimateTotalGasCost = async (l2Provider, tx)=>{
    const l1GasCost = await (0, exports.estimateL1GasCost)(l2Provider, tx);
    const l2GasCost = await (0, exports.estimateL2GasCost)(l2Provider, tx);
    return l1GasCost.add(l2GasCost);
};
exports.estimateTotalGasCost = estimateTotalGasCost;
const isL2Provider = (provider)=>{
    return Boolean(provider._isL2Provider);
};
exports.isL2Provider = isL2Provider;
const asL2Provider = (provider)=>{
    if ((0, exports.isL2Provider)(provider)) {
        return provider;
    }
    const l2Provider = (0, cloneDeep_1.default)(provider);
    const formatter = l2Provider.formatter;
    (0, assert_1.assert)(formatter, `provider.formatter must be defined`);
    const ogBlockFormatter = formatter.block.bind(formatter);
    formatter.block = (block)=>{
        const parsed = ogBlockFormatter(block);
        parsed.stateRoot = block.stateRoot;
        return parsed;
    };
    const ogBlockWithTxFormatter = formatter.blockWithTransactions.bind(formatter);
    formatter.blockWithTransactions = (block)=>{
        const parsed = ogBlockWithTxFormatter(block);
        parsed.stateRoot = block.stateRoot;
        parsed.transactions = parsed.transactions.map((tx, idx)=>{
            const ogTx = block.transactions[idx];
            tx.l1BlockNumber = ogTx.l1BlockNumber ? (0, utils_1.toNumber)(ogTx.l1BlockNumber) : ogTx.l1BlockNumber;
            tx.l1Timestamp = ogTx.l1Timestamp ? (0, utils_1.toNumber)(ogTx.l1Timestamp) : ogTx.l1Timestamp;
            tx.l1TxOrigin = ogTx.l1TxOrigin;
            tx.queueOrigin = ogTx.queueOrigin;
            tx.rawTransaction = ogTx.rawTransaction;
            return tx;
        });
        return parsed;
    };
    const ogTxResponseFormatter = formatter.transactionResponse.bind(formatter);
    formatter.transactionResponse = (tx)=>{
        const parsed = ogTxResponseFormatter(tx);
        parsed.txType = tx.txType;
        parsed.queueOrigin = tx.queueOrigin;
        parsed.rawTransaction = tx.rawTransaction;
        parsed.l1TxOrigin = tx.l1TxOrigin;
        parsed.l1BlockNumber = tx.l1BlockNumber ? parseInt(tx.l1BlockNumber, 16) : tx.l1BlockNumbers;
        return parsed;
    };
    const ogReceiptFormatter = formatter.receipt.bind(formatter);
    formatter.receipt = (receipt)=>{
        const parsed = ogReceiptFormatter(receipt);
        parsed.l1GasPrice = (0, utils_1.toBigNumber)(receipt.l1GasPrice);
        parsed.l1GasUsed = (0, utils_1.toBigNumber)(receipt.l1GasUsed);
        parsed.l1Fee = (0, utils_1.toBigNumber)(receipt.l1Fee);
        parsed.l1FeeScalar = parseFloat(receipt.l1FeeScalar);
        return parsed;
    };
    l2Provider.getL1GasPrice = async ()=>{
        return (0, exports.getL1GasPrice)(l2Provider);
    };
    l2Provider.estimateL1Gas = async (tx)=>{
        return (0, exports.estimateL1Gas)(l2Provider, tx);
    };
    l2Provider.estimateL1GasCost = async (tx)=>{
        return (0, exports.estimateL1GasCost)(l2Provider, tx);
    };
    l2Provider.estimateL2GasCost = async (tx)=>{
        return (0, exports.estimateL2GasCost)(l2Provider, tx);
    };
    l2Provider.estimateTotalGasCost = async (tx)=>{
        return (0, exports.estimateTotalGasCost)(l2Provider, tx);
    };
    l2Provider._isL2Provider = true;
    return l2Provider;
};
exports.asL2Provider = asL2Provider; //# sourceMappingURL=l2-provider.js.map
}}),
"[project]/node_modules/@eth-optimism/sdk/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/adapters/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/cross-chain-messenger.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/interfaces/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/l2-provider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@eth-optimism/sdk/dist/utils/index.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40eth-optimism_sdk_dist_5ea86942._.js.map